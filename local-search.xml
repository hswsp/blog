<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Multi-Decree Paxos</title>
    <link href="/2023/02/16/Multi-Paxos/"/>
    <url>/2023/02/16/Multi-Paxos/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自<a href="https://juejin.cn/post/6891459638546399245">理解分布式一致性:Paxos协议之Multi-Paxos</a></p></blockquote><p>在前面一篇文章我们讲到了Basic Paxos，本篇文章我会讲解更加通用和普遍的Multi-Paxos协议。</p><p>在Basic Paxos协议中，每一次执行过程都需要经历Prepare-&gt;Promise-&gt;Accept-&gt;Accepted 这四个步骤，这样就会导致消息太多，从而影响分布式系统的性能。 如果Leader足够稳定的话，Phase 1 里面的Prepare-&gt;Promise 完全可以省略掉，从而使用同一个Leader去发送Accept消息。 当然我们还要对请求消息做一些改造，这里我们在请求里面加入了轮数<code>I</code>，每过一轮，<code>I+1</code> 。 下面我们用序列图的形式尽可能的去展示Multi-Paxos的魅力。</p><h1 id="multi-paxos-without-failures">Multi-Paxos without failures</h1><p>下图我们展示一个基本的Multi-Paxos一次执行交互流程，系统有1个Client，1个Proposer， 3个Acceptor， 1个Learner。</p><figure><img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a67f5d240e094e01947f94d242677afe~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="multi-paxos-when-phase-1-can-be-skipped">Multi-Paxos when phase 1 can be skipped</h1><p>上面我们讲到在Multi-Paxos中，如果Leader足够稳定的话，在接下来的执行中，phase 1 的请求其实是可以被省略的，那么接下来我们看一下被省略的整个流程。 这里round number需要+1,表示已经进入下一轮了。 <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35340a553ea046c989cec0c56f01a6de~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" /></p><h1 id="multi-paxos-when-roles-are-collapsed">Multi-Paxos when roles are collapsed</h1><p>在Basic-Paxos中我们区分了很多角色，有Clients，Proposers, Acceptors and Learners。实际上Proposers, Acceptors and Learners可以合并成一个，我们把它统称为Server。下面是合并之后的序列图。 <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3180b6914d5e4b3e992e5df1d55e6c75~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" /></p><p>大家看看，是不是实现起来简单很多？</p><h1 id="multi-paxos-when-roles-are-collapsed-and-the-leader-is-steady">Multi-Paxos when roles are collapsed and the leader is steady</h1><p>同样的，当Leader很稳定的时候，我们可以在接下来的执行中忽略Phase 1. 如下图所示： <img src="https:////p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7292a7b04cc54393b23d9f901cc259a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" /></p>]]></content>
    
    
    <categories>
      
      <category>Distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Single-Decree Paxos</title>
    <link href="/2023/02/16/Basic-Paxos/"/>
    <url>/2023/02/16/Basic-Paxos/</url>
    
    <content type="html"><![CDATA[<p>大家可能在各个场合都听说过Paxos协议，毕竟这个开创性的协议是很多分布式协议的鼻祖，比如后面比较有名的Raft协议就是基于Paxos协议发展而来的。现实中也有很多产品在使用Paxos协议，像是Google的Chubby，Spanner，IBM的SVC等。 但是在笔者的学习过程中，发现介绍Paxos协议的很多，但是真正能把它讲明白的却很少。所以笔者特意花了一定的时间来研究Paxos协议，现把学习结果分析如下。</p><p>其实Paxos的作者Leslie Lamport早在2001年就写过一篇Paxos Made Simple的论文，来尽可能的简化Paxos的描述。大家可以在<a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf">Paxos Made Simple</a>获取作者的这篇论文。</p><h1 id="角色">角色</h1><p>在Paxos协议中存在5种角色: client, acceptor, proposer, learner, 和 leader。但在实际的实现中，一个服务可能同时扮演一个或者多个角色，这样做的考虑是为了减少消息延迟和消息数量，提升整个Paxos协议的工作效率。</p><p><strong>Client</strong> Client 是指请求的发起端，Client发送请求给分布式系统，并等待回复。</p><p><strong>Acceptor (Voters)</strong> Acceptor 可以看做是消息请求的存储器。一般来说Acceptors是由一定数量的服务组成的，当消息被发送给Acceptor， 只有大部分Acceptor确认接收此消息，该消息才会被存储，否则该消息将被丢弃。</p><p><strong>Proposer</strong> Proposer 可以看做Client的代理人，Proposer将Client的消息请求发送给Acceptors，并等待Acceptors的确认。在发生消息冲突时，Proposer将会尝试解决冲突。</p><p><strong>Learner</strong> Learners可以看做是所有被确认消息的执行器，一旦有Client的消息请求被Acceptors确认之后，Learners会做相应的处理（如：执行消息内容，发送回复给Client）。Learner可以有多个。</p><p><strong>Leader</strong> Paxos需要一个Leader来确保分布式系统可以按步骤进行下去。这里的Leader其实就是一个Proposer, Paxos协议会确保只有一个Proposer会被当做Leader。</p><h1 id="proposal-number-agreed-value">Proposal Number &amp; Agreed Value</h1><p>Proposal Number 也叫提案编号，我们用n表示，对于每一个Proposer来说，每一个提案编号都是唯一的。 Agreed Value也叫确认值，我们用v来表示，v是Acceptors确认的值。 两个值组合起来就是<code>（n，v）</code>。</p><h1 id="basic-paxos">Basic Paxos</h1><p>Paxos协议有很多变种，这里我们首先介绍一下Basis Paxos，后面的文章我们会继续介绍其他的Paxos协议。当然，既然是基础的Paxos协议，搞懂了它，对于其他的Paxos协议自然手到擒来。</p><p>在Basic Paxos 协议中，有很多次的执行过程，每次执行过程产生一个单独的执行结果。每次执行过程都有很多轮次，每一轮都有2个阶段。</p><h2 id="阶段1"><strong>阶段1</strong></h2><ul><li>阶段1A：<strong>Prepare</strong></li></ul><p>在Prepare阶段，一个Proposer会创建一个Prepare消息，每个Prepare消息都有唯一的提案编号<code>n</code>。<code>n</code>并不是将要提案的内容，而只是一个唯一的编号，用来标志这个Prepare的消息。 <strong>n必须比该Proposer之前用过的所有编号都大</strong>，一般来说我们可以以数字递增的方式来实现这个编号。 接下来Proposer会把该编号发送给Acceptors，只有大多数Acceptors接收到Proposer发来的消息，该消息才算是发送成功。</p><ul><li>阶段1B：<strong>Promise</strong></li></ul><p>所有的Acceptors都在等待从Proposers发过来的Prepare消息。当一个Acceptor收到从Proposer发过来的Prepare消息时候，会有两种情况：</p><p>该消息中的n是Acceptor所有收到的Prepare消息中最大的一个，那么该Acceptor必须返回一个Promise消息给Proposer，告诉它后面<strong>所有小于等于n的消息我都会忽略掉</strong>。如果该Acceptor在过去的某个时间已经确认了某个消息，那么它<strong>必须返回那个消息的proposal number m 和 accepted value w <code>（m，w）</code>。如果该Acceptor在过去并没有确认过任何消息，那么会返回NULL</strong>。</p><p>如果Prepare消息中的n小于该Acceptor之前接收到的消息，那么该消息会被Acceptor忽略（为了优化也可以返回一个拒绝消息给Proposer，告诉它不要再发小于n的消息给我了）。</p><h2 id="阶段2"><strong>阶段2</strong></h2><ul><li>阶段2A：<strong>Accept</strong></li></ul><p>如果一个Proposer从Acceptors接收到了足够多的Promises（&gt;n/2），这表示该Proposer可以开始下一个Accept请求的阶段了，在Accept阶段，Proposer需要设置一个值，然后向Acceptors发送Accept请求。 在阶段1B我们讲到了，如果Acceptor之前确认过消息，那么会把该消息编号和消息的值<code>（m，w）</code>返回给Proposer， Proposer收到多个Acceptors返回过来的消息之后，会从中<strong>选择编号最大的一个消息所对应的值z，并把他作为Accept请求的值<code>（n，z）</code>发给Acceptor</strong>。<strong>如果所有的Acceptors都没有确认过消息，那么Proposer可以自主选择要确认的值z</strong>。</p><ul><li>阶段 2b: Accepted</li></ul><p>当Acceptor接收到了Proposer的确认消息请求<code>（n，z）</code>，如果该Acceptor在阶段1b的时候没有promise只接收 &gt;n 的消息，那么该<code>（n，z）</code>消息就必须被Acceptor确认。 当<code>（n，z）</code>消息被Acceptor确认时，<strong>Acceptor会发送一个<code>Accepted（n，z）</code>消息给Proposer 和所有的Learner。当然在大部分情况下Proposer和Learner这两个角色可以合并</strong>。</p><p><strong>如果该Acceptor在阶段1b的时候promise只接收 &gt;n 的消息，那么该确认请求消息会被拒绝或者忽略。</strong></p><p>按照以上的逻辑就会出现在一个轮次中，Acceptor 确认多次消息的情况。什么情况下才会出现这样的情况呢？ 我们举个例子： Acceptor 收到<code>Accept（n，z）</code>，然后返回了<code>Accepted（n，z）</code>，接下来该Acceptor 又收到了<code>Prepare（n+1)</code>请求，按照阶段1B的原则，Acceptor会 <code>Promise （n+1，z）</code>，然后Acceptor 收到<code>Accept（n+1，z</code>），最后返回<code>Accepted（n+1，z）</code>。大家可以看到尽管Acceptor 确认了多次请求，但是最终会确保确认的值是保持一致的。</p><p>下面我们会用序列图的方式形象的描述Basis Paxos中可能出现的各种情况。</p><h1 id="basic-paxos-without-failures">Basic Paxos without failures</h1><p>在该序列图中，有1个Client，3个Acceptors和1个Learner，该图表示的是在第一轮执行过程中就成功的例子。 <img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/fb8a4ebe028341c6994d70b31a840732_tplv.png" alt="img" /></p><p>在第一轮就成功只是Paxos协议中一部分情况，其实在真实的世界中由于网络，系统等各种原因会造成多种情况的意外，最后导致协议往往并不能在第一轮就成功，往往需要经历好几轮。</p><h1 id="basic-paxos-when-an-acceptor-fails">Basic Paxos when an Acceptor fails</h1><p>如果有一个Acceptor因为各种原因挂掉了，3个Acceptors变成了2个Acceptors，还是满足&gt;n/2 的要求，所以还是会成功。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/26c0eab073344967a8c8065ec0f2fad1_tplv.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="basic-paxos-when-an-proposer-fails">Basic Paxos when an Proposer fails</h1><p>如果Proposer 在发送了一条Accept消息之后，但是还没收到Accepted消息之前就挂掉了，只有一个Acceptor接收到了Accept消息。那么整个Paxos协议就没法进行下去了，这时一个新的Leader（Proposer）会被选举出来，重新开始一轮新的共识。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/52d86813443d406b811f51b0f98e7549_tplv.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="basic-paxos-when-multiple-proposers-conflict">Basic Paxos when multiple Proposers conflict</h1><p>最后再描述一个最复杂的情况，即有多个Proposers认为他们是Leaders，并不断的发送Prepare请求。为什么会有多个Leaders呢？ 有可能一个Proposer当了一段时间Leader之后挂掉了，新的Proposer被选为Leader继续新的一轮共识。后面挂掉的Proposer又恢复了，它认为自己还是Leader，所以继续发送Prepare请求。 <img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/aaf1ecdbe422457caadf8118b9d23a41_tplv.png" alt="img" /> <img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/346f7a4b19734b39aff5166813111ac4_tplv.png" alt="img" /></p><p>本次的Basic Paxos协议就介绍到这里。后面我们会继续介绍Paxos的其他变种。</p>]]></content>
    
    
    <categories>
      
      <category>Distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 物理卷(PV)、逻辑卷(LV)、卷组(VG)管理</title>
    <link href="/2023/02/05/Linux%20volume/"/>
    <url>/2023/02/05/Linux%20volume/</url>
    
    <content type="html"><![CDATA[<h1 id="相关概念"><strong>相关概念</strong></h1><p>逻辑卷是使用逻辑卷组管理(Logic Volume Manager)创建出来的设备，如果要了解逻辑卷，那么首先需要了解逻辑卷管理中的一些概念。</p><ul><li>物理卷（Physical Volume,PV）：也就是物理磁盘分区，如果想要使用LVM来管理这个分区，可以使用fdisk将其ID改为LVM可以识别的值，即8e。</li><li>卷组（Volume Group,VG）：PV的集合</li><li>逻辑卷（Logic Volume,LV）：VG中画出来的一块逻辑磁盘</li></ul><p>了解概念之后，逻辑卷是如何产生的就很清晰了：物理磁盘或者磁盘分区转换为物理卷，一个或多个物理卷聚集形成一个或多个卷组，而逻辑卷就是从某个卷组里面抽象出来的一块磁盘空间。具体架构如下：</p><p><a href="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231715436-764135301.png"><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/823295-20200513231716132-1122001253.png" alt="clipboard" /></a></p><h1 id="为什么要使用逻辑卷"><strong>为什么要使用逻辑卷</strong></h1><p>对于物理磁盘，我们直接分区、格式化为文件系统之后就可以使用，那为什么还需要使用逻辑卷的方式来管理磁盘呢？我认为主要有2个原因：</p><ul><li>业务上使用大容量的磁盘。举个例子，我们需要在/data下挂载30TB的存储，对于单个磁盘，是无法满足要求的，因为市面上没有那么大的单块磁盘。但是如果我们使用逻辑卷，将多个小容量的磁盘聚合为一个大的逻辑磁盘，就能满足需求。</li><li>扩展和收缩磁盘。在业务初期规划磁盘时，我们并不能完全知道需要分配多少磁盘空间是合理的，如果使用物理卷，后期无法扩展和收缩，如果使用逻辑卷，可以根据后期的需求量，手动扩展或收缩。</li></ul><h1 id="创建物理卷pv"><strong>创建物理卷（PV）</strong></h1><p>通过上面的逻辑卷架构图，可以知道，如果要创建逻辑卷，需要先有物理磁盘或者磁盘分区，然后使用物理磁盘或磁盘分区创建物理卷，再使用物理卷创建卷组，最后使用卷组创建逻辑卷。接下来一步一步创建逻辑卷。</p><p>创建物理卷是创建逻辑卷的第一步，创建物理卷相关命令有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># pvcreate用于创建物理卷</span><br>pvcreate /dev/sdb<br><br><span class="hljs-comment"># pvdisplay、pvsca、pvs用于查看物理卷</span><br>pvdisplay<br>pvs<br>pvscan<br></code></pre></td></tr></table></figure><p>可以使用磁盘直接创建物理卷，也可以使用磁盘分区创建物理卷。两种方法稍微有些差距，下面进行说明。</p><h2 id="使用磁盘直接创建物理卷"><strong>使用磁盘直接创建物理卷</strong></h2><p>直接使用物理磁盘创建物理卷没有什么需要特别注意的，直接创建即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用fdisk -l确认磁盘，可以看到/dev/sdb未做分区处理</span><br>[root@masterdb ~]<span class="hljs-comment"># fdisk -l /dev/sdb</span><br><br>Disk /dev/sdb: 2147 MB, 2147483648 bytes, 4194304 sectors<br>Units = sectors of 1 * 512 = 512 bytes<br>Sector size (logical/physical): 512 bytes / 512 bytes<br>I/O size (minimum/optimal): 512 bytes / 512 bytes<br><br><span class="hljs-comment"># 使用pvcreate将sdb磁盘创建为物理卷</span><br>[root@masterdb ~]<span class="hljs-comment"># pvcreate /dev/sdb</span><br>  Physical volume <span class="hljs-string">&quot;/dev/sdb&quot;</span> successfully created.<br><br><span class="hljs-comment"># 使用pvdisplay确认物理卷信息</span><br>[root@masterdb ~]<span class="hljs-comment"># pvdisplay </span><br>  --- Physical volume ---<br>  PV Name               /dev/sda3<br>  VG Name               centos<br>  PV Size               &lt;68.73 GiB / not usable 4.00 MiB<br>  Allocatable           <span class="hljs-built_in">yes</span> (but full)<br>  PE Size               4.00 MiB<br>  Total PE              17593<br>  Free PE               0<br>  Allocated PE          17593<br>  PV UUID               FRxq7G-1XWu-dPeW-wEwO-322y-M9XR-0ExebA<br>   <br>  <span class="hljs-string">&quot;/dev/sdb&quot;</span> is a new physical volume of <span class="hljs-string">&quot;2.00 GiB&quot;</span><br>  --- NEW Physical volume ---<br>  PV Name               /dev/sdb<br>  VG Name               <br>  PV Size               2.00 GiB<br>  Allocatable           NO<br>  PE Size               0   <br>  Total PE              0<br>  Free PE               0<br>  Allocated PE          0<br>  PV UUID               nsL75f-o3fD-apyz-SSY0-miUi-4RYf-zVLIT6<br>   <br><span class="hljs-comment"># 也可以使用pvs确认物理卷信息,不过能够看到的信息比pvdisplay少</span><br>[root@masterdb ~]<span class="hljs-comment"># pvs </span><br>  PV         VG     Fmt  Attr PSize  PFree<br>  /dev/sda3  centos lvm2 a--  68.72g    0 <br>  /dev/sdb          lvm2 ---   2.00g 2.00g<br>[root@masterdb ~]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h2 id="使用磁盘分区创建物理卷"><strong>使用磁盘分区创建物理卷</strong></h2><p>磁盘分区之后，磁盘id为83，如果要使用逻辑卷管理，需要将id改为8e，才能创建物理卷。</p><p><a href="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231716700-400843767.png"><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/823295-20200513231717020-1298850562.png" alt="image" /></a></p><p>分区1修改id过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@masterdb ~]<span class="hljs-comment"># fdisk /dev/sdc </span><br> Welcome to fdisk (util-linux 2.23.2).<br><br>Changes will remain <span class="hljs-keyword">in</span> memory only, until you decide to write them.<br> Be careful before using the write <span class="hljs-built_in">command</span>.<br><br><br> Command (m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>): t     <span class="hljs-comment">#t可以修改分区代码</span><br> Partition number (1,2, default 2): 1            <span class="hljs-comment">#选择1分区进行修改</span><br> Hex code (<span class="hljs-built_in">type</span> L to list all codes): L          <span class="hljs-comment">#如果不知道类型，可以用”L”列出可以选择的修改代码</span><br><br>  0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        <br>  1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-<br>  2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-<br>  3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-<br>  4  FAT16 &lt;32M      40  Venix 80286     85  Linux extended  c7  Syrinx         <br>  5  Extended        41  PPC PReP Boot   86  NTFS volume <span class="hljs-built_in">set</span> da  Non-FS data    <br>  6  FAT16           42  SFS             87  NTFS volume <span class="hljs-built_in">set</span> db  CP/M / CTOS / .<br>  7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   <br>  8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       <span class="hljs-built_in">df</span>  BootIt         <br>  9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     <br>  a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        <br>  b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      <br>  c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs        <br>  e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            <br>  f  W95 Ext<span class="hljs-string">&#x27;d (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/</span><br><span class="hljs-string"> 10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b</span><br><span class="hljs-string"> 11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      </span><br><span class="hljs-string"> 12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      </span><br><span class="hljs-string"> 14  Hidden FAT16 &lt;3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary  </span><br><span class="hljs-string"> 16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    </span><br><span class="hljs-string"> 17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE </span><br><span class="hljs-string"> 18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto</span><br><span class="hljs-string"> 1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep        </span><br><span class="hljs-string"> 1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT            </span><br><span class="hljs-string"> 1e  Hidden W95 FAT1 80  Old Minix      </span><br><span class="hljs-string"> Hex code (type L to list all codes): 8e         #选择8e</span><br><span class="hljs-string"> Changed type of partition &#x27;</span>Linux<span class="hljs-string">&#x27; to &#x27;</span>Linux LVM<span class="hljs-string">&#x27;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Command (m for help): w               # 保存</span><br><span class="hljs-string"> The partition table has been altered!</span><br><span class="hljs-string"></span><br><span class="hljs-string">Calling ioctl() to re-read partition table.</span><br><span class="hljs-string"> Syncing disks.</span><br><span class="hljs-string"> [root@masterdb ~]#</span><br></code></pre></td></tr></table></figure><p>按照上面的过程，修改分区2，最终结果如下：</p><p><a href="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231717369-997595744.png"><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/823295-20200513231717728-1202598541.png" alt="image" /></a></p><p>接着进行创建物理卷(PV)即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@masterdb ~]<span class="hljs-comment"># pvcreate /dev/sdc1 </span><br>  Physical volume <span class="hljs-string">&quot;/dev/sdc1&quot;</span> successfully created.<br>[root@masterdb ~]<span class="hljs-comment"># pvcreate /dev/sdc2 </span><br>  Physical volume <span class="hljs-string">&quot;/dev/sdc2&quot;</span> successfully created.<br></code></pre></td></tr></table></figure><h1 id="创建扩容卷组"><strong>创建、扩容卷组</strong></h1><h2 id="创建卷组"><strong>创建卷组</strong></h2><p>有了PV就可以创建卷组了，创建卷组相关命令有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用vgcreate创建卷组</span><br>vgcreate VG_NAME device1 ... devicen<br><br><span class="hljs-comment"># 使用vgdosplay、vgscan、vgs命令查看卷组</span><br>vgdisplay<br>vgscan<br>vgs<br></code></pre></td></tr></table></figure><p>接下来演示使用sdb和sdc1创建一个卷组VG_TEST。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用vgcreate创建卷组VG_TEST,包含物理卷：/dev/sdb和/dev/sdc1</span><br>[root@masterdb ~]<span class="hljs-comment"># vgcreate VG_TEST /dev/sdb /dev/sdc1</span><br>  Volume group <span class="hljs-string">&quot;VG_TEST&quot;</span> successfully created<br><br><span class="hljs-comment"># 查看方法一：使用vgdisplay查看卷组信息</span><br>[root@masterdb ~]<span class="hljs-comment"># vgdisplay</span><br>  --- Volume group ---<br>  VG Name               VG_TEST<br>  System ID             <br>  Format                lvm2<br>  Metadata Areas        2<br>  Metadata Sequence No  1<br>  VG Access             <span class="hljs-built_in">read</span>/write<br>  VG Status             resizable<br>  MAX LV                0<br>  Cur LV                0<br>  Open LV               0<br>  Max PV                0<br>  Cur PV                2<br>  Act PV                2<br>  VG Size               2.99 GiB<br>  PE Size               4.00 MiB<br>  Total PE              766<br>  Alloc PE / Size       0 / 0   <br>  Free  PE / Size       766 / 2.99 GiB<br>  VG UUID               DmY2Nz-ietc-2Y8Y-7A1b-1cpT-qEeV-XrgURn<br>...  <br>   <br><span class="hljs-comment"># 查看方法二：使用vgscan查看卷组信息</span><br>[root@masterdb ~]<span class="hljs-comment"># vgscan</span><br>  Reading volume <span class="hljs-built_in">groups</span> from cache.<br>  Found volume group <span class="hljs-string">&quot;VG_TEST&quot;</span> using metadata <span class="hljs-built_in">type</span> lvm2<br>  Found volume group <span class="hljs-string">&quot;centos&quot;</span> using metadata <span class="hljs-built_in">type</span> lvm2<br><br><span class="hljs-comment"># 查看方法三：使用vgs查看卷组信息</span><br>[root@masterdb ~]<span class="hljs-comment"># vgs </span><br>  VG      <span class="hljs-comment">#PV #LV #SN Attr   VSize  VFree</span><br>  VG_TEST   2   0   0 wz--n-  2.99g 2.99g<br>  centos    1   4   0 wz--n- 68.72g    0<br></code></pre></td></tr></table></figure><h2 id="扩容卷组">扩容卷组</h2><p>如果在使用过程中，发现要使用的空间大于卷组的空间，可以对卷组进行扩容，把新的物理卷(PV)加入到卷组中，语法为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vgextend VG_NAME device1 ... devicen<br></code></pre></td></tr></table></figure><p>接下来演示将sdc2加入到卷组VG_TEST中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用vgextend扩容卷组VG_TEST</span><br>[root@masterdb ~]<span class="hljs-comment"># vgextend VG_TEST /dev/sdc2  </span><br>  Volume group <span class="hljs-string">&quot;VG_TEST&quot;</span> successfully extended<br></code></pre></td></tr></table></figure><p>最终结果如下，发现PV数量和VG容量都发生了变化</p><p><a href="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231718058-1985120739.png"><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/823295-20200513231718445-783339278.png" alt="image" /></a></p><h1 id="创建扩容逻辑卷"><strong>创建、扩容逻辑卷</strong></h1><h2 id="创建逻辑卷"><strong>创建逻辑卷</strong></h2><p>有了卷组，就可以创建逻辑卷(LV)了，创建逻辑卷相关命令有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用lvcreate创建逻辑卷</span><br>lvcreate –L SIZE –n LV_NAME VG_NAME<br><br>使用lvdisplay、lvscan、lvs查看逻辑卷<br>lvdisplay<br>lvscan<br>lvs<br></code></pre></td></tr></table></figure><p>接下来演示使用<code>VG_TEST</code>创建逻辑卷<code>lv_test</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用lvcreate创建逻辑卷lv_test</span><br>[root@masterdb ~]<span class="hljs-comment"># lvcreate -L 1g -n lv_test VG_TEST</span><br>  Logical volume <span class="hljs-string">&quot;lv_test&quot;</span> created.<br><br><span class="hljs-comment"># 查看方法一：使用lvdisplay查看逻辑卷</span><br>[root@masterdb ~]<span class="hljs-comment"># lvdisplay </span><br>  --- Logical volume ---<br>  LV Path                /dev/VG_TEST/lv_test<br>  LV Name                lv_test<br>  VG Name                VG_TEST<br>  LV UUID                RqWMOG-wCJJ-deu4-dIgv-c5hI-Bsqa-FHgh4E<br>  LV Write Access        <span class="hljs-built_in">read</span>/write<br>  LV Creation host, time masterdb, 2020-05-13 22:42:45 +0800<br>  LV Status              available<br>  <span class="hljs-comment"># open                 0</span><br>  LV Size                1.00 GiB<br>  Current LE             256<br>  Segments               1<br>  Allocation             inherit<br>  Read ahead sectors     auto<br>  - currently <span class="hljs-built_in">set</span> to     8192<br>  Block device           253:4<br>...<br>   <br><span class="hljs-comment"># 查看方法二：使用lvscan查看逻辑卷  </span><br>[root@masterdb ~]<span class="hljs-comment"># lvscan </span><br>  ACTIVE            <span class="hljs-string">&#x27;/dev/VG_TEST/lv_test&#x27;</span> [1.00 GiB] inherit<br>  ACTIVE            <span class="hljs-string">&#x27;/dev/centos/mysql&#x27;</span> [&lt;45.00 GiB] inherit<br>  ACTIVE            <span class="hljs-string">&#x27;/dev/centos/swap&#x27;</span> [&lt;3.73 GiB] inherit<br>  ACTIVE            <span class="hljs-string">&#x27;/dev/centos/home&#x27;</span> [10.00 GiB] inherit<br>  ACTIVE            <span class="hljs-string">&#x27;/dev/centos/root&#x27;</span> [10.00 GiB] inherit<br>  <br><span class="hljs-comment"># 查看方法三：使用lvs查看逻辑卷  </span><br>[root@masterdb ~]<span class="hljs-comment"># lvs </span><br>  LV      VG      Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert<br>  lv_test VG_TEST -wi-a-----   1.00g                                                    <br>  home    centos  -wi-ao----  10.00g                                                    <br>  mysql   centos  -wi-ao---- &lt;45.00g                                                    <br>  root    centos  -wi-ao----  10.00g                                                    <br>  swap    centos  -wi-ao----  &lt;3.73g<br></code></pre></td></tr></table></figure><p>创建完lv之后，格式化挂载即可使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建文件系统</span><br>[root@masterdb ~]<span class="hljs-comment"># mkfs.ext3 /dev/VG_TEST/lv_test </span><br>mke2fs 1.42.9 (28-Dec-2013)<br>Filesystem label=<br> OS <span class="hljs-built_in">type</span>: Linux<br>Block size=4096 (<span class="hljs-built_in">log</span>=2)<br>Fragment size=4096 (<span class="hljs-built_in">log</span>=2)<br> Stride=0 blocks, Stripe width=0 blocks<br> 65536 inodes, 262144 blocks<br> 13107 blocks (5.00%) reserved <span class="hljs-keyword">for</span> the super user<br> First data block=0<br> Maximum filesystem blocks=268435456<br> 8 block <span class="hljs-built_in">groups</span><br> 32768 blocks per group, 32768 fragments per group<br> 8192 inodes per group<br> Superblock backups stored on blocks: <br>     32768, 98304, 163840, 229376<br><br>Allocating group tables: <span class="hljs-keyword">done</span>                            <br> Writing inode tables: <span class="hljs-keyword">done</span>                            <br> Creating journal (8192 blocks): <span class="hljs-keyword">done</span><br> Writing superblocks and filesystem accounting information: <span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 创建挂载点</span><br>[root@masterdb ~]<span class="hljs-comment"># mkdir /test </span><br><br><span class="hljs-comment"># 挂载文件系统</span><br>[root@masterdb ~]<span class="hljs-comment"># mount /dev/VG_TEST/lv_test /test</span><br><br><span class="hljs-comment"># 确认结果</span><br>[root@masterdb ~]<span class="hljs-comment"># df –h </span><br> Filesystem                   Size  Used Avail Use% Mounted on<br> /dev/mapper/centos-root       10G  4.1G  5.9G  42% /<br> ...<br> /dev/mapper/VG_TEST-lv_test  976M  1.3M  924M   1% /test<br></code></pre></td></tr></table></figure><h2 id="扩容逻辑卷"><strong>扩容逻辑卷</strong></h2><p>使用如下命令进行扩容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用lvextend扩容lv，+SIZE代表增加的空间</span><br>lvextend -L +SIZE lv_device<br><br><span class="hljs-comment"># 调整文件系统的大小</span><br>resize2fs device lv_device<br></code></pre></td></tr></table></figure><p>接下来演示使用对逻辑卷lv_test扩容500M。</p><p>扩容前文件磁盘大小如下：</p><p><a href="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231718812-1860533846.png"><img src="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231719174-88647049.png" alt="image" /></a></p><p>进行扩容操作：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 对lv进行扩容，增加500M空间</span><br>[root@masterdb ~]<span class="hljs-comment"># lvextend -L +500M /dev/VG_TEST/lv_test </span><br>  Size of logical <span class="hljs-keyword">volume</span><span class="language-bash"> VG_TEST/lv_test changed from 1.00 GiB (256 extents) to &lt;1.49 GiB (381 extents).</span><br>  Logical <span class="hljs-keyword">volume</span><span class="language-bash"> VG_TEST/lv_test successfully resized.</span><br></code></pre></td></tr></table></figure><p>之后查看磁盘大小，未发生改变：</p><p><a href="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231719520-1867843347.png"><img src="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231719884-1598548425.png" alt="image" /></a></p><p>调整文件系统的大小：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用resize2fs调整文件系统的大小</span><br>[root@masterdb ~]<span class="hljs-comment"># resize2fs /dev/VG_TEST/lv_test </span><br>resize2fs 1.42.9 (28-Dec-2013)<br>Filesystem at /dev/VG_TEST/lv_test is mounted on /test; on-line resizing required<br>old_desc_blocks = 1, new_desc_blocks = 1<br>The filesystem on /dev/VG_TEST/lv_test is now 390144 blocks long.<br></code></pre></td></tr></table></figure><p>确认磁盘大小已经发生了改变</p><p><a href="https://img2020.cnblogs.com/blog/823295/202005/823295-20200513231720209-2045634523.png"><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/823295-20200513231720555-1199395255.png" alt="image" /></a></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Merge的三种操作</title>
    <link href="/2023/01/20/git-merge/"/>
    <url>/2023/01/20/git-merge/</url>
    
    <content type="html"><![CDATA[<p><code>git merge</code>的三种操作<code>merge</code>, <code>squash merge</code>, 和<code>rebase merge</code></p><p>举例来说：</p><p>假设在master分支的B点拉出一个新的分支dev，经过一段时间开发后：</p><ul><li>master分支上有两个新的提交M1和M2</li><li>dev分支上有三个提交D1，D2，和D3</li></ul><p>如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/6035627-cc0a26ddd001d80d.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>现在我们完成了dev分支的开发测试工作，需要把dev分支合并回master分支。</p><ol type="1"><li>merge</li></ol><p>这是最基本的merge，就是把提交历史原封不动的拷贝过来，包含完整的提交历史记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout master<br>$ git merge dev<br></code></pre></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/6035627-97f36fc78c9a99f6.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>此时<strong>还会生产一个<code>merge commit (D4')</code>，这个<code>merge commit</code>不包含任何代码改动</strong>，而包含在dev分支上的几个commit列表(<code>D1</code>, <code>D2</code>和<code>D3</code>)。查看git的提交历史(git log)可以看到所有的这些提交历史记录。</p><ol start="2" type="1"><li>squash merge:</li></ol><p>根据字面意思，<strong>这个操作完成的是压缩的提交</strong>；解决的是什么问题呢，由于在dev分支上执行的是开发工作，有一些很小的提交，或者是纠正前面的错误的提交，对于这类提交对整个工程来说不需要单独显示出来一次提交，不然导致项目的提交历史过于复杂；所以基于这种原因，我们可以把dev上的所有提交都合并成一个提交；然后提交到主干。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>git checkout master<br><span class="hljs-variable">$ </span>git merge --squash dev<br></code></pre></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/6035627-ce670a59578a3cdf.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这个例子中，我们把D1，D2和D3的改动合并成了一个D。</p><p>注意，<strong><code>squash merge</code>并不会替你产生提交，它只是把所有的改动合并，然后放在本地文件，需要你再次手动执行git commit操作</strong>；此时又要注意了，因为你要你手动commit，也就是说这个commit是你产生的，不是有原来dev分支上的开发人员产生的，提交者本身发生了变化。也可以这么理解，就是你把dev分支上的所有代码改动一次性porting到master分支上而已。</p><ol start="3" type="1"><li>rebase merge</li></ol><p>由于<strong>squash merge会变更提交者作者信息</strong>，这是一个很大的问题，后期问题追溯不好处理(当然也可以由分支dev的所有者来执行squash merge操作，以解决部分问题)，<strong>rebase merge可以保留提交的作者信息，同时可以合并commit历史</strong>，完美的解决了上面的问题。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$ </span>git checkout dev<br><span class="hljs-variable">$ </span>git rebase -i master<br><span class="hljs-variable">$ </span>git checkout master<br><span class="hljs-variable">$ </span>git merge dev<br></code></pre></td></tr></table></figure><p><strong>rebase merge分两步完成</strong>：</p><p><strong>第一步：执行rebase操作</strong>，结果是看起来dev分支是从M2拉出来的，而不是从B拉出来的，然后使用<code>-i</code>参数手动调整commit历史，是否合并如何合并。例如下<code>rebase -i</code>命令会弹出文本编辑框：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick &lt;D1&gt; Message <span class="hljs-keyword">for</span> commit <span class="hljs-comment">#1</span><br>pick &lt;D2&gt; Message <span class="hljs-keyword">for</span> commit <span class="hljs-comment">#2</span><br>pick &lt;D3&gt; Message <span class="hljs-keyword">for</span> commit <span class="hljs-comment">#3</span><br></code></pre></td></tr></table></figure><p>假设D2是对D1的一个拼写错误修正，因此可以不需要显式的指出来，我们把D2修改为<code>fixup</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick &lt;D1&gt; Message <span class="hljs-keyword">for</span> commit <span class="hljs-comment">#1</span><br>fixup &lt;D2&gt; Message <span class="hljs-keyword">for</span> commit <span class="hljs-comment">#2</span><br>pick &lt;D3&gt; Message <span class="hljs-keyword">for</span> commit <span class="hljs-comment">#3</span><br></code></pre></td></tr></table></figure><p>rebase之后的状态变为：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/6035627-fa1836ff4bfb6a27.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>D1'是D1和D2的合并。</p><p><strong>第二步：再执行merge操作</strong>，把dev分支合并到master分支：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/6035627-59db55375cfa040f.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>注意：在执行rebase的时候可能会出现冲突的问题，此时需要手工解决冲突的问题，然后执行(<code>git add</code>)命令；<strong>所有冲突解决完之后，这时不需要执行(<code>git commit</code>)命令，而是运行(<code>git rebase --continue</code>)命令，一直到rebase完成</strong>；如果中途想放弃rebase操作，可以运行(<code>git rebase --abort</code>)命令回到rebase之前的状态。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊云原生数据库的一致性</title>
    <link href="/2022/12/30/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <url>/2022/12/30/%E4%BA%91%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>摘录自<a href="https://www.zhihu.com/question/52337912/answer/2463729192">OceanBase的一致性协议为什么选择 paxos而不是raft?</a></p></blockquote><p>Raft or not? 为什么 Consensus-based replication 不是分布式数据库日志复制的银弹？</p><h1 id="背景">背景</h1><p>近期在跟团队同学聊天的过程中，听到了这样一句观点：</p><blockquote><p>“我们团队的目前的技术路线是不是错了？基于 Kafka/Pulsar 在做日志存储， 感觉更像是在做中间件，而不是在做数据库！”</p></blockquote><p>我在和很多朋友讨论的过程中，发现大家对于 <strong>Consistency</strong>、<strong>Consensus</strong>、<strong>Replication</strong> 这些基本概念存在很多误解，也有很多人认为只有基于 Paxos/Raft 这类分布式一致性算法的日志复制才是分布式数据库的唯一正解。</p><p>要说清楚这个问题，首先要梳理清楚下面的几个基本概念。</p><h2 id="replication">Replication</h2><p>Replication 指的是将数据拷贝到多个位置的过程（不同磁盘、进程、机器、集群），这一过程通常起到两个作用</p><ol type="1"><li>提升数据的可靠性 - 解决坏盘，物理机故障，集群异常时的故障恢复问题</li><li>加速查询 - 多副本可以同时使用提高性能</li></ol><p>Replication 的分类有很多，<strong>先明确一点，我们今天讨论的是增量日志的同步方式，而非全量数据的拷贝。</strong></p><p>除此之外，常见的 Replication 区分方式还有：同步/异步，强一致/最终一致，基于主从/去中心化等等。</p><p>Replication 模式的选择会影响系统的可用性和一致性，因此才有人提出了著名的 CAP 理论，在<a href="https://www.zhihu.com/search?q=网络隔离&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">网络隔离</a>无法避免的情况下，系统设计者<strong>必须在一致性和可用性之间进行权衡</strong>。</p><h2 id="consistency">Consistency</h2><p>简单理解一致性，就是同一时间下对于多副本进行读写是否可以得到一致的数据。</p><p>首先明确这里我们讨论的是 CAP 中的 “C”，而不是 ACID 中的 “C”。对于一致性级别的描述，我认为这篇 CosmosDB 的文档是最为靠谱的 <a href="https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels">https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels</a> （不得不承认Azure的产品文档要强过AWS不少，且有着满满的学院风）</p><p><strong>通常 OLTP 数据库会要求强一致性，或者说线性一致性</strong>，即：</p><ol type="1"><li>任何一次读都能读到某个数据的最近一次写入。</li><li>任何一个读取返回新值后，所有后续读取（在相同或其他客户端上）也必须返回新值。</li></ol><p>线性一致的本质是数据多副本之间新鲜度的保证（recency guarantee），它保证了一旦新的值被写入或读取，后续所有的读都会看到写入的值，直到它被再次覆盖。这也就意味着提供线性一致保证的分布式系统，用户可以不用关心多副本的实现，每个操作都可以实现原子有序。</p><h2 id="consensus">Consensus</h2><p>人们希望像使用单机系统一样使用分布式系统，因此不可避免的引入了“分布式共识”问题。</p><p>简单来说，就是当一个进程提议某一个值是什么之后，系统中所有的进程对这个值的变化能够达成一致，下图就是一个达成一致的过程。</p><figure><img src="http://cdn.spphoto.top/img/v2-64a4815b167d3a60b1b8719c051d1642_1440w.webp" alt="举个和“共识”相关例子" /><figcaption aria-hidden="true">举个和“共识”相关例子</figcaption></figure><p>最早的<a href="https://www.zhihu.com/search?q=共识算法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">共识算法</a>来源于 1988 年发表的 Viewstamped Replication 和 1989 年 Leslie 老爷子提出的 Paxos 算法。</p><p>近年来 Raft 算法也因为其相对而言比较容易实现，而在业界有了大量应用（比如在主流的 NewSQL 中：CockRoachDB、TiDB、Oceanbase 几乎都是基于 Raft 和 Paxos 实现的）</p><p>事实上，共识算法还有另外一类，也就是 <strong>leaderless consensus protocol</strong>。</p><p>这类算法被广泛的运用在<a href="https://www.zhihu.com/search?q=区块链&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">区块链</a>中，比如比特币所采用的 PoW 算法。这类算法由于效率问题，较少被应用于并发量较高的数据库系统中。</p><p><strong>值得注意的是，即使采用了<a href="https://www.zhihu.com/search?q=分布式共识算法&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">分布式共识算法</a>，也并不意味着系统就能够支持线性一致性。</strong></p><figure><img src="http://cdn.spphoto.top/img/v2-97725c81daee2bc3611bbb33e26ec148_1440w.webp" alt="Raft 复制状态机架构" /><figcaption aria-hidden="true">Raft 复制状态机架构</figcaption></figure><p>当我们在设计一个系统的时候，需要仔细考虑日志与状态机器的 commit 顺序问题，以及谨慎的维护 Raft/Paxos 的 leader 的 lease，避免在网络隔离的情况下出现脑裂。</p><p>Milvus 的可调一致性（Tunable Consistency）实际上非常类似于分布式共识算法中的 Follower Read 实现。Follower Read 指的在强一致性读的前提下使用 follower 副本来承载数据读取的任务，从而提升集群的吞吐能力并降低 leader 负载。其实现方式是通过询问主节点最新的日志 commit index 并等待该 commit index 的所有数据都已经 apply 到状态机上再提供查询服务。</p><p>我们在 Milvus 的设计过程中，并未采取每次查询都询问生产者 commit index 的策略，而是通过类似于 Flink 中 watermark 的机制定期通知查询执行节点 commit index 的位置。这种设计，主要是基于 Milvus 用户本身对数据一致性的要求并不高，通常情况下可以接受降低数据的可见性换取更高的性能，因此不需要每次查询都确定 commit index 的位置。</p><h1 id="为什么-consensus-based-replication-会如此流行">为什么 Consensus-based replication 会如此流行</h1><p>简单来说，就是人们喜欢线性一致性（Linearizability）。</p><p>无论是 Raft、ZAB，以及包括 Aurora 基于 Quorum 的日志协议，其实某种程度上都是 Paxos 算法的一种变种。而<strong>线性一致性又往往是实现分布式数据库 ACID 的基础</strong>，这让这种技术的在事务型数据库中具备了很强的不可替代性。</p><p>Consensused-based replication 之所以如此流行，还有以下三个原因：</p><p>第一点是相比于传统主从复制，尽管 Consensus-based replication 在 CAP 理论中更偏重 “CP”，且其依然提供了不错的 Availability，通常情况下进程崩溃，服务器重启都可以在秒级恢复。</p><p>第二点是 Raft 的提出极大的简化了 Consensus 算法的实现复杂度，越来越多的数据库选择了自己写 Raft 算法，或者改造现有的 Raft 实现。据不完全统计，Github 上超过 1000 stars 的 Raft 实现就有超过 15 种，<strong>最知名的如 Etcd 提供的 Raft 库以及蚂蚁开源的 sofa-jraft</strong>，基于这些算法做二次改造的项目更是不计其数。在国内，随着 TiKV、Etcd 等开源产品的流行，越来越多的人关注到这一技术领域。</p><p>第三点在于 Consensus-based replication 从性能上而言，确实能够满足现在的业务的需求。尤其是高性能 SSD 和<a href="https://www.zhihu.com/search?q=万兆网卡&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">万兆网卡</a>的推广，极大的降低了多副本同步的流量和落盘负担，使得 Paxox/Raft 算法的使用成为主流。</p><h1 id="consensus-based-replication-有什么问题">Consensus-based replication 有什么问题</h1><p>讽刺的是，Consensus-based replication 并不是分布式系统的解决一切的万能良药，恰巧因为可用性，复杂度，性能这些挑战，导致了它无法成为 replication 的唯一事实标准。</p><p><strong>1）可用性</strong></p><p>对比弱一致性系统，以及基于 Quorum 实现的分布式系统，Paxos/Raft 在进行优化之后往往对主副本有较强的依赖，<strong>导致其对抗 Grey Failure 的能力较弱</strong>。Consensus 重新选主的策略往往依赖于主节点长时间不响应，而这种策略并不能特别好的处理主节点慢或者抖的问题：实际生产中太多次遇到因为某些机器风扇坏掉，内存故障或者网卡频繁丢包导致的系统抖动问题。</p><p><strong>2）复杂度</strong></p><p>尽管已经有了很多的参考实现，做对 Consensus 算法并不是一件简单的事情，随着 Multi Raft、Parallel raft 之类的算法出现，日志和状态机之间的协同也需要更多的理论思考和测试验证。相反，我更加欣赏 <strong>PacificA、ISR 之类的 replication 协议，借助一个小的 Raft group 进行选主和 membership 管理，从而能够大幅降低设计复杂度</strong>。</p><p><strong>3）性能成本</strong></p><p>云原生时代，<strong>EBS 和 S3 等共享存储方案越来越多的替代了本地存储</strong>，数据可靠性和一致性已经可以得到很好的保证。基于分布式共识来实现数据多副本已经不再是刚性需求，且这种复制方式存在数据冗余放置的问题（基于 Consensus 本身需要多副本，EBS 自身又是多副本）。对于跨机房/跨云的数据备份而言，过于追求一致性的代价除了牺牲可用性，也牺牲了请求延迟（参考 <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/PACELC_theorem">https://en.wikipedia.org/wiki/PACELC_theorem</a> )，造成性能的大幅下降，因此绝大多数业务场景下线性一致性不会成为跨机房融灾的刚性需求。</p><h1 id="云原生时代究竟应该采用什么样的日志复制策略">云原生时代，究竟应该采用什么样的日志复制策略</h1><p>聊了那么多 Consensus-based replication 的优势和劣势，到底什么才是<a href="https://www.zhihu.com/search?q=云原生时代&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">云原生时代</a>数据库应该采用的 Replication 策略呢？</p><p>不可否认，基于 raft 和 <a href="https://www.zhihu.com/search?q=paxos&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">paxos</a> 的算法依然会被很多 OLTP 数据库所采用，不过我们应该可以从 PacificA 协议、Socrates、Aurora、Rockset 中看出一些新的趋势。</p><p>在介绍具体的实现之前，先提出我总结出的两个原则：</p><p><strong>1）Replication as a service</strong></p><p>使用一个<strong>专门用于同步数据的微服务</strong>，而非将同步模块和存储模块紧耦合在一个进程里。</p><p><strong>2）“套娃”</strong></p><p>前面已经说了，避免 Single Point Failure，似乎逃不开 Paxos 的限制，但如果我们把问题缩小，把 leader election 交给 raft/paxos 实现（比如基于 chubby、zk、etcd 这类服务），那么 log replication 就可以大幅简化，性能成本的问题也迎刃而解！分享几个我很喜欢的设计方案。</p><p>第一个例子，我最喜欢的协议是微软的 PacificA，这篇文章的 paper 发布于 08 年，相比 paxos 的逻辑完备性，PacificA 更关注工程。当年我们在阿里云设计自研 Lindorm 数据库的强一致方案的时候，就发现我们的方案跟 PacificA 非常的相似。</p><p>微软的 PacificA 的实现也非常简单，对于数据同步链路，primary 复制给 secondary 的时候等待所有的节点 ack 该请求后，才被认为是提交，因此线性一致性是非常容易保证的。</p><p>PacificA 的可用性保证更加简单，以 Zk、etcd 这一类系统来进行选主、或者完成成员变更操作。也就是说主挂了，lease 消失，备服务会申请替换为主将主节点退群。备挂了，primary 会申请让 secondary 退群。</p><p>第二个例子，我很欣赏的系统是 Socrates，不得不说微软产品确实很符合我个人的技术审美。</p><p>Socrates 的核心特点就是“解耦计算-日志-存储”。把日志和存储拆开，日志基于一个单独的服务来实现。</p><figure><img src="http://cdn.spphoto.top/img/v2-2430aafb269e11205f22893f940984f7_1440w.webp" alt="Socrates 架构图" /><figcaption aria-hidden="true">Socrates 架构图</figcaption></figure><p>日志基于单独服务实现（XLog Service），利用低延迟存储实现持久化：在 Socrates 中用了一个组件叫 landing zone，做高速三副本持久化，虽然容量有限，只能做 <a href="https://www.zhihu.com/search?q=circular%20buffer&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">circular buffer</a>，但是很容易让我联想到 EMC 中用带电容的内存做数据持久化。</p><p>主节点会异步将日志分发给 log broker，并在 log broker 中完成数据落盘 Xstore（较低成本的数据存储），缓存在本地 SSD 进行加速读取，一旦数据落盘成功，LZ 中的 buffer 就可以被清理。这样一来，整个日志数据就分为了 LZ、本地 SSD 缓存和 Xstore 三层，近线数据充分利用热存储，可以更好的缓存提升故障恢复速度和提升 log tailing 的效率。</p><figure><img src="http://cdn.spphoto.top/img/v2-8b79dc9e83b8a9330dd798e0b64ad765_1440w.webp" alt="Socrates 中的日志服务" /><figcaption aria-hidden="true">Socrates 中的日志服务</figcaption></figure><p>第三个例子，我认为比较值得一提的是 AWS Aurora，这款数据库几乎成为了<a href="https://www.zhihu.com/search?q=云原生数据库&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">云原生数据库</a>的代名词。</p><p>首先 Aurora 也采用了非常典型的存储计算分离架构，存储层是一个针对 MySQL 的定制服务，负责 redo log、page 的持久化，完成 redo log 到 page 的转换。</p><p>Aurora 的强大之处在于使用 6 副本的 NWR 协议保证了写入的高可用性。相比于 DynamoDB 的 NWR，Aurora 由于只存在 single writer，可以产生递增的 log sequence numer，解决了传统 NWR 系统中最难规避的冲突仲裁问题。</p><p>事实上，通过 Single DB instance 和存储层 Quorum 的共同配合，其实是实现了一个类 Paxos 协议。Aurora paper 并未讨论上层 DB instance 的故障时如何判断，不过我的猜测是依然使用了依赖 Paxos、Raft、ZAB 协议的组件切换策略，组件在切换时可能会对下层的 storage 执行 lease recovery，保证不会同时出现双主发生脑裂（纯属个人猜测，欢迎纠正答疑）。</p><p>最后一个例子，有一个有意思的产品叫 Rockset，这是一家由 Facebook RocksDB 原团队的设计的分析型产品。</p><figure><img src="http://cdn.spphoto.top/img/v2-28bdfb93a9a3a8a45c029025aabcb27f_1440w-20250710233743114.webp" alt="RocksDB Cloud架构" /><figcaption aria-hidden="true">RocksDB Cloud架构</figcaption></figure><p>之后有机会可以单独聊聊<a href="https://www.zhihu.com/search?q=rockset&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">rockset</a>这款产品，在我看来它是 Snowflake 之外 OLAP 产品中云原生做的最好的。这里不得不提的是，他们像 Milvus 一样，直接使用了 Kafka/Kineses 作为分布式日志，使用S3作为存储，使用本地 SSD 作为缓存提升查询性能。更加有意思的是，Kafka 的数据复制协议 ISR 也跟 PacificA 有诸多类似之处，本质上也是一个“套娃”。<strong>做云原生服务，学会通过借力其他服务，降低系统实现复杂度已经是架构师的必修课。</strong></p><h1 id="总结">总结</h1><p>现在，越来越多的<a href="https://www.zhihu.com/search?q=云数据库&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">云数据库</a>，把日志 replication 做成了单独的 service。这极大了降低了添加只读副本/异构副本的成本，同时也更有利于日志存储服务的性能成本优化，<a href="https://www.zhihu.com/search?q=微服务化&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">微服务化</a>的设计也可以快速复用一些成熟的云上基础设施，这对于传统紧耦合的<a href="https://www.zhihu.com/search?q=数据库系统&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2463729192%7D">数据库系统</a>来说是不可想象的：这个独立的日志服务也许依赖了 Consensus-based replication，也可以采用“套娃”的策略，并且使用各种不同的一致性协议搭配 Paxos/Raft 来实现线性一致性。</p><p>最后，再分享一个例子。</p><p>很多年前，当我无意间听到了 Google Colossus 存储元信息的方式，不禁为它的设计拍案叫绝：Colossus 基于 GFS 存储所有的元信息，GFS 的数据存储在 Colossus 上，而 Colossus 中最原始的元信息因为已经足够的小，可以直接存储在 Chubby 上。这不就是一个“天然的”基于 Paxos 的、类似 Zookeeper 的协调服务嘛。</p><p>无论技术如何进步发展，其外在形式如何转变，深入了解和思考“技术发展背后”才是技术人更应该做的事情，也更符合第一性原理思维方式。</p><hr /><h1 id="参考文献">参考文献</h1><ul><li>Lamport L. Paxos made simple[J]. ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, December 2001), 2001: 51-58.</li><li>Ongaro D, Ousterhout J. In search of an understandable consensus algorithm[C]//2014 USENIX Annual Technical Conference (Usenix ATC 14). 2014: 305-319.</li><li>Oki B M, Liskov B H. Viewstamped replication: A new primary copy method to support highly-available distributed systems[C]//Proceedings of the seventh annual ACM Symposium on Principles of distributed computing. 1988: 8-17.</li><li>Lin W, Yang M, Zhang L, et al. PacificA: Replication in log-based distributed storage systems[J]. 2008.</li><li>Verbitski A, Gupta A, Saha D, et al. Amazon aurora: On avoiding distributed consensus for i/os, commits, and membership changes[C]//Proceedings of the 2018 International Conference on Management of Data. 2018: 789-796.</li><li>Antonopoulos P, Budovski A, Diaconu C, et al. Socrates: The new sql server in the cloud[C]//Proceedings of the 2019 International Conference on Management of Data. 2019: 1743-1756.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM CPU 使用率飙高问题的排查过程</title>
    <link href="/2022/11/07/Troubleshoot-High-CPU-Usage/"/>
    <url>/2022/11/07/Troubleshoot-High-CPU-Usage/</url>
    
    <content type="html"><![CDATA[<h1 id="问题现象">问题现象</h1><p>首先，我们一起看看通过 VisualVM 监控到的机器 CPU 使用率图：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/1.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>如上图所示，在 下午3:45 分之前，CPU 的使用率明显飙高，最高飙到近 100%，为什么会出现这样的现象呢？</p><h1 id="排查过程">排查过程</h1><p><strong>Step 1：</strong> 使用top命令，查询资源占用情况：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/2.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>如上图所示，显示了服务器当前的资源占用情况，其中PID为5456的进程占用的资源最多。</p><p>在这里，我们也<strong>使用<code>top -p PID</code>命令，查询指定PID的资源占用情况</strong>：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/3.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p><strong>Step 2：</strong> <strong>使用<code>ps -mp PID -o THREAD,tid,time</code>命令，查询该进程的线程情况</strong>：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/4.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>在这里，我们也使用<code>ps -mp PID -o THREAD,tid,time | sort -rn</code>命令，将该进程下的线程按资源使用情况倒序展示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/5.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p><strong>Step 3：</strong> 使用<strong><code>printf "%x\n" PID</code>命令，将PID转为十六进制的TID</strong>：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/6.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>在这里，我们之所以需要将PID转为十六进制是因为<strong>在堆栈信息中，TID是以十六进制形式存在的</strong>。</p><p><strong>Step 4：</strong> <strong>使用<code>jstack PID | grep TID -A 100</code>命令，查询堆栈信息</strong>：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/7.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>如上图所示，显示该进程下多个线程均处于<code>TIMED_WAITING</code>状态。</p><p>虽然线程处于<code>WAITING</code>或者<code>TIMED_WAITING</code>状态都不会消耗 CPU，但是线程频繁的挂起和唤醒却会消耗 CPU，而且代价高昂。</p><p>而上面之所以会出现 CPU 使用率飙高的情况，则是因为有人在做压测。</p><p>特别地，在 mock 底层接口的时候，使用了类似<code>TimeUnit.SECONDS.sleep(1)</code>这样的语句。</p><p>至于为何在 下午3:45 分之后，CPU 的使用率降下来了，则是因为停止了压测。</p><p>除此之外，我们还可以使用<code>jinfo</code>和<code>jstat</code>命令来查询 Java 进程的启动参数以及 GC 情况：</p><p><strong>使用<code>jinfo PID</code>命令，查询启动参数：</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/8.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>如上图所示，使用该命令我们主要是为了查询启动参数，如初始化堆大小、垃圾回收器等配置。</p><p><strong>使用<code>jstat -gcutil PID 1000</code>命令，查询 GC 情况：</strong></p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/9.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>如上图所示，显示了PID为20567的 Java 进程每秒的 GC 情况，其中<strong>1000表示 GC 状态的更新频率</strong>，单位为毫秒。</p><h1 id="reference">Reference</h1><ol type="1"><li><a href="https://www.eginnovations.com/blog/troubleshoot-java-cpu-issues/">High Java CPU Usage – Troubleshooting Tips</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka两年踩过的一些非比寻常的坑</title>
    <link href="/2022/11/06/kafka-practice/"/>
    <url>/2022/11/06/kafka-practice/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文章摘录自 <a href="https://mp.weixin.qq.com/s/YPkE3Tsu3RVbhfVZCBt1pQ">苏三说技术</a>。汲取前人Kafaka使用经验！</p></blockquote><h1 id="前言">前言</h1><p>我的上家公司是做餐饮系统的，每天中午和晚上用餐高峰期，系统的并发量不容小觑。为了保险起见，公司规定各部门都要在吃饭的时间轮流值班，防止出现线上问题时能够及时处理。</p><p>我当时在后厨显示系统团队，该系统属于订单的下游业务。用户点完菜下单后，订单系统会通过发<code>kafka</code>消息给我们系统，系统读取消息后，做业务逻辑处理，持久化订单和菜品数据，然后展示到划菜客户端。这样厨师就知道哪个订单要做哪些菜，有些菜做好了，就可以通过该系统出菜。系统自动通知服务员上菜，如果服务员上完菜，修改菜品上菜状态，用户就知道哪些菜已经上了，哪些还没有上。这个系统可以大大提高后厨到用户的效率。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/640.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>事实证明，这一切的关键是消息中间件：<code>kafka</code>，如果它有问题，将会直接影响到后厨显示系统的功能。</p><p>接下来，我跟大家一起聊聊使用<code>kafka</code>两年时间踩过哪些坑？</p><h1 id="顺序问题">顺序问题</h1><h2 id="为什么要保证消息的顺序">1. 为什么要保证消息的顺序？</h2><p>刚开始我们系统的商户很少，为了快速实现功能，我们没想太多。既然是走消息中间件<code>kafka</code>通信，订单系统发消息时将订单详细数据放在消息体，我们后厨显示系统只要订阅<code>topic</code>，就能获取相关消息数据，然后处理自己的业务即可。</p><p>不过这套方案有个关键因素：<strong>要保证消息的顺序</strong>。</p><p>为什么呢？</p><p>订单有很多状态，比如：下单、支付、完成、撤销等，不可能<code>下单</code>的消息都没读取到，就先读取<code>支付</code>或<code>撤销</code>的消息吧，如果真的这样，数据不是会产生错乱？</p><p>好吧，看来保证消息顺序是有必要的。</p><h2 id="如何保证消息顺序">2.如何保证消息顺序？</h2><p>我们都知道<code>kafka</code>的<code>topic</code>是无序的，但是一个<code>topic</code>包含多个<code>partition</code>，<strong>每个<code>partition</code>内部是有序的</strong>。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/641.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>如此一来，思路就变得清晰了：只要保证生产者写消息时，<strong>按照一定的规则写到同一个<code>partition</code></strong>，<strong>不同的消费者读不同的<code>partition</code>的消息</strong>，就能保证生产和消费者消息的顺序。</p><p>我们刚开始就是这么做的，同一个<code>商户编号</code>的消息写到同一个<code>partition</code>，<code>topic</code>中创建了<code>4</code>个<code>partition</code>，然后部署了<code>4</code>个消费者节点，构成<code>消费者组</code>，一个<code>partition</code>对应一个消费者节点。从理论上说，这套方案是能够保证消息顺序的。<img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/642.png" alt="Image" /></p><p>一切规划得看似“天衣无缝”，我们就这样”顺利“上线了。</p><h2 id="出现意外">3.出现意外</h2><p>该功能上线了一段时间，刚开始还是比较正常的。</p><p>但是，好景不长，很快就收到用户投诉，说在划菜客户端有些订单和菜品一直看不到，无法划菜。</p><p>我定位到了原因，公司在那段时间网络经常不稳定，业务接口时不时报超时，业务请求时不时会连不上数据库。</p><p>这种情况对<code>顺序消息</code>的打击，可以说是<code>毁灭性</code>的。</p><p>为什么这么说？</p><p>假设订单系统发了：”下单“、”支付“、”完成“ 三条消息。<img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/643.png" alt="Image" /></p><p>而”下单“消息由于网络原因我们系统处理失败了，而后面的两条消息的数据是无法入库的，因为只有”下单“消息的数据才是完整的数据，其他类型的消息只会更新状态。</p><p>加上，我们当时没有做<code>失败重试机制</code>，使得这个问题被放大了。问题变成：一旦”下单“消息的数据入库失败，用户就永远看不到这个订单和菜品了。</p><p>那么这个紧急的问题要如何解决呢？</p><h2 id="解决过程">4.解决过程</h2><p>最开始我们的想法是：在消费者处理消息时，如果处理失败了，立马重试3-5次。但如果有些请求要第6次才能成功怎么办？不可能一直重试呀，这种同步重试机制，会阻塞其他商户订单消息的读取。</p><p>显然用上面的这种<code>同步重试机制</code>在出现异常的情况，会严重影响消息消费者的消费速度，降低它的吞吐量。</p><p>如此看来，我们不得不用<code>异步重试机制</code>了。</p><p>如果用异步重试机制，处理失败的消息就得保存到<code>重试表</code>下来。</p><p>但有个新问题立马出现：<strong>只存一条消息如何保证顺序？</strong></p><p>存一条消息的确无法保证顺序，假如：”下单“消息失败了，还没来得及异步重试。此时，”支付“消息被消费了，它肯定是不能被正常消费的。</p><p>此时，”支付“消息该一直等着，每隔一段时间判断一次，它前面的消息都有没有被消费?</p><p>如果真的这么做，会出现两个问题：</p><ol type="1"><li>”支付“消息前面只有”下单“消息，这种情况比较简单。但如果某种类型的消息，前面有N多种消息，需要判断多少次呀，这种判断跟订单系统的耦合性太强了，相当于要把他们系统的逻辑搬一部分到我们系统。</li><li>影响消费者的消费速度</li></ol><p>这时有种更简单的方案浮出水面：消费者在处理消息时，先判断该<code>订单号</code>在<code>重试表</code>有没有数据，如果有则直接把当前消息保存到<code>重试表</code>。如果没有，则进行业务处理，如果出现异常，把该消息保存到<code>重试表</code>。</p><p>后来我们用<code>elastic-job</code>建立了<code>失败重试机制</code>，如果重试了<code>7</code>次后还是失败，则将该消息的状态标记为<code>失败</code>，发邮件通知开发人员。</p><p>终于由于网络不稳定，导致用户在划菜客户端有些订单和菜品一直看不到的问题被解决了。现在商户顶多偶尔延迟看到菜品，比一直看不菜品好太多。</p><h1 id="消息积压">消息积压</h1><p>随着销售团队的市场推广，我们系统的商户越来越多。随之而来的是消息的数量越来越大，导致消费者处理不过来，经常出现消息积压的情况。对商户的影响非常直观，划菜客户端上的订单和菜品可能半个小时后才能看到。一两分钟还能忍，半个消息的延迟，对有些暴脾气的商户哪里忍得了，马上投诉过来了。我们那段时间经常接到商户投诉说订单和菜品有延迟。</p><p>虽说，加<code>服务器节点</code>就能解决问题，但是按照公司为了省钱的惯例，要先做系统优化，所以我们开始了<code>消息积压</code>问题解决之旅。</p><h2 id="消息体过大">1. 消息体过大</h2><p>虽说<code>kafka</code>号称支持<code>百万级的TPS</code>，但从<code>producer</code>发送消息到<code>broker</code>需要一次网络<code>IO</code>，<code>broker</code>写数据到磁盘需要一次磁盘<code>IO</code>（写操作），<code>consumer</code>从<code>broker</code>获取消息先经过一次磁盘<code>IO</code>（读操作），再经过一次网络<code>IO</code>。<img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/644.png" alt="Image" /></p><p>一次简单的消息从生产到消费过程，需要经过<code>2次网络IO</code>和<code>2次磁盘IO</code>。如果消息体过大，势必会增加IO的耗时，进而影响kafka生产和消费的速度。消费者速度太慢的结果，就会出现消息积压情况。</p><p>除了上面的问题之外，<code>消息体过大</code>，还会浪费服务器的磁盘空间，稍不注意，可能会出现磁盘空间不足的情况。</p><p>此时，我们已经到了需要优化消息体过大问题的时候。</p><p><strong>如何优化呢？</strong></p><p>我们重新梳理了一下业务，没有必要知道订单的<code>中间状态</code>，只需知道一个<code>最终状态</code>就可以了。</p><p>如此甚好，我们就可以这样设计了：</p><ol type="1"><li>订单系统发送的消息体只用包含：id和状态等关键信息。</li><li>后厨显示系统消费消息后，通过id调用订单系统的订单详情查询接口获取数据。</li><li>后厨显示系统判断数据库中是否有该订单的数据，如果没有则入库，有则更新。</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/645.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>果然这样调整之后，消息积压问题很长一段时间都没再出现。</p><h3 id="section"></h3><h2 id="路由规则不合理">2. 路由规则不合理</h2><p>还真别高兴的太早，有天中午又有商户投诉说订单和菜品有延迟。我们一查kafka的topic竟然又出现了消息积压。</p><p>但这次有点诡异，不是所有<code>partition</code>上的消息都有积压，而是只有一个。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/646.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>刚开始，我以为是消费那个<code>partition</code>消息的节点出了什么问题导致的。但是经过排查，没有发现任何异常。</p><p>这就奇怪了，到底哪里有问题呢？</p><p>后来，我查日志和数据库发现，有几个商户的订单量特别大，刚好这几个商户被分到同一个<code>partition</code>，使得该<code>partition</code>的消息量比其他<code>partition</code>要多很多。</p><p>这时我们才意识到，发消息时按<code>商户编号</code>路由<code>partition</code>的规则不合理，可能会导致有些<code>partition</code>消息太多，消费者处理不过来，而有些<code>partition</code>却因为消息太少，消费者出现空闲的情况。</p><p>为了避免出现这种分配不均匀的情况，我们需要对发消息的路由规则做一下调整。</p><p>我们思考了一下，用订单号做路由相对更均匀，不会出现单个订单发消息次数特别多的情况。除非是遇到某个人一直加菜的情况，但是加菜是需要花钱的，所以其实同一个订单的消息数量并不多。</p><p>调整后按<code>订单号</code>路由到不同的<code>partition</code>，同一个订单号的消息，每次到发到同一个<code>partition</code>。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/647.png" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>调整后，消息积压的问题又有很长一段时间都没有再出现。我们的商户数量在这段时间，增长的非常快，越来越多了。</p><h2 id="批量操作引起的连锁反应">3. 批量操作引起的连锁反应</h2><p>在高并发的场景中，消息积压问题，可以说如影随形，真的没办法从根本上解决。表面上看，已经解决了，但后面不知道什么时候，就会冒出一次，比如这次：</p><p>有天下午，产品过来说：有几个商户投诉过来了，他们说菜品有延迟，快查一下原因。</p><p>这次问题出现得有点奇怪。</p><p>为什么这么说？</p><p>首先这个时间点就有点奇怪，平常出问题，不都是中午或者晚上用餐高峰期吗？怎么这次问题出现在下午？</p><p>根据以往积累的经验，我直接看了<code>kafka</code>的<code>topic</code>的数据，果然上面消息有积压，但这次每个<code>partition</code>都积压了<code>十几万</code>的消息没有消费，比以往加压的消息数量增加了<code>几百倍</code>。这次消息积压得极不寻常。</p><p>我赶紧查服务监控看看消费者挂了没，还好没挂。又查服务日志没有发现异常。这时我有点迷茫，碰运气问了问订单组下午发生了什么事情没？他们说下午有个促销活动，跑了一个JOB批量更新过有些商户的订单信息。</p><p>这时，我一下子如梦初醒，是他们在JOB中批量发消息导致的问题。怎么没有通知我们呢？实在太坑了。</p><p>虽说知道问题的原因了，倒是眼前积压的这<code>十几万</code>的消息该如何处理呢？</p><p>此时，如果直接调大<code>partition</code>数量是不行的，历史消息已经存储到4个固定的<code>partition</code>，只有新增的消息才会到新的<code>partition</code>。我们重点需要处理的是已有的partition。</p><p>直接加服务节点也不行，因为<code>kafka</code>允许同组的多个<code>partition</code>被一个<code>consumer</code>消费，但不允许一个<code>partition</code>被同组的多个<code>consumer</code>消费，可能会造成资源浪费。</p><p>看来只有用多线程处理了。</p><p>为了紧急解决问题，我改成了用<code>线程池</code>处理消息，核心线程和最大线程数都配置成了<code>50</code>。</p><p>调整之后，果然，消息积压数量不断减少。</p><p>但此时有个更严重的问题出现：我收到了报警邮件，有两个订单系统的节点down机了。</p><p>不久，订单组的同事过来找我说，我们系统调用他们订单查询接口的并发量突增，超过了预计的好几倍，导致有2个服务节点挂了。他们把查询功能单独整成了一个服务，部署了6个节点，挂了2个节点，再不处理，另外4个节点也会挂。订单服务可以说是公司最核心的服务，它挂了公司损失会很大，情况万分紧急。</p><p>为了解决这个问题，只能先把线程数调小。</p><p>幸好，线程数是可以通过<code>zookeeper</code>动态调整的，我把核心线程数调成了<code>8</code>个，核心线程数改成了<code>10</code>个。</p><p>后面，运维把订单服务挂的2个节点重启后恢复正常了，以防万一，再多加了2个节点。为了确保订单服务不会出现问题，就保持目前的消费速度，后厨显示系统的消息积压问题，1小时候后也恢复正常了。<img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/648.png" alt="Image" /></p><p>后来，我们开了一次复盘会，得出的结论是：</p><ol type="1"><li>订单系统的批量操作一定提前通知下游系统团队。</li><li>下游系统团队多线程调用订单查询接口一定要做压测。</li><li>这次给订单查询服务敲响了警钟，它作为公司的核心服务，应对高并发场景做的不够好，需要做优化。</li><li>对消息积压情况加监控。</li></ol><p>顺便说一下，对于要求严格保证消息顺序的场景，可以将线程池改成多个队列，每个队列用单线程处理。</p><h2 id="表过大">4. 表过大</h2><p>为了防止后面再次出现消息积压问题，消费者后面就一直用多线程处理消息。</p><p>但有天中午我们还是收到很多报警邮件，提醒我们kafka的topic消息有积压。我们正在查原因，此时产品跑过来说：又有商户投诉说菜品有延迟，赶紧看看。这次她看起来有些不耐烦，确实优化了很多次，还是出现了同样的问题。</p><p>在外行看来：<strong>为什么同一个问题一直解决不了？</strong></p><p><strong>其实技术心里的苦他们是不知道的。</strong></p><p>表面上问题的症状是一样的，都是出现了菜品延迟，他们知道的是因为消息积压导致的。但是他们不知道深层次的原因，导致消息积压的原因其实有很多种。这也许是使用消息中间件的通病吧。</p><p>我沉默不语，只能硬着头皮定位原因了。</p><p>后来我查日志发现消费者消费一条消息的耗时长达<code>2秒</code>。以前是<code>500毫秒</code>，现在怎么会变成<code>2秒</code>呢？</p><p>奇怪了，消费者的代码也没有做大的调整，为什么会出现这种情况呢？</p><p>查了一下线上菜品表，单表数据量竟然到了<code>几千万</code>，其他的划菜表也是一样，现在单表保存的数据太多了。</p><p>我们组梳理了一下业务，其实菜品在客户端只展示最近<code>3天</code>的即可。</p><p>这就好办了，我们服务端存着<code>多余的数据</code>，不如把表中多余的数据归档。于是，DBA帮我们把数据做了归档，只保留最近<code>7天</code>的数据。</p><p>如此调整后，消息积压问题被解决了，又恢复了往日的平静。</p><h1 id="主键冲突">主键冲突</h1><p>别高兴得太早了，还有其他的问题，比如：报警邮件经常报出数据库异常：<code>Duplicate entry '6' for key 'PRIMARY'</code>，说主键冲突。</p><p>出现这种问题一般是由于有两个以上相同主键的sql，同时插入数据，第一个插入成功后，第二个插入的时候会报主键冲突。表的主键是唯一的，不允许重复。</p><p>我仔细检查了代码，发现代码逻辑会先根据主键从表中查询订单是否存在，如果存在则更新状态，不存在才插入数据，没得问题。</p><p>这种判断在并发量不大时，是有用的。但是如果在高并发的场景下，两个请求同一时刻都查到订单不存在，一个请求先插入数据，另一个请求再插入数据时就会出现主键冲突的异常。</p><p>解决这个问题最常规的做法是：<code>加锁</code>。</p><p>我刚开始也是这样想的，加数据库悲观锁肯定是不行的，太影响性能。加数据库乐观锁，基于版本号判断，一般用于更新操作，像这种插入操作基本上不会用。</p><p>剩下的只能用分布式锁了，我们系统在用redis，可以加基于redis的分布式锁，锁定订单号。</p><p>但后面仔细思考了一下：</p><ol type="1"><li>加分布式锁也可能会影响消费者的消息处理速度。</li><li>消费者依赖于redis，如果redis出现网络超时，我们的服务就悲剧了。</li></ol><p>所以，我也不打算用分布式锁。</p><p>而是选择使用mysql的<code>INSERT INTO ...ON DUPLICATE KEY UPDATE</code>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">table</span> (column_list)<br><span class="hljs-keyword">VALUES</span> (value_list)<br><span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span><br>c1 <span class="hljs-operator">=</span> v1, <br>c2 <span class="hljs-operator">=</span> v2,<br>...;<br></code></pre></td></tr></table></figure><p>它会先尝试把数据插入表，如果主键冲突的话那么更新字段。</p><p>把以前的<code>insert</code>语句改造之后，就没再出现过主键冲突问题。</p><h1 id="数据库主从延迟">数据库主从延迟</h1><p>不久之后的某天，又收到商户投诉说下单后，在划菜客户端上看得到订单，但是看到的菜品不全，有时甚至订单和菜品数据都看不到。</p><p>这个问题跟以往的都不一样，根据以往的经验先看<code>kafka</code>的<code>topic</code>中消息有没有积压，但这次并没有积压。</p><p>再查了服务日志，发现订单系统接口返回的数据有些为空，有些只返回了订单数据，没返回菜品数据。</p><p>这就非常奇怪了，我直接过去找订单组的同事。他们仔细排查服务，没有发现问题。这时我们不约而同的想到，会不会是数据库出问题了，一起去找<code>DBA</code>。果然，<code>DBA</code>发现数据库的主库同步数据到从库，由于网络原因偶尔有延迟，有时延迟有<code>3秒</code>。</p><p>如果我们的业务流程从发消息到消费消息耗时小于<code>3秒</code>，调用订单详情查询接口时，可能会查不到数据，或者查到的不是最新的数据。</p><p>这个问题非常严重，会导致直接我们的数据错误。</p><p>为了解决这个问题，我们也加了<code>重试机制</code>。调用接口查询数据时，如果返回数据为空，或者只返回了订单没有菜品，则加入<code>重试表</code>。</p><p>调整后，商户投诉的问题被解决了。</p><h1 id="重复消费">重复消费</h1><p><code>kafka</code>消费消息时支持三种模式：</p><ul><li>at most once模式 最多一次。保证每一条消息commit成功之后，再进行消费处理。消息可能会丢失，但不会重复。</li><li>at least once模式 至少一次。保证每一条消息处理成功之后，再进行commit。消息不会丢失，但可能会重复。</li><li>exactly once模式 精确传递一次。将offset作为唯一id与消息同时处理，并且保证处理的原子性。消息只会处理一次，不丢失也不会重复。但这种方式很难做到。</li></ul><p><code>kafka</code>默认的模式是<code>at least once</code>，但这种模式可能会产生重复消费的问题，所以我们的业务逻辑必须做幂等设计。</p><p>而我们的业务场景保存数据时使用了<code>INSERT INTO ...ON DUPLICATE KEY UPDATE</code>语法，不存在时插入，存在时更新，是天然支持幂等性的。</p><h1 id="多环境消费问题">多环境消费问题</h1><p>我们当时线上环境分为：<code>pre</code>(预发布环境) 和 <code>prod</code>(生产环境)，两个环境共用同一个数据库，并且共用同一个kafka集群。</p><p>需要注意的是，在配置<code>kafka</code>的<code>topic</code>的时候，要加前缀用于区分不同环境。pre环境的以pre_开头，比如：pre_order，生产环境以prod_开头，比如：prod_order，防止消息在不同环境中串了。</p><p>但有次运维在<code>pre</code>环境切换节点，配置<code>topic</code>的时候，配错了，配成了<code>prod</code>的<code>topic</code>。刚好那天，我们有新功能上<code>pre</code>环境。结果悲剧了，<code>prod</code>的有些消息被<code>pre</code>环境的<code>consumer</code>消费了，而由于消息体做了调整，导致<code>pre</code>环境的<code>consumer</code>处理消息一直失败。</p><p>其结果是生产环境丢了部分消息。不过还好，最后生产环境消费者通过重置<code>offset</code>，重新读取了那一部分消息解决了问题，没有造成太大损失。</p><h1 id="后记">后记</h1><p>除了上述问题之外，我还遇到过：</p><ul><li><code>kafka</code>的<code>consumer</code>使用自动确认机制，导致<code>cpu使用率100%</code>。</li><li><code>kafka</code>集群中的一个<code>broker</code>节点挂了，重启后又一直挂。</li></ul><p>这两个问题说起来有些复杂，我就不一一列举了，有兴趣的朋友可以关注我的公众号，加我的微信找我私聊。</p><p>非常感谢那两年使用消息中间件<code>kafka</code>的经历，虽说遇到过挺多问题，踩了很多坑，走了很多弯路，但是实打实的让我积累了很多宝贵的经验，快速成长了。</p><p>其实<code>kafka</code>是一个非常优秀的消息中间件，我所遇到的绝大多数问题，都并非<code>kafka</code>自身的问题（除了cpu使用率100%是它的一个bug导致的之外）。</p>]]></content>
    
    
    <categories>
      
      <category>Infrastructure</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java ThreadGroup</title>
    <link href="/2022/11/06/thread-group/"/>
    <url>/2022/11/06/thread-group/</url>
    
    <content type="html"><![CDATA[<h1 id="线程组概念理解">线程组概念理解</h1><p>在java的多线程处理中有线程组ThreadGroup的概念，<strong>ThreadGroup是为了方便线程管理出现了，可以统一设定线程组的一些属性，比如setDaemon，设置未处理异常的处理方法，设置统一的安全策略等等</strong>；也可以通过线程组方便的获得线程的一些信息。</p><p>每一个ThreadGroup都可以包含一组的子线程和一组子线程组，在一个<strong>进程中线程组是以树形的方式存在</strong>，通常情况下根线程组是system线程组。system线程组下是main线程组，默认情况下第一级应用自己的线程组是通过main线程组创建出来的。</p><p>我们可以通过下面代码片段看下一个简单的java application中线程组的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.outofmemory.concurrent;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadGroupDemo</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>printGroupInfo(Thread.currentThread());<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">appThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>()&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>System.out.println(<span class="hljs-string">&quot;do loop &quot;</span> + i);<br>&#125;<br>&#125;<br>&#125;);<br>appThread.setName(<span class="hljs-string">&quot;appThread&quot;</span>);<br>appThread.start();<br>printGroupInfo(appThread);<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printGroupInfo</span><span class="hljs-params">(Thread t)</span> &#123;<br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> t.getThreadGroup();<br>System.out.println(<span class="hljs-string">&quot;thread &quot;</span> + t.getName() + <span class="hljs-string">&quot; group name is &quot;</span> <br>+ group.getName()+ <span class="hljs-string">&quot; max priority is &quot;</span> + group.getMaxPriority()<br>+ <span class="hljs-string">&quot; thread count is &quot;</span> + group.activeCount());<br><br>ThreadGroup parent=group;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> parent;<br>parent = parent.getParent();<br><span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br> <br>System.out.println(current.getName() + <span class="hljs-string">&quot;&#x27;s parent is &quot;</span> + parent.getName());<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码打印结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">thread main group name is main max priority is 10 thread count is 1<br>main<span class="hljs-string">&#x27;s parent is system</span><br><span class="hljs-string">--------------------------</span><br><span class="hljs-string">thread appThread group name is main max priority is 10 thread count is 2</span><br><span class="hljs-string">main&#x27;</span>s parent is system<br>--------------------------<br><span class="hljs-keyword">do</span> loop 0<br><span class="hljs-keyword">do</span> loop 1<br><span class="hljs-keyword">do</span> loop 2<br><span class="hljs-keyword">do</span> loop 3<br><span class="hljs-keyword">do</span> loop 4<br></code></pre></td></tr></table></figure><p>在创建线程时可以通过构造函数指定其所在的线程组，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadGroup group=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;worker&quot;</span>);<br>Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group,<span class="hljs-string">&quot;the first thread of group&quot;</span>);<br></code></pre></td></tr></table></figure><p>通常情况下我们创建线程时可能不设置线程组，这时候<strong>创建的线程会和创建该线程的线程在一个组里面</strong>。</p><h1 id="线程组实践">线程组实践</h1><p>下面通过实例演示如何使用ThreadGroup，该实例中设定了线程组的Daemon属性，设置了线程组内线程的最大优先级，通过继承ThreadGroup的方式，重写了该线程组对于未处理异常的处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.outofmemory.concurrent;<br> <br><span class="hljs-keyword">import</span> java.net.SocketException;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadGroupDemo2</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">spiderGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpiderThreadGroup</span>(<span class="hljs-string">&quot;spiderGroup&quot;</span>);<br><span class="hljs-comment">//可以统一设定线程是否为守护线程</span><br>spiderGroup.setDaemon(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//可以设置线程组内的最大优先级</span><br>spiderGroup.setMaxPriority(Thread.NORM_PRIORITY);<br><br><span class="hljs-comment">//初始化线程</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">spiderThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(spiderGroup, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SocketException</span>());<br>&#125;<br><br>&#125;);<br><br><span class="hljs-comment">//启动线程</span><br>spiderThread.start();<br>&#125;<br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此类从ThreadGroup类继承重写了其uncaughtException方法，对于SocketException进行了特殊处理</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> outofmemory.cn</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpiderThreadGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadGroup</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpiderThreadGroup</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">super</span>(name);<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br><span class="hljs-keyword">if</span> (e.getCause() <span class="hljs-keyword">instanceof</span> SocketException) &#123;<br>System.out.println(<span class="hljs-string">&quot;socket exception should be process&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">super</span>.uncaughtException(t, e);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的实例代码会输出如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">socket exception should be process<br></code></pre></td></tr></table></figure><p>说明未处理异常已经被统一处理了。</p><p>下面我们通过另外一个示例演示如何通过线程组，方便的获得应用中一共有多少个活动线程，并打印这些活动线程的名字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.outofmemory.concurrent;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo3</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> Thread.currentThread().getThreadGroup();<br><span class="hljs-keyword">while</span> (g != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> g.getParent();<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>g = temp;<br>&#125;<br><br><span class="hljs-comment">//现在g就是跟线程组</span><br>System.out.println(<span class="hljs-string">&quot;active count is &quot;</span> + g.activeCount());<br><br>Thread[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[g.activeCount()];<br>g.enumerate(all);<br><span class="hljs-keyword">for</span> (Thread t : all) &#123;<br>System.out.println(t.getName());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>按理说我只有一个main方法，没有任何自定义线程，那么会输出几个线程呢？</p><p>下面是输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">active count is 5<br>Reference Handler<br>Finalizer<br>Signal Dispatcher<br>Attach Listener<br>main<br></code></pre></td></tr></table></figure><p>一共有5个线程，这5个线程除了main是我们自己代码run所在的线程，其他都是虚拟机启动的线程。</p><h1 id="线程组和线程池">线程组和线程池</h1><p>线程组和线程池是两个不同的概念，他们的作用完全不同，<strong>线程组是为了方便线程的管理，线程池是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</strong></p><p>在构建线程池时，ThreadPoolExcutor的构造方法中，生成线程工厂的参数ThreadFactory接口的实现类<strong>DefaultThreadFactory中有个属性，ThreadGroup</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                             <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                             TimeUnit unit,</span><br><span class="hljs-params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                             ThreadFactory threadFactory,</span><br><span class="hljs-params">                             RejectedExecutionHandler handler)</span> &#123;<br>       <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>           maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>           maximumPoolSize &lt; corePoolSize ||<br>           keepAliveTime &lt; <span class="hljs-number">0</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>       <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>       <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>       <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>       <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>       <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>       <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>       <span class="hljs-built_in">this</span>.handler = handler;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">poolId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br> <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String prefix;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> daemon;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> priority;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ThreadGroup threadGroup;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Multithreading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Multithreading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kibana使用之Lucene的语法查询</title>
    <link href="/2022/11/02/Lucene-grammar/"/>
    <url>/2022/11/02/Lucene-grammar/</url>
    
    <content type="html"><![CDATA[<p>Kibana使用的查询语法是Lucene的查询语法，下面了解下Lucene的查询语法，了解了Lucene的查询语法也就知道了改如何使用Kibana的使用方式。</p><p>Lucene查询语法以可读的方式书写，然后使用JavaCC进行词法转换，转换成机器可识别的查询。</p><h1 id="词语查询"><strong>词语查询</strong></h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;here&quot;</span>,<span class="hljs-string">&quot;there&quot;</span><br><span class="hljs-string">&quot;here,there&quot;</span><br></code></pre></td></tr></table></figure><h1 id="字段查询"><strong>字段查询</strong></h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">tag</span>:there<br><span class="hljs-attr">tag</span>:<span class="hljs-string">&quot;there are&quot;</span><br></code></pre></td></tr></table></figure><p>搜索语句是需要加上双引号，否则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">tag</span>:there are<br></code></pre></td></tr></table></figure><p>就意味着，搜索tag为there，或者包含are关键字的文档</p><h1 id="修饰符查询"><strong>修饰符查询</strong></h1><p>通过增加修饰，从而扩大查询的范围。通配符一般包括如下</p><blockquote><p>?:匹配单个字符 *:匹配0个或多个字符</p></blockquote><p>语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">?tere<br></code></pre></td></tr></table></figure><p>意味着搜索there、where等类似的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test*<br></code></pre></td></tr></table></figure><p>意味着搜索test、tests、tester</p><h1 id="模糊词查询">模糊词查询</h1><p>就是在词语后面加上符号~。语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">he~<br></code></pre></td></tr></table></figure><p>意味着搜索her或hei等词</p><p>也可以在~后面添加模糊系数，模糊系数[0-1]，越靠近1表示越相近，默认模糊系数为0.5。语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">he~<span class="hljs-number">0.8</span><br></code></pre></td></tr></table></figure><h1 id="邻近词查询"><strong>邻近词查询</strong></h1><p>语法如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;here there&quot;</span>~<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>代表搜索包含"here","there"的文档，这两个词中间可以有一部分内容（这部分的内容通过字符个数显示）能够匹配到结果的如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;here wowo wowo there&quot;</span><br><span class="hljs-string">&quot;here,wowow,wowow,there&quot;</span><br></code></pre></td></tr></table></figure><h1 id="范围查询"><strong>范围查询</strong>。</h1><p>可以指定最大值和最小值，会自动查找在这之间的文档。如果是单词，则会按照字典顺序搜索</p><blockquote><p>{}尖括号表示不包含最小值和最大值，可以单独使用 []方括号表示包含最小值和最大值，可以单独使用。如下：</p></blockquote><p>如果搜索成绩grade字段小于等于80分，大于60分的可以写成下面的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">grade</span>:&#123;<span class="hljs-number">60</span>,<span class="hljs-number">80</span>]<br></code></pre></td></tr></table></figure><p>如果搜索name在A和C之间的，可以使用如下的语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">name</span>:&#123;A,C&#125;<br></code></pre></td></tr></table></figure><h1 id="词语相关度查询"><strong>词语相关度查询</strong></h1><p>如果单词的匹配度很高，一个文档中或者一个字段中可以匹配多次，那么可以提升该词的相关度。使用符号^提高相关度。</p><p>提高jarkarta的比重<code>jakarta apache</code>可以采用下面的语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">jakarta^<span class="hljs-number">4</span> apache<br></code></pre></td></tr></table></figure><h1 id="布尔操作符"><strong>布尔操作符</strong></h1><p>支持多种操作符：</p><h2 id="and"><strong>AND</strong></h2><p>AND操作符用于连接两个搜索条件，仅当两个搜索条件都满足时，才认为匹配。通常用来做交集操作。也可以使用&amp;&amp;替换。</p><p>注意必须使用大写。如果不使用AND，而是and，可能会被单做关键词进行搜索！</p><p>例如：搜索同时包含a和b的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a <span class="hljs-variable constant_">AND</span> b<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a &amp;&amp; b<br></code></pre></td></tr></table></figure><h2 id="or"><strong>OR</strong></h2><p>OR操作符用于连接两个搜索条件，当其中一个条件满足时，就认为匹配。通常用来做并集操作。也可以使用||替换。注意必须使用大写。</p><p>例如：搜索包含a或者b的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a <span class="hljs-variable constant_">OR</span> b<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a || b<br></code></pre></td></tr></table></figure><h2 id="not"><strong>NOT</strong></h2><p>NOT操作符排除某个搜索条件。通常用来做差集操作也可以使用!替换。注意必须大写。</p><p>例如：搜索包含a，不包含b的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a <span class="hljs-variable constant_">NOT</span> b<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a &amp;&amp; !b<br></code></pre></td></tr></table></figure><p>在kibana中支持单独使用，如：排除包含test的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable constant_">NOT</span> test<br></code></pre></td></tr></table></figure><h2 id="加号"><strong>+（加号）</strong></h2><p>包含该操作符后跟着的搜索条件，如：搜索包含tom的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+tom<br></code></pre></td></tr></table></figure><p>作用和AND的差不多，但是支持单独使用</p><h2 id="减号"><strong>-（减号）</strong></h2><p>排除该操作符后跟着的搜索条件，如：搜索不包含tom的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-tom<br></code></pre></td></tr></table></figure><p>效果类似NOT</p><h1 id="分组"><strong>分组</strong></h1><p>支持使用小括号对每个子句进行分组，形成更为复杂的查询逻辑。 例如：要搜索包含a的文档中，也包含b或者c的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a <span class="hljs-variable constant_">AND</span> (b <span class="hljs-variable constant_">OR</span> c)<br></code></pre></td></tr></table></figure><p>也支持在字段中使用小括号。如：要搜索标题中，既包含a也包含b的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">title</span>:(+a +<span class="hljs-string">&quot;b&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="转义字符"><strong>转义字符</strong></h1><p>由于Lucene中支持很多的符号，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+ - &amp;&amp; || ! ( ) &#123; &#125; [ ] ^ <span class="hljs-string">&quot; ~ * ? : \</span><br></code></pre></td></tr></table></figure><p>因此如果需要搜索 (1+1):2 需要对改串进行转换，使用字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">\(<span class="hljs-number">1</span>\+<span class="hljs-number">1</span>\)\:<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h1 id="参考文档">参考文档：</h1><ol type="1"><li>http://www.cnblogs.com/xing901022/p/4974977.html</li><li>https://segmentfault.com/a/1190000002972420</li></ol>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Search</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDFS简介</title>
    <link href="/2022/10/20/Intro-to-HDFS/"/>
    <url>/2022/10/20/Intro-to-HDFS/</url>
    
    <content type="html"><![CDATA[<h1 id="相关背景资料"><strong>相关背景资料</strong></h1><p><strong>Hadoop</strong>：一个分布式系统基础架构，由Apache基金会开发。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力高速运算和存储。</p><p><strong>Distributed</strong>：分布式计算是利用互联网上的计算机的 CPU 的共同处理能力来解决大型计算问题的一种计算科学。</p><p><strong>File system</strong>：文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构；即在磁盘上组织文件的方法。也指用于存储文件的磁盘或分区，或文件系统种类。</p><p><strong>Hadoop 和 HDFS 的关系</strong></p><p>Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。</p><p>对外部客户机而言，HDFS 就像一个传统的分级文件系统。可以创建、删除、移动或重命名文件，等等。很多时候，我们就叫它DFS（Distributed File System）。</p><p>Hadoop 是一个以一种可靠、高效、可伸缩的方式进行处理的，能够对大量数据进行分布式处理的系统框架。</p><p><strong>HDFS是Hadoop兼容最好的标准级文件系统</strong>，因为Hadoop是一个综合性的文件系统抽象，所以HDFS不是Hadoop必需的。所以可以理解为Hadoop是一个框架，HDFS是Hadoop中的一个部件。</p><figure><img src="https://pic3.zhimg.com/80/e29f5144113ba7973a1798ce0ff10896_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="我们为什么需要hdfs"><strong>我们为什么需要HDFS</strong></h1><p>要说明需要HDFS，首先得说明一下，为什么在计算机系统中需要文件系统。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。简单的理解为，只要有文件管理，就得有文件系统。</p><p>文件系统由三部分组成：与文件管理有关软件、被管理文件以及实施文件管理所需<strong>数据结构</strong>。</p><figure><img src="https://pic1.zhimg.com/80/ab9d9ffe7f9dde6946421fa95161a1b0_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从系统角度来看，文件系统是对文件存储器空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。</p><p>文件系统是用于存储文件的，但是我们发现现有的文件系统忙于处理什么文件呢？</p><figure><img src="https://pic1.zhimg.com/80/cc3980e69efc13274219386deed981b0_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>看起来现有的磁盘能够胜任目前的数据处理，但对于我们来说有一个好消息和坏消息。</p><figure><img src="https://pic4.zhimg.com/80/009aa16f5f3370d66edeb774be35d057_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>磁盘面对的海量信息有证券交易所的每天1TB的信息；社交网站上2PB的图片；计算机每天产生的100GB到10TB的机器日志，缓存文件，RFID检测器等等。</p><figure><img src="https://pic1.zhimg.com/80/a67572fc6e7e717df85a527330fa9044_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>既然读取一块磁盘的所有数据需要很长时间，写入更是需要更长时间（写入时间一般是读取时间的3倍）。我们需要一个巨大文件难道得换传输速度10GB/S的磁盘（现在没有这样的磁盘），而且即使有文件为1ZB，或者小点10EB时，这样的磁盘也无法做到随读随取。</p><figure><img src="https://pic2.zhimg.com/80/b1130118a74eac7b8000c30e9814d211_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当数据集的大小超过一台独立物理计算机的存储能力时，就有必要对它进行分区并存储到若干台单独的计算机上。</p><figure><img src="https://pic1.zhimg.com/80/6b814eb4a3f0a91fad1a4d5c80f52fe4_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从概念图上看，分布化的文件系统会因为分布后的结构不完整，导致系统复杂度加大，并且引入的网络编程，同样导致分布式文件系统更加复杂。</p><figure><img src="https://pic2.zhimg.com/80/9013f3007fdf70b2f8f4440b7a8c3651_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>对于以上的问题我们来HDFS是如何迎刃而解的：</p><p>HDFS以流处理访问模式来存储文件的。</p><p>一次写入，多次读取。数据源通常由源生成或从数据源直接复制而来，接着长时间在此数据集上进行各类分析，大数据不需要搬来搬去。</p><figure><img src="https://pic3.zhimg.com/80/681968b6a79c44fa76dfb0d257ce3622_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>DFS是用流处理方式处理文件，每个文件在系统里都能找到它的本地化映像，所以对于用户来说，别管文件是什么格式的，也不用在意被分到哪里，只管从DFS里取出就可以了。</p><figure><img src="https://pic2.zhimg.com/80/228ca23d87b5e48e1e4a9ba96abef0f9_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>一般来说，文件处理过程中无法保证文件安全顺利到达，<strong>传统文件系统是使用本地校验方式保证数据完整</strong>，文件被散后，难道需要特意安排每个分片文件的校验码？</p><p>HDFS的回答是：NO！</p><p>分片数量和大小是不确定的，海量的数据本来就需要海量的校验过程，分片后加入每个分片的跟踪校验完全是在数满天恒星的同时数了他们的行星。</p><p>HDFS的解决方案是<strong>分片冗余，本地校验</strong>。</p><figure><img src="https://pic4.zhimg.com/80/554be0de2ab7c2543faa4eea17ed82db_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>直观上看，我们是给文件系统添堵，文件越来越多，实际上，DFS更加喜欢这样的架构。数据冗余式存储，直接将多份的分片文件交给分片后的存储服务器去校验。</p><figure><img src="https://pic3.zhimg.com/80/6f9faaca10c86e92724d49e607c93172_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>冗余后的分片文件还有个额外功能，只要冗余的分片文件中有一份是完整的，经过多次协同调整后，其他分片文件也将完整。</p><figure><img src="https://pic1.zhimg.com/80/954f0eba3c758fb69066169702a3b688_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>经过协调校验，无论是传输错误，I/O错误，还是个别服务器宕机，整个系统里的文件是完整的。</p><p>分布后的文件系统有个无法回避的问题，因为文件不在一个磁盘导致读取访问操作的延时，这个是HDFS现在遇到的主要问题。</p><p>现阶段，HDFS的配置是按照高数据吞吐量优化的，可能会以高时间延时为代价。但万幸的是，HDFS是具有很高弹性，可以针对具体应用再优化。</p><h1 id="hdfs-的概念"><strong>HDFS 的概念</strong></h1><p>通过上一节的得到的信息，我们了解了HDFS就是下面这个抽象图的具体实现：</p><figure><img src="https://pic1.zhimg.com/80/ccf74554a98945837f36f04d1679bdf8_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>解释一下，何为元数据：</p><p>元数据是用于描述要素、数据集或数据集系列的内容、覆盖范围、质量、管理方式、数据的所有者、数据的提供方式等有关的信息。更简单的说，是<strong>关于数据的数据</strong>。</p><p>HDFS就是将巨大的数据变成大量数据的数据。</p><p>磁盘存储文件时，是按照数据块来存储的，也就是说，<strong>数据块是磁盘的读/写最小单位</strong>。数据块也称磁盘块。</p><p>构建于单个磁盘上的文件系统是通过磁盘块来管理文件系统，一般来说，文件系统块的大小是磁盘块的整数倍。特别的，单个磁盘文件系统，小于磁盘块的文件会占用整个磁盘块。磁盘块的大小一般是512字节。</p><p>在HDFS中，也有块（block）这个概念，默认为64MB，每个块作为独立的存储单元。</p><p>与其他文件系统不一样，<strong>HDFS中每个小于块大小的文件不会占据整个块的空间</strong>。具体原因在后面的介绍。下面介绍为什么是64MB一个文件块：</p><p>为什么HDFS中的小文件不会占用整个块，而且需要64MB或者更大的一个块？</p><p>在文件系统中，系统存储文件时，需要定位该数据在磁盘中的位置，再进行传输处理。</p><p>定位在磁盘的位置是需要时间的，同样文件传输也是需要时间。</p><p><span class="math inline">\(T(存储时间)=T(定位时间)+T(传输时间)\)</span></p><p>如果每个要传输的块设置得足够大，那么从磁盘传输数据的时间可以明显大于定位这个块开始位置的时间。</p><figure><img src="https://pic4.zhimg.com/80/a595c1d4dc6bbf0df432be49bfe30d63_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当然不是设置每个块越大越好。</p><p>HDFS提供给MapReduce数据服务，而<strong>一般来说MapReduce的Map任务通常一次处理一个块中的数据</strong>，如果任务数太少（少于集群中节点的数量），就没有发挥多节点的优势，甚至作业的运行速度就会和单节点一样。</p><p>分布式的文件抽象能够带来的优势是：</p><ol type="1"><li><p>一个文件可以大于每个磁盘</p></li><li><p>文件不用全在一个磁盘上。</p></li><li><p>简化了存储子系统的设计。</p></li></ol><p>其实，HDFS对与用户来说，可以直接看成是一个巨大的硬盘</p><figure><img src="https://pic2.zhimg.com/80/d9d28044b5fd2c1957b2ff8d09b8d025_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以，HDFS和文件系统相似，用fsck指令可以显示块信息:<code>% hadoop fsck / -files -blocks</code></p><h1 id="hdfs-的关键运行机制"><strong>HDFS 的关键运行机制</strong></h1><p>HDFS是基于主从结构（master/slaver）构件：</p><figure><img src="https://pic1.zhimg.com/80/d754d8461b13c94276c8ef6db63adce8_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在HDFS的主从结构中，有<strong>两类节点 namenode和datanode</strong>。他们以管理者-工作者模式工作。</p><figure><img src="https://pic3.zhimg.com/80/530538f304285d5da7e0fa0aedc63af2_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>子节点才是HDFS真正的存储和检索地点</strong>，如果想在主节点做整个集群数据的索引并检索的话，请考虑可行性，毕竟<strong>HDFS不擅长做巨型索引。</strong></p><p>客户端（client）代表用户通过与namenode和datanode交互访问整个文件系统。可以是具体程序，也可以是应用。</p><figure><img src="https://pic2.zhimg.com/80/0fde49fffaafc86c9acfbc5ca5da5ad9_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以，用户在编程时，无需知道namenode和datanode也可以实现功能。</p><p>没有datanode，文件系统不会崩溃，文件系统只是无法存储文件，也不会丢失数据。<strong>没有namenode，文件系统会崩溃</strong>，文件系统上的所有文件将丢失（无法读出，因为无法定位元数据块的位置，也就无法根据datanode的块来重构文件）。</p><figure><img src="https://pic1.zhimg.com/80/7980ac213c113d31dde77b5c38413d90_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="如何使用hdfs"><strong>如何使用HDFS</strong></h1><p>HDFS是在安装并成功配置后即可使用。具体安装过程不再赘述。</p><p>无论是使用shell脚本，或者使用WEB UI进行操作，使用前必须得明白HDFS的配置。便于存储操作或者操作优化。</p><figure><img src="https://pic4.zhimg.com/80/383c91ea202d8151084c8b5e72d474c3_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>例如我们使用伪分布式配置（也就是1个namenode和1个datanode配置方式）。</p><figure><img src="https://pic2.zhimg.com/80/76541a89f578a657383d67350e5fea85_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>说明hdfs的URI是localhost，hdfs的守护进程将通过该属性确定namenode的主机和端口。分布式文件系统将文件存储为1份备份。</p><p><strong>常用HDFS命令</strong></p><figure><img src="https://pic4.zhimg.com/80/3f2deb2a9379d8c5eef99fed4841fdb7_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSM Tree:高性能海量数据写数据结构</title>
    <link href="/2022/10/18/LSM-tree/"/>
    <url>/2022/10/18/LSM-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>LSM-Tree 是一种设计思想。在此思想下，可以带来<strong>极高的写入速度</strong>。但是稍微<strong>牺牲了读取的速度</strong>。另外要知道，在此设计下，<strong>无法对事务有很好的支持</strong>。</p><p>还要知道，这种方式的写入方式，它是<strong>近实时</strong>的，在实时性上略有牺牲。 在此设计下，背后要进行merge，<strong>要花费很多的资源</strong></p><p>十多年前，谷歌发布了大名鼎鼎的"三驾马车"的论文，分别是GFS(2003年)，<a href="https://zhuanlan.zhihu.com/p/82399103">MapReduce</a>（2004年），BigTable（2006年），为开源界在大数据领域带来了无数的灵感，其中在 “BigTable” 的论文中很多很酷的方面之一就是它所使用的文件组织方式，这个方法更一般的名字叫 <strong>Log Structured-Merge Tree</strong>。在面对亿级别之上的海量数据的存储和检索的场景下，我们选择的数据库通常都是各种强力的NoSQL，比如Hbase，Cassandra，Leveldb，RocksDB等等，这其中前两者是Apache下面的顶级开源项目数据库，后两者分别是Google和Facebook开源的数据库存储引擎。而<strong>这些强大的NoSQL数据库都有一个共性，就是其底层使用的数据结构，都是仿照“BigTable”中的文件组织方式来实现的</strong>，也就是我们今天要介绍的LSM-Tree。</p><h1 id="什么是lsm-tree">什么是LSM-Tree</h1><p>LSM-Tree全称是<strong>Log Structured Merge Tree</strong>，是一种<strong>分层，有序，面向磁盘</strong>的数据结构，其核心思想是充分了利用了，磁盘批量的顺序写要远比随机写性能高出很多，如下图示：</p><figure><img src="https://pic3.zhimg.com/80/4c2d8dedccd4562f2cc4c2d282d7c730_1440w.webp?source=1940ef5c" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>围绕这一原理进行设计和优化，以此让写性能达到最优，<strong>正如我们普通的Log的写入方式</strong>，这种结构的写入，全部都是以Append的模式追加，不存在删除和修改。当然有得就有舍，这种结构虽然大大提升了数据的写入能力，却是以牺牲部分读取性能为代价，故此这种结构通常适合于<strong>写多读少的场景</strong>。故LSM被设计来提供比传统的B+树或者ISAM更好的写操作吞吐量，通过消去随机的本地更新操作来达到这个目标。<strong>这里面最典型的例子就属于Kakfa了，把磁盘顺序写发挥到了极致</strong>，故而在大数据领域成为了互联网公司标配的分布式消息中间件组件。</p><p>虽然这种结构的写非常简单高效，但其缺点是对读取特别是随机读很不友好，这也是为什么日志通常用在下面的两种简单的场景：</p><ol type="1"><li>数据是被整体访问的，大多数数据库的WAL（write ahead log）也称预写log，包括mysql的Binlog等</li><li><strong>数据是通过文件的偏移量offset访问的</strong>，比如Kafka。</li></ol><p>想要<strong>支持更复杂和高效的读取</strong>，比如按key查询和按range查询，就得需要做一步的设计，这也是LSM-Tree结构，除了利用磁盘顺序写之外，还划分了<strong>内存+磁盘多层的合并结构</strong>的原因，正是基于这种结构再加上不同的优化实现，才造就了在这之上的各种独具特点的NoSQL数据库，如Hbase，Cassandra，Leveldb，RocksDB，MongoDB，TiDB等。</p><h1 id="lsm-tree-合并思想">LSM-Tree 合并思想</h1><p>LSM 树由<strong>两个或以上的存储结构</strong>组成，比如在论文中为了方便说明使用了最简单的两个存储结构。<strong>一个存储结构常驻内存中</strong>，称为 C0 tree ，具体可以是任何方便健值查找的数据结构，比如红黑树、 map 之类，甚至可以是跳表。<strong>另外一个存储结构常驻在硬盘中</strong>，称为 C1 tree ，具体结构<strong>类似 B 树</strong>。 C1 所有节点都是 100% 满的，节点的大小为磁盘块大小。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/a00326d8931e4b045b6b47d696e63c60.png" alt="LSM-Tree 存储结构 1" /><figcaption aria-hidden="true">LSM-Tree 存储结构 1</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/d64cc63251dbd373a046d37c928cbd6d.png" alt="LSM-Tree 存储结构 2" /><figcaption aria-hidden="true">LSM-Tree 存储结构 2</figcaption></figure><p>如上图所示，数据库采用了基于 LSM Tree 结构作为数据库的存储引擎，<strong>数据被分为基线数据（ SSTable ）和增量数据（ MemTable ）两部分</strong>。</p><p><strong>基线数据被保存在磁盘中</strong>，当需要读取的时候会被加载到数据库的缓存中。</p><p>数据被不断插入（或者修改）时，在内存中缓存增量数据，<code>memtable</code>是红黑树或者跳表这样的有序<strong>内存</strong>数据结构，起到缓存和排序的作用。</p><p><strong>当增量数据达到一定阀值时，就把增量数据刷新到磁盘上</strong>，<strong>当磁盘上的增量数据达到一定阀值时再把磁盘上的增量数据和基线数据进行合并</strong>。</p><p>这个本身是 LSM 的核心设计思想，非常朴素，就是将对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘，从而大幅度提升性能。</p><p>关于树的节点数据结构，不同数据库在基于 LSM-Tree 思想实现具体存储引擎的时候，可以根据自己的特点去定义。</p><h1 id="lsm-tree-wal">LSM-Tree WAL</h1><p>谈及 LSM （ Log Structured Merge Tree ）树存储引擎，从字面意思上，其实我们基本能看到两层意思，第一个是 Merge ，就是我们上一节说到的合并思想；另外一个就是 Log ，就是我们接下来要说的 WAL 文件，从下面展示的基于 LSM 存储引擎的写的流程当中，我们可以看到 <strong>WAL 就是数据库的一个日志文件</strong>。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/f8035eb9e6e7e2cdcb5cc137d2d6a281.png" alt="LSM-Tree 写数据流程图" /><figcaption aria-hidden="true">LSM-Tree 写数据流程图</figcaption></figure><p>当插入一条数据时，<strong>数据先顺序写入磁盘保存的 WAL 文件中，之后插入到内存中的 Memtable 当中</strong>， Memtable 实际上保存的数据结构就是我们所述的内存当中的小树。这样就保证了数据的持久化，即使因为故障宕机，虽然内存里面的数据已经丢失，但是依然可以<strong>通过日志信息恢复当初内存里面的数据信息</strong>，并且都是<strong>顺序写</strong>，速度非常快。当 memtable 写入文件 SSTable 后，这个 log 文件的内容就不再需要了。而新的 memtable 会有新的 log 文件对应。</p><h1 id="sstable-和-lsm-tree">SSTable 和 LSM-Tree</h1><p>提到LSM-Tree这种结构，就得提一下LevelDB这个存储引擎，我们知道Bigtable是谷歌开源的一篇论文，很难接触到它的源代码实现。如果说<strong>Bigtable是分布式闭源的一个高性能的KV系统</strong>，那么LevelDB就是这个KV系统开源的单机版实现，最为重要的是LevelDB是由Bigtable的原作者 Jeff Dean 和 Sanjay Ghemawat 共同完成，可以说高度复刻了Bigtable 论文中对于其实现的描述。</p><p>在LSM-Tree里面，核心的数据结构就是SSTable，全称是<strong>Sorted String Table</strong>，SSTable的概念其 实也是来自于 Google 的 Bigtable 论文，论文中对 SSTable 的描述如下：</p><blockquote><p>An SSTable provides a persistent, ordered immutable map from keys to values, where both keys and values are arbitrary byte strings. Operations are provided to look up the value associated with a specified key, and to iterate over all key/value pairs in a specified key range. Internally, each SSTable contains a sequence of blocks (typically each block is 64KB in size, but this is configurable). <strong>A block index (stored at the end of the SSTable) is used to locate blocks</strong>; the index is loaded into memory when the SSTable is opened. A lookup can be performed with a single disk seek: we first find the appropriate block by performing a binary search in the in-memory index, and then reading the appropriate block from disk. <strong>Optionally, an SSTable can be completely mapped into memory</strong>, which allows us to perform lookups and scans without touching disk.</p></blockquote><p>如上所述，SSTable是一种拥有持久化，有序且不可变的的键值存储结构，它的key和value都是任意的字节数组，并且了提供了按指定key查找和指定范围的key区间迭代遍历的功能。<strong>SSTable内部包含了一系列可配置大小的Block块，典型的大小是64KB</strong>，关于这些Block块的index存储在SSTable的尾部，用于帮助快速查找特定的Block。当一个SSTable被打开的时候，<strong>index会被加载到内存</strong>，然后根据key在内存index里面进行一个二分查找，查到该key对应的磁盘的offset之后，然后去磁盘把响应的块数据读取出来。当然如果内存足够大的话，可以直接把SSTable直接通过MMap的技术映射到内存中，从而提供更快的查找。</p><figure><img src="https://img-blog.csdnimg.cn/20190521200155392.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>SSTable 在后台是要经过不断地排序合并，文件随着层次的加深，其大小也逐步变大。同时它也是可以启用压缩功能的，并且这种压缩不是将整个 SSTable 一起压缩，而是根据 locality 将数据分组，<strong>每个组分别压缩</strong>，这样的好处当读取数据的时候，我们不需要解压缩整个文件而是解压缩部分 Group 就可以读取。如图下图所示的情况， leve0 的 SSTable 达到数据量的阀值之后，会经过排序合并形成 Level1 的 SSTable ， Level1 的 SSTable 达到阀值之后，会经过排序合并成为 Level2 的 SSTable 文件。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/lsm-3.png" alt="LSM-Tree SSTable’s merge" /><figcaption aria-hidden="true">LSM-Tree SSTable’s merge</figcaption></figure><p>以上图中所示的文件合并过程是一个排序合并的过程，因此每一层都包含大量 SSTable 文件，但是键值值范围不重复，这样查询操作只需要查询这一层的一个 SSTable 文件即可。</p><h1 id="关于lsm-tree的读写原理">关于LSM-Tree的读写原理</h1><p>在LSM-Tree里，<strong>SSTable有一份在内存里面，其他的多级在磁盘上</strong>，如下图是一份完整的LSM-Tree图示：</p><figure><img src="https://img-blog.csdnimg.cn/20190521200208933.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NTQwMzA=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="lsm-tree写数据的过程">LSM-Tree写数据的过程</h2><ol type="1"><li><p>当收到一个写请求时，会先把该条数据记录在WAL Log里面，用作故障恢复。</p></li><li><p>当写完WAL Log后，会把该条数据写入内存的SSTable里面（<strong>删除是墓碑标记</strong>，更新是新记录一条的数据），也称Memtable。注意为了维持有序性在<strong>内存里面可以采用红黑树或者跳跃表</strong>相关的数据结构。（例如Redis里面Zset对象底层结构使用的就是跳表）</p></li><li><p><strong>当Memtable超过一定的大小后，会在内存里面冻结</strong>，变成不可变的Memtable，同时为了不阻塞写操作需要新生成一个Memtable继续提供服务。</p></li><li><p>把内存里面不可变的Memtable给dump到<strong>硬盘上</strong>的SSTable层中，此步骤也称为<strong>Minor Compaction</strong>，这里需要注意<strong>在L0层的SSTable是没有进行合并的，所以这里的key range在多个SSTable中可能会出现重叠</strong>，在层数大于0层之后的SSTable，不存在重叠key。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/lsm-1.png" alt="The Base LSM Algorithm" /><figcaption aria-hidden="true">The Base LSM Algorithm</figcaption></figure></li><li><p>当每层的磁盘上的SSTable的体积超过一定的大小或者个数，也会周期的进行合并。此步骤也称为<strong>Major Compaction</strong>，这个阶段会真正 的<strong>清除掉被标记删除掉的数据以及多版本数据的合并</strong>，避免浪费空间，注意由于<strong>SSTable都是有序的</strong>，我们可以直接采用merge sort进行高效合并。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/lsm-3.png" alt="Basic Compaction" /><figcaption aria-hidden="true">Basic Compaction</figcaption></figure></li></ol><h2 id="lsm-tree读数据的过程">LSM-Tree读数据的过程</h2><ol type="1"><li>当收到一个读请求的时候，会直接先在内存里面查询，如果查询到就返回。</li><li>如果没有查询到就会依次下沉，直到把所有的Level层查询一遍得到最终结果。</li></ol><p>思考查询步骤，我们会发现如果SSTable的分层越多，那么最坏的情况下要把所有的分层扫描一遍，对于这种情况肯定是需要优化的，如何优化？在 Bigtable 论文中提出了几种方式：</p><ol type="1"><li>压缩</li></ol><p>SSTable 是可以启用压缩功能的，并且这种压缩不是将整个 SSTable 一起压缩，而是<strong>根据 locality 将数据分组</strong>，每个组分别压缩，这样的好处当读取数据的时候，我们不需要解压缩整个文件而是解压缩部分 Group 就可以读取。</p><ol start="2" type="1"><li>缓存</li></ol><p>因为SSTable在写入磁盘后，除了Compaction之外，是不会变化的，所以我可以将Scan的Block进行缓存，从而提高检索的效率</p><ol start="3" type="1"><li>索引，Bloom filters</li></ol><p>正常情况下，一个读操作是需要读取所有的 SSTable 将结果合并后返回的，但是对于某些 key 而言，有些 SSTable 是根本不包含对应数据的，因此，我们可以<strong>对每一个 SSTable 添加 Bloom Filter</strong>，因为布隆过滤器在判断一个SSTable不存在某个key的时候，那么就一定不会存在，利用这个特性可以减少不必要的磁盘扫描。</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/lsm-2.png" alt="通过软件实现的技巧像布隆过滤器或者硬件（大文件cache）来优化读性能" /><figcaption aria-hidden="true">通过软件实现的技巧像布隆过滤器或者硬件（大文件cache）来优化读性能</figcaption></figure><ol start="4" type="1"><li>合并</li></ol><p>这个在前面的写入流程中已经介绍过，通过定期合并瘦身， 可以有效的清除无效数据，缩短读取路径，提高磁盘利用空间。但<strong>Compaction操作是非常消耗CPU和磁盘IO的</strong>，尤其是在业务高峰期，如果发生了Major Compaction，则会降低整个系统的吞吐量，这也是一些NoSQL数据库，比如Hbase里面常常会禁用Major Compaction，并在凌晨业务低峰期进行合并的原因。</p><p>最后有的同学可能会问道，为什么LSM不直接顺序写入磁盘，而是需要在内存中缓冲一下？ 这个问题其实很容易解答，<strong>单条写的性能肯定没有批量写来的快</strong>，这个原理其实在Kafka里面也是一样的，虽然kafka给我们的感觉是写入后就落地，但其实并不是，本身是 可以根据条数或者时间比如200ms刷入磁盘一次，这样能大大提升写入效率。此外在LSM中，在磁盘缓冲的另一个好处是，<strong>针对新增的数据，可以直接查询返回</strong>，能够避免一定的IO操作。</p><h2 id="lsm-tree-数据修改过程">LSM-Tree 数据修改过程</h2><p>LSM-Tree 存储引擎的更新过程其实并不存在，它不会像 B 树存储引擎那样，先经过检索过程，然后再进行修改。它的<strong>更新操作是通过追加数据来间接实现</strong>，也就是说更新最终转换为追加一个新的数据。只是<strong>在读取的时候</strong>，会从 Level0 层的 SSTable 文件开始查找数据，<strong>数据在低层的 SSTable 文件中必然比高层的文件中要新</strong>，所以总能读取到最新的那条数据。也就是说此时在<strong>整个 LSM Tree 中可能会同时存在多个 key 值相同的数据</strong>，只有在之后<strong>合并 SSTable 文件的时候，才会将旧的值删除</strong>。</p><h2 id="lsm-tree-数据删除过程">LSM-Tree 数据删除过程</h2><p>LSM-Tree 存储引擎的对数据的删除过程与追加数据的过程基本一样，区别在于追加数据的时候，是有具体的数据值的，而<strong>删除的时候，追加的数据值是删除标记</strong>。同样在读取的时候，会从 Level0 层的 SSTable 文件开始查找数据，数据在低层的 SSTable 文件中必然比高层的文件中要新，所以如果有删除操作，那么一定会最先读到带删除标记的那条数据。后期合并 SSTable 文件的时候，才会把数据删除。</p><h1 id="btree-vs-lsm-tree">B+Tree VS LSM-Tree</h1><p>传统关系型数据采用的底层数据结构是B+树，那么同样是面向磁盘存储的数据结构LSM-Tree相比B+树有什么异同之处呢？</p><p>LSM-Tree的设计思路是，将数据拆分为几百M大小的<strong>Segments</strong>，并是<strong>顺序写入</strong>。</p><p>B+Tree则是将数据拆分为固定大小的Block或<strong>Page</strong>, 一般是4KB大小，和磁盘一个扇区的大小对应，Page是读写的最小单位。</p><p>在数据的更新和删除方面，<strong>B+Tree可以做到原地更新和删除，这种方式对数据库事务支持更加友好</strong>，因为一个key只会出现一个Page页里面，但由于LSM-Tree只能追加写，并且<strong>在L0层key的rang会重叠，所以对事务支持较弱</strong>，<strong>只能在Segment Compaction的时候进行真正地更新和删除。</strong></p><p>因此<strong>LSM-Tree的优点是支持高吞吐的写</strong>（可认为是O（1）），这个特点在分布式系统上更为看重，当然针对读取普通的LSM-Tree结构，读取是O（N）的复杂度，在使用索引或者缓存优化后的也可以达到O（logN）的复杂度。</p><p>而<strong>B+tree</strong>的优点是<strong>支持高效的读</strong>（稳定的OlogN），但是在大规模的写请求下（复杂度O(LogN)），效率会变得比较低，因为随着insert的操作，为了维护B+树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。</p><p>还有一点需要提到的是基于LSM-Tree分层存储能够做到写的高吞吐，带来的副作用是整个系统必须频繁的进行compaction，写入量越大，Compaction的过程越频繁。而compaction是一个compare &amp; merge的过程，非常消耗CPU和存储IO，<strong>在高吞吐的写入情形下，大量的compaction操作占用大量系统资源，必然带来整个系统性能断崖式下跌</strong>，对应用系统产生巨大影响，当然我们可以禁用自动Major Compaction，在每天系统低峰期定期触发合并，来避免这个问题。</p><p>阿里为了优化这个问题，在X-DB<strong>引入了异构硬件设备FPGA</strong>来代替CPU完成compaction操作，使系统整体性能维持在高水位并避免抖动，是存储引擎得以服务业务苛刻要求的关键。</p><h1 id="lsm-tree的用武之地">LSM Tree的用武之地</h1><ul><li>RocksDB 是 LSM 的典型代表乃至实践标准</li><li>OceanBase数据库存储引擎基于LSM-Tree</li><li>elasticsearch搜索引擎中有用到LSM-Tree</li><li>clickHouse中有用到LSM-Tree</li></ul><h1 id="总结">总结</h1><p>本文主要介绍了LSM-Tree的相关内容，简单的说，其牺牲了部分读取的性能，通过批量顺序写来换取了高吞吐的写性能，这种特性在大数据领域得到充分了体现，最直接的例子就各种NoSQL在大数据领域的应用，学习和了解LSM-Tree的结构将有助于我们更加深入的去理解相关NoSQL数据库的实现原理，掌握隐藏在这些框架下面的核心知识。</p><h1 id="参考文章">参考文章</h1><p><a href="https://www.oceanbase.com/docs/enterprise-oceanbase-database-cn-10000000000354478">OceanBase存储架构概述</a></p><p><a href="https://www.talkwithtrend.com/Article/252811">DB 存储引擎：LSM-Tree 存储引擎详细分解 - 赵海 - twt企业IT交流平台</a></p><p><a href="https://www.zhihu.com/question/19887265">LSM 算法的原理是什么？</a></p><p><a href="https://blog.csdn.net/star1210644725/article/details/120384972?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120384972-blog-90414063.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120384972-blog-90414063.pc_relevant_default&amp;utm_relevant_index=2">深入解析什么是LSM-Tree</a></p><p><a href="https://blog.csdn.net/u010454030/article/details/90414063">深入理解什么是LSM-Tree</a></p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6.824 Lab 2 - Raft</title>
    <link href="/2022/09/17/Lab-2-Raft/"/>
    <url>/2022/09/17/Lab-2-Raft/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>The source code of this Lab is <a href="https://github.com/hswsp/MIT-6.824/tree/main/Lab%202-Raft">Here</a></strong></p></blockquote><h1 id="background">Background</h1><p>Consensus algorithms are vital in large-scale, fault-tolerant systems because they enable a set of distributed/replicated machines or servers to work as a coherent group and agree on system state, even in the presence of failures or outages.</p><figure><img src="https://cdn.ttgtmedia.com/rms/onlineImages/networking-distributed_computing.jpg" alt="Consensus algorithms are important in distributed computing systems." /><figcaption aria-hidden="true">Consensus algorithms are important in distributed computing systems.</figcaption></figure><p>There are basically two types of consensus algorithms:</p><ul><li>Byzantine Fault Tolerance Consensus Algorithm</li><li>Non-byzantine Fault Tolerance Consensus Algorithm</li></ul><p><strong>Byzantine Fault Tolerance</strong>(BFT) is the feature of a distributed network to reach consensus(agreement on the same value) even when some of the nodes in the network fail to respond or respond with incorrect information. The objective of a BFT mechanism is to safeguard against the system failures by employing collective decision making(both – correct and faulty nodes) which aims to reduce to influence of the faulty nodes. BFT is derived from Byzantine Generals’ Problem.</p><p>The Byzantine Generals Problem is a game theory problem, which describes the difficulty decentralized parties have in arriving at consensus without relying on a trusted central party. Only decentralized systems face the Byzantine Generals problem, as they have no reliable source of information and no way of verifying the information they receive from other members of the network. The problem was explained aptly in <a href="https://lamport.azurewebsites.net/pubs/byz.pdf">a paper by LESLIE LAMPORT, ROBERT SHOSTAK, and MARSHALL PEASE at Microsoft Research in 1982</a>.</p><figure><img src="https://river.com/learn/images/articles/byzantine-generals-problem.png" alt="byzantine-generals-problem" /><figcaption aria-hidden="true">byzantine-generals-problem</figcaption></figure><p>So what I want to emphasize is that the Byzantine Generals problem describes the most difficult and complex distributed fault scenario. In addition to faulty behavior, there is also a scenario of malicious behavior. In the presence of malicious node behavior (such as in the blockchain technology of digital currencies), we must apply <strong>Byzantine Fault Tolerance</strong>.</p><p>Leslie Lamport constructed two solutions to the Byzantine Generals Problem:</p><ul><li>A SOLUTION WITH ORAL MESSAGES</li><li>A SOLUTION WITH SIGNED MESSAGES</li></ul><p>Besides, other commonly used BFT includes:</p><ul><li>PBFT(practical Byzantine Fault Tolerance)</li><li>PoW(Proof-of-Work).</li></ul><p>While in a distributed computing system, the most commonly used non-Byzantine fault-tolerant algorithm is <strong>Crash Fault Tolerance</strong> (CFT). CFT solves the consensus problem in the scenario where there is a fault in the distributed system, but no malicious node.</p><p>The commonly used CFT includes:</p><ul><li><p><a href="https://martinfowler.com/articles/patterns-of-distributed-systems/paxos.html">Paxos algorithm</a></p></li><li><p>Multi-Paxos</p></li><li><p><a href="https://marcoserafini.github.io/papers/zab.pdf">Zab protocol</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Gossip_protocol#:~:text=A%20gossip%20protocol%20or%20epidemic,all%20members%20of%20a%20group.">gossip protocol</a></p></li><li><p><a href="https://blog.birost.com/a?ID=00550-5be6c52e-30ff-4c27-9137-aa026180578a">Qourum NWR</a></p></li></ul><p>Raft produces a result equivalent to (multi-)Paxos, and it is as efﬁcient as Paxos. In this lab we'll implement Raft, a replicated state machine protocol.</p><h1 id="introduction">Introduction</h1><p>We should follow the design in the <a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">extended Raft paper</a>, with particular attention to Figure 2. We'll implement most of what's in the paper, including saving persistent state and reading it after a node fails and then restarts. We will not implement cluster membership changes (Section 6).</p><p>We may find this <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">guide</a> useful, as well as this advice about <a href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">locking</a> and <a href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">structure</a> for concurrency.</p><p>To help us to understand Raft algorithm, this <a href="http://thesecretlivesofdata.com/raft/">working draft</a> visualize the data flow of consensus algorithm and especially Raft algorithm.</p><p>Raft decomposes the consensus problem into three relatively independent subproblems: <strong>Leader Election, Log Replication in the state machine, and Cluster Membership Changes</strong>. In this lab, we will only implement the first two parts, with two other essential techniques for Raft practice: <strong>Persistence and Log Compaction</strong>.</p><h2 id="lab-code-structure">Lab Code Structure</h2><p>A service calls <code>Make(peers,me,…)</code> to create a Raft peer. the ports of all the Raft servers (including this one) are in <code>peers[]</code>. this server's port is <code>peers[me]</code>. all the servers' <code>peers[]</code> arrays have the same order. <code>persister</code> is a place for this server to save its persistent state, and also initially holds the most recent saved state, if any. <code>Make()</code> must return quickly, so it should start goroutines for any long-running work.</p><p><code>applyCh</code> is a channel on which the tester or service expects Raft to send <code>ApplyMsg</code> messages. The service expects your implementation to send an <code>ApplyMsg</code> for each newly committed log entry to the <code>applyCh</code> channel argument to <code>Make()</code>. you'll want to send two kinds of messages to the service (or tester) on the same server: command and snapshots. set <code>CommandValid</code> to <code>true</code> to indicate that the <code>ApplyMsg</code> contains a newly committed log entry and set <code>CommandValid</code> to <code>false</code> for snapshots.</p><p><code>Start(command interface&#123;&#125;)</code> asks Raft to start the processing to append the command to the replicated log. <code>Start()</code> should return immediately, without waiting for the log appends to complete.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// create a new Raft server instance:</span><br>rf := Make(peers, me, persister, applyCh)<br><br><span class="hljs-comment">// start agreement on a new log entry:</span><br>rf.Start(command <span class="hljs-keyword">interface</span>&#123;&#125;) (index, term, isleader)<br><br><span class="hljs-comment">// ask a Raft for its current term, and whether it thinks it is leader</span><br>rf.GetState() (term, isLeader)<br><br><span class="hljs-comment">// each time a new entry is committed to the log, each Raft peer</span><br><span class="hljs-comment">// should send an ApplyMsg to the service (or tester).</span><br><span class="hljs-keyword">type</span> ApplyMsg<br></code></pre></td></tr></table></figure><p>this lab has also provided a diagram of Raft interactions that can help clarify how your Raft code interacts with the layers on top of it:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft-server.png" alt="lab2 Raft interactions" /><figcaption aria-hidden="true">lab2 Raft interactions</figcaption></figure><p>Combining the interactions diagram and test code, we can see how our Raft code works as a whole:</p><p>The test functions call <code>func make_config(t *testing.T, n int, unreliable bool, snapshot bool) *config</code> to create a raft service, in which, it calls <code>Make(peers,me,…)</code>.</p><p>The service calls <code>func (cfg *config) one(cmd interface&#123;&#125;, expectedServers int, retry bool) int</code> to do a complete agreement, in which, it calls <code>rf.Start(cmd)</code> to append the command to the replicated log.</p><h2 id="logging">Logging</h2><p>In order to debug distributed systems, We will make Go print a boring log with a specific format for each peer service. Here I use <a href="https://github.com/hashicorp/go-hclog">go-hclog</a> as the logger to output formatted log in a file for each peer. <strong>It prints the message along with the topic and the amount of milliseconds since the start of the run</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileConfig</span><span class="hljs-params">(file io.Writer)</span></span> Config &#123;<br>id := generateUUID()<br><span class="hljs-keyword">return</span> Config&#123;<br>HeartbeatTimeout:   <span class="hljs-number">100</span> * time.Millisecond,<br>ElectionTimeout:    <span class="hljs-number">200</span> * time.Millisecond,<br>CommitTimeout:      <span class="hljs-number">70</span> * time.Millisecond,<br>    <span class="hljs-comment">// LeaseRead, LeaderLeaseTimeout&lt;HeartbeatTimeout,</span><br>    <span class="hljs-comment">// During the lease period, we can believe that other nodes must not initiate elections, </span><br>    <span class="hljs-comment">// and the cluster must not have split-brain, so we can directly read the master during this time period.</span><br>LeaderLeaseTimeout: <span class="hljs-number">100</span> * time.Millisecond, <br>LogLevel:           <span class="hljs-string">&quot;DEBUG&quot;</span>,<br>LocalID:            ServerID(id),<br>LogOutput:          file,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">rf.logger = hclog.New(&amp;hclog.LoggerOptions&#123;<br>Name:  fmt.Sprintf(<span class="hljs-string">&quot;my-raft-%d&quot;</span>, me),<br>Level: hclog.LevelFromString(rf.config().LogLevel),<br>Output: rf.config().LogOutput,<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="locking-advice">Locking Advice</h2><p>To avoid Livelocks, I use Golang <code>Atomic</code> as much as possible and fetch all the variables at the very beginning of each function. And try to use fine-grained lock instead of Coarse-Grained Lock (such as using <code>sync.Mutex</code> to lock the whole function). And also copy-on-write technich when dealing with the Raft <code>logs</code>.</p><p>Besides, to prevent thread getting blocked, we can add time limit to Go Select Statement for asynchronous nofitication:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// asyncNotifyCh is used to do an async channel send</span><br><span class="hljs-comment">// to a single channel without blocking.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncNotifyCh</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>To aovid deadlock, we can prevent Deadlock by eliminating Circular wait condition: all of the functions request the resources in an increasing order of numbering. For example, <code>lastLock sync.Mutex</code> first and then <code>logsLock sync.RWMutex</code>.</p><h1 id="data-structure-design">Data Structure Design</h1><p>As for the general structure, the tables in Raft paper are very clear in Figure 2, and we only need to add some details.</p><h2 id="server-state">Server State</h2><p>Firstly, we define some enum constants to represent the server node status:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RaftState captures the state of a Raft node: Follower, Candidate, Leader,</span><br><span class="hljs-comment">// or Shutdown.</span><br><span class="hljs-keyword">type</span> RaftState <span class="hljs-type">uint32</span><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// Follower is the initial state of a Raft node.</span><br>Follower RaftState = <span class="hljs-literal">iota</span><br><br><span class="hljs-comment">// Candidate is one of the valid states of a Raft node.</span><br>Candidate<br><br><span class="hljs-comment">// Leader is one of the valid states of a Raft node.</span><br>Leader<br><br><span class="hljs-comment">// Shutdown is the terminal state of a Raft node.</span><br>Shutdown<br>)<br></code></pre></td></tr></table></figure><p>To represent the state of all the servers, we define <code>raftState</code> to maintain various state variables:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft1.png" alt="lab2 Raft State" /><figcaption aria-hidden="true">lab2 Raft State</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// raftState is used to maintain various state variables</span><br><span class="hljs-comment">// and provides an interface to set/get the variables in a</span><br><span class="hljs-comment">// thread safe manner.</span><br><span class="hljs-keyword">type</span> raftState <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// currentTerm commitIndex, lastLogIndex,  must be kept at the top of</span><br><span class="hljs-comment">// the struct so they&#x27;re 64 bit aligned which is a requirement for</span><br><span class="hljs-comment">// atomic ops on 32 bit platforms.</span><br><br><span class="hljs-comment">// The current term, cache of StableStore, start from 1</span><br>currentTerm <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// Highest committed log entry</span><br>commitIndex <span class="hljs-type">uint64</span><br><span class="hljs-comment">// Last applied log to the FSM</span><br>lastApplied <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// protects 4 next fields</span><br>lastLock sync.Mutex<br><br><span class="hljs-comment">// Cache the latest snapshot index/term</span><br>lastSnapshotIndex <span class="hljs-type">uint64</span>  <span class="hljs-comment">//lastIncludedIndex</span><br>lastSnapshotTerm  <span class="hljs-type">uint64</span>  <span class="hljs-comment">//lastIncludedTerm</span><br><br><span class="hljs-comment">// Cache the latest log that in Persistent state (stored in FSM)</span><br>lastLogIndex <span class="hljs-type">uint64</span><br>lastLogTerm  <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// Tracks running goroutines</span><br>routinesGroup sync.WaitGroup<br><br><span class="hljs-comment">// The current state</span><br>state         RaftState<br><br><span class="hljs-comment">//dedicated thread calling r.app.apply</span><br>applyLogCh       <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// killCh is used to kill all go routines when state changes</span><br>killCh           <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In Go, one can use structs for inheritance. For object-oriented programming, we can compose using <code>raftState</code> to form our <code>Raft</code> peer struct:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Raft <span class="hljs-keyword">struct</span> &#123;<br>raftState <span class="hljs-comment">//OOP inherit</span><br><br>mu        sync.Mutex          <span class="hljs-comment">// Lock to protect shared access to this peer&#x27;s state</span><br>peers     []*labrpc.ClientEnd <span class="hljs-comment">// RPC end points of all peers</span><br>persister *Persister          <span class="hljs-comment">// Object to hold this peer&#x27;s persisted state</span><br>me        <span class="hljs-type">int</span>                 <span class="hljs-comment">// this peer&#x27;s index into peers[]</span><br>dead      <span class="hljs-type">int32</span>               <span class="hljs-comment">// set by Kill()</span><br><span class="hljs-comment">// Shutdown channel to exit, protected to prevent concurrent exits</span><br>shutdownCh   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>shutdownLock sync.Mutex<br><br><span class="hljs-comment">// Your data here (2A, 2B, 2C).</span><br><span class="hljs-comment">// Look at the paper&#x27;s Figure 2 for a description of what</span><br><span class="hljs-comment">// state a Raft server must maintain.</span><br><br><span class="hljs-comment">// persistent state on all servers</span><br><span class="hljs-comment">//candidateID that received vote in current term</span><br>votedFor <span class="hljs-type">int32</span><br><span class="hljs-comment">//the current cluster leader ID</span><br>leaderID <span class="hljs-type">int32</span><br>leaderLock sync.RWMutex<br><br><span class="hljs-comment">//each entry contains command for state machine</span><br><span class="hljs-comment">// and term when entry was received by leader</span><br><span class="hljs-comment">//we actually use logs[index-1] to fetch log with Index = index</span><br>logs      []Log<br>logsLock sync.RWMutex<br><br><span class="hljs-comment">// volatile state on leaders</span><br><span class="hljs-comment">// leaderState used only while state is leader</span><br>leaderState LeaderState<br><br><span class="hljs-comment">// conf stores the current configuration to use. This is the most recent one</span><br><span class="hljs-comment">// provided. All reads of config values should use the config() helper method</span><br><span class="hljs-comment">// to read this safely.</span><br>conf atomic.Value<br><br><span class="hljs-comment">// lastContact is the last time we had contact from the</span><br><span class="hljs-comment">// leader node. This can be used to gauge staleness.</span><br>lastContact     time.Time<br>lastContactLock sync.RWMutex<br><br><span class="hljs-comment">// committedCh chan notify client we have committed</span><br>committedCh  <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// applyCh is used to async send logs to the main thread to</span><br><span class="hljs-comment">// be committed and applied to the FSM.</span><br>applyCh <span class="hljs-keyword">chan</span> ApplyMsg<br><br><span class="hljs-comment">// stable is a StableStore implementation for durable state</span><br><span class="hljs-comment">// It provides stable storage for many fields in raftState</span><br>stable StableStore<br><br><span class="hljs-comment">// Used for our logging</span><br><span class="hljs-comment">// Logger is a user-provided logger. If nil, a logger writing to</span><br><span class="hljs-comment">// LogOutput with LogLevel is used.</span><br>logger hclog.Logger<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="appendentries-rpc">AppendEntries RPC</h2><p>One important things to define PRC struct is that go RPC sends only struct fields whose names start with <strong>capital letters</strong>. <strong>Sub-structures must also have capitalized field names</strong> (e.g. fields of log records in an array). The <code>labgob</code> package will warn you about this; don't ignore the warnings.</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft2.png" alt="lab2 Raft AppendEntries" /><figcaption aria-hidden="true">lab2 Raft AppendEntries</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// AppendEntriesArgs is the command used to append entries to the</span><br><span class="hljs-comment">// replicated log.</span><br><span class="hljs-keyword">type</span> AppendEntriesArgs <span class="hljs-keyword">struct</span> &#123;<br>Term         <span class="hljs-type">uint64</span><br>LeaderId     <span class="hljs-type">int32</span><br>PrevLogIndex <span class="hljs-type">uint64</span> <span class="hljs-comment">//index of log entry immediately preceding new ones</span><br>PrevLogTerm  <span class="hljs-type">uint64</span> <span class="hljs-comment">//term of prevLogIndex entry</span><br>Entries      []Log<br>LeaderCommit <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg AppendEntriesArgs)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, LeaderId = %d, PrevLogIndex = %d, PrevLogTerm = %d, LeaderCommit = %d, Entries = %s&quot;</span>, arg.Term,arg.LeaderId,arg.PrevLogIndex,arg.PrevLogTerm,arg.LeaderCommit,arg.Entries)<br>&#125;<br><br><br><span class="hljs-keyword">type</span> AppendEntriesReply <span class="hljs-keyword">struct</span> &#123;<br>ServerID      <span class="hljs-type">int</span><br>Term          <span class="hljs-type">uint64</span><br>Success       <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// optimization: accelerated log backtracking</span><br>ConflictTerm  <span class="hljs-type">uint64</span>  <span class="hljs-comment">// first Log Term that conflicts between follower and leader</span><br>ConflictIndex <span class="hljs-type">uint64</span>  <span class="hljs-comment">// first Log Index that conflicts between follower and leader</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg AppendEntriesReply)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;ServerID = %d, Term = %d, Success = %v, ConflictTerm = %d, ConflictIndex = %d&quot;</span>,<br>arg.ServerID,arg.Term,arg.Success,arg.ConflictTerm,arg.ConflictIndex)<br>&#125;<br></code></pre></td></tr></table></figure><p>Another important things here is that, for all of the data structure, <strong>attaching a <code>String()</code> function to a named struct</strong> allows us to convert a struct to a string. This will help me a lot during debugging!</p><h2 id="requestvote-rpc">RequestVote RPC</h2><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft3.png" alt="lab2 Raft RequestVote" /><figcaption aria-hidden="true">lab2 Raft RequestVote</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RequestVoteArgs</span><br><span class="hljs-comment">// example RequestVote RPC arguments structure.</span><br><span class="hljs-comment">// field names must start with capital letters!</span><br><span class="hljs-keyword">type</span> RequestVoteArgs <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Your data here (2A, 2B).</span><br>Term <span class="hljs-type">uint64</span><br>CandidateId <span class="hljs-type">int32</span><br><span class="hljs-comment">// Cache the latest log from LogStore</span><br>LastLogIndex <span class="hljs-type">uint64</span><br>LastLogTerm  <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// for Debug</span><br>Time time.Time<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg RequestVoteArgs)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, CandidateId = %v, LastLogIndex = %v, LastLogTerm = %v, request Time = %v&quot;</span>,<br>arg.Term,arg.CandidateId,arg.LastLogIndex,arg.LastLogTerm, arg.Time)<br>&#125;<br><br><span class="hljs-comment">// example RequestVote RPC reply structure.</span><br><span class="hljs-comment">// field names must start with capital letters!</span><br><span class="hljs-keyword">type</span> RequestVoteReply <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Your data here (2A).</span><br>Term <span class="hljs-type">uint64</span><br>VoteGranted <span class="hljs-type">bool</span><br>VoterID <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// for Debug</span><br>Time time.Time<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg RequestVoteReply)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, VoteGranted = %v, VoterID = %v, reply time = %v&quot;</span>,<br>arg.Term,arg.VoteGranted,arg.VoterID, arg.Time)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="installsnapshot-rpc">InstallSnapshot RPC</h2><p>In the Raft paper, Snapshots are split into chunks for transmission; this gives the follower a sign of life with each chunk, so it can reset its election timer.</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft5.png" alt="lab2 Raft InstallSnapshot" /><figcaption aria-hidden="true">lab2 Raft InstallSnapshot</figcaption></figure><p>But here, for simplicity, we don't split Snapshots into several chunks. So we don't use the variable <code>offset</code> and <code>done</code> in this lab.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// InstallSnapshotRequest is the command sent to a Raft peer to bootstrap its</span><br><span class="hljs-comment">// log (and state machine) from a snapshot on another peer.</span><br><span class="hljs-keyword">type</span> InstallSnapshotRequest <span class="hljs-keyword">struct</span> &#123;<br>Term        <span class="hljs-type">uint64</span><br>LeaderId    <span class="hljs-type">int32</span>    <span class="hljs-comment">// LeaderId of request</span><br><br><span class="hljs-comment">// These are the last index/term included in the snapshot</span><br>LastLogIndex <span class="hljs-type">uint64</span><br>LastLogTerm  <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// Raw byte stream data of snapshot</span><br>Data         []<span class="hljs-type">byte</span><br><br><span class="hljs-comment">// Size of the snapshot</span><br>Size         <span class="hljs-type">int64</span><br><br><span class="hljs-comment">// true if this is the last chunk</span><br>Done         <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg InstallSnapshotRequest)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, LeaderId = %d, LastLogIndex = %d, LastLogTerm = %d, Data = %v, Size = %d&quot;</span>,<br>arg.Term,arg.LeaderId,arg.LastLogIndex,arg.LastLogTerm,arg.Data,arg.Size)<br>&#125;<br><span class="hljs-comment">// InstallSnapshotReply is the response returned from an</span><br><span class="hljs-comment">// InstallSnapshotRequest.</span><br><span class="hljs-keyword">type</span> InstallSnapshotReply <span class="hljs-keyword">struct</span> &#123;<br>Term    <span class="hljs-type">uint64</span><br>Success <span class="hljs-type">bool</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg InstallSnapshotReply)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, Success = %v&quot;</span>,<br>arg.Term,arg.Success)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rpc-handler">RPC Handler</h1><p>Our Raft peers should exchange RPCs using the <code>labrpc</code> Go package (source in <code>src/labrpc</code>). The tester can tell <code>labrpc</code> to delay RPCs, re-order them, and discard them to simulate various network failures.</p><p>We use <code>labrpc.ClientEnd.Call()</code> to send a request and waits for a reply. <code>Call()</code> is guaranteed to return (perhaps after a delay) <em>except</em> if the handler function on the server side does not return. Thus there is no need to implement your own timeouts around <code>Call()</code>.</p><p>The labrpc package simulates a lossy network, in which servers may be unreachable, and in which requests and replies may be lost. <code>Call()</code>sends a request and waits for a reply. If a reply arrives within a timeout interval, <code>Call()</code> returns true; otherwise <code>Call()</code> returns false. <strong>Thus <code>Call()</code> may not return for a while</strong>. A false return can be caused by a dead server, a live server that can't be reached, a lost request, or a lost reply.</p><p>Since <code>Call()</code> may return for a long time, which means the possibility of outdated PRC response. And we apply Go Channel as a medium for goroutines, for example background goroutine that kicking off leader election periodically by sending out <code>RequestVote</code> RPCs, to communicate with each other. So we should take this condition into account: Peer 1, for example, sent the <code>RequestVote</code> RPCs during the its <em>leader</em> lease time and got blocked in <code>rf.peers[server].Call(...)</code> clause, but when RPC returned, peer 1 has already been the <em>follower</em>, which means this PRC response is outdated and some of the <strong>channels for receiving data</strong> have already been cloesed!</p><p>One way to handle this potential bug is to restrict blocked time in RPC handler:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ok := rf.peers[server].Call(<span class="hljs-string">&quot;Raft.InstallSnapShot&quot;</span>, args, reply)<br>rstChan &lt;- ok<br>&#125;()<br><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> ok = &lt;-rstChan:<br><span class="hljs-keyword">case</span> &lt;-time.After(rf.config().HeartbeatTimeout):<br>  <span class="hljs-comment">//call rpc timeout!!!</span><br>  rf.logger.Debug(<span class="hljs-string">&quot;sent an SnapShot timeout!!&quot;</span>,<span class="hljs-string">&quot;from &quot;</span>, rf.me,<span class="hljs-string">&quot; to &quot;</span>, server)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="server-behavior">Server Behavior</h1><p>At any given time each server is in one of three states: <strong>leader, follower, or candidate</strong>.</p><ul><li>Followers are passive: they issue no requests on their own but simply respond to requests from leaders and candidates.</li><li>The leader handles all client requests (if a client contacts a follower, the follower redirects it to the leader).</li><li>Candidate is used to elect a new leader.</li></ul><p>So the whole Raft module is constructed in a main loop:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//main server loop.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> ticker() &#123;<br><span class="hljs-keyword">for</span> rf.killed() == <span class="hljs-literal">false</span> &#123;<br><br><span class="hljs-comment">// Your code here to check if a leader election should</span><br><span class="hljs-comment">// be started and to randomize sleeping time using</span><br><span class="hljs-comment">// time.Sleep().</span><br><span class="hljs-comment">// Check if we are doing a shutdown</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-rf.shutdownCh:<br><span class="hljs-comment">// Clear the leader to prevent forwarding</span><br>rf.setLeader(<span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>&#125;<br><br><span class="hljs-keyword">switch</span> rf.getState() &#123;<br><span class="hljs-keyword">case</span> Follower:<br>rf.runFollower()<br><span class="hljs-keyword">case</span> Candidate:<br>rf.runCandidate()<br><span class="hljs-keyword">case</span> Leader:<br>rf.runLeader()<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>What is left is to code all the behaviors of different states for one server. Figure 2 describes the algorithm more precisely:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft4.png" alt="lab2 Raft Rules for Servers" /><figcaption aria-hidden="true">lab2 Raft Rules for Servers</figcaption></figure><h1 id="leader-election">Leader Election</h1><p>Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they <strong>begin as followers</strong> running code <code>rf.runFollower()</code>. A server remains in follower state as long as it receives valid RPCs from a leader or candidate.</p><p>If a follower receives no communication over a period of time called the <em>election timeout</em> (in code we use <code>HeartbeatTimeout</code> to represent), then it assumes there is no viable leader and begins an election to choose a new leader. After the node elects itself as a candidate, the function <code>rf.runCandidate()</code>executes.</p><h2 id="runfollower">runFollower()</h2><p>Each follower will have a random time to see if the leader's <em>contact</em> has been received within a certain period of time(<code>HeartbeatTimeout</code>). If the time from the <strong>last contact</strong> exceeds the timeout time, it will enter the <em>candidate</em> state:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">heartbeatTimer := randomTimeout(r.config().HeartbeatTimeout)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-heartbeatTimer:<br><span class="hljs-comment">// Restart the heartbeat timer</span><br>hbTimeout := r.config().HeartbeatTimeout<br>heartbeatTimer = randomTimeout(hbTimeout)<br><br><span class="hljs-comment">// Check if we have had a successful contact</span><br>lastContact := r.LastContact()<br><span class="hljs-keyword">if</span> time.Now().Sub(lastContact) &lt; hbTimeout &#123;<br><span class="hljs-comment">//log here</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// Heartbeat failed! Transition to the candidate state</span><br><span class="hljs-comment">//If election timeout elapses without receiving AppendEntries RPC from current leader</span><br><span class="hljs-comment">//or granting vote to candidate: convert to candidate</span><br>r.setLeader(<span class="hljs-number">-1</span>)<br>r.setState(Candidate)<br></code></pre></td></tr></table></figure><p>Every time the <em>follower</em> receives the leader's HeartBeat, AppendEntries, InstallSnapshot and other operations, the <code>LastContact</code> time will be updated:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// setLastContact is used to set the last contact time to now</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> setLastContact() &#123;<br>r.lastContactLock.Lock()<br>r.lastContact = time.Now()<br>r.lastContactLock.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)&#123;<br>...<br><span class="hljs-comment">// you grant a vote to another peer. restart your election timer</span><br>rf.setLastContact()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)&#123;<br>...<br><span class="hljs-comment">//restart your election timer if you get an AppendEntries RPC from the current leader</span><br>rf.setLastContact()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> InstallSnapShot(req *InstallSnapshotRequest,reply *InstallSnapshotReply) &#123;<br>...<br>reply.Success = <span class="hljs-literal">true</span><br><span class="hljs-comment">//restart your election timer if you get an InstallSnapShot RPC from the current leader</span><br>r.setLastContact()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runcandidate">runCandidate()</h2><p>The core logic of the <em>candidate</em> is in the <code>electSelf()</code> function, where the candidate will first increase its own <em>term</em>, and then send RequestVote RPC in parallel to each of the other servers in the cluster., and finally become the leader when the number of votes is greater than 1/2 of the number of nodes.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// electSelf is used to send a RequestVote RPC to all peers, and vote for</span><br><span class="hljs-comment">// ourself. This has the side affecting of incrementing the current term. The</span><br><span class="hljs-comment">// response channel returned is used to wait for all the responses (including a</span><br><span class="hljs-comment">// vote for ourself). This must only be called from the main thread.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> electSelf() &lt;-<span class="hljs-keyword">chan</span> *RequestVoteReply&#123;<br><span class="hljs-comment">// Increment the term</span><br>r.setCurrentTerm(r.getCurrentTerm() + <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// Create a response channel</span><br>respCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *RequestVoteReply, <span class="hljs-built_in">len</span>(r.peers))<br><br><span class="hljs-comment">// Construct the request</span><br>lastIdx, lastTerm := r.getLastEntry()<br>req := &amp;RequestVoteArgs&#123;<br>Term:         r.getCurrentTerm(),<br>CandidateId:  <span class="hljs-type">int32</span>(r.me),<br>LastLogIndex: lastIdx,<br>LastLogTerm:  lastTerm,<br>&#125;<br><br><span class="hljs-comment">// Construct a function to ask for a vote</span><br>askPeer := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(peerId <span class="hljs-type">int</span>)</span></span> &#123;<br>r.goFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>voteReply := &amp;RequestVoteReply&#123;&#125;<br>voteReply.VoterID = <span class="hljs-type">uint64</span>(peerId)<br>err := r.sendRequestVote(peerId, req, voteReply)<br><span class="hljs-keyword">if</span> !err&#123;<br>r.logger.Error(<span class="hljs-string">&quot;failed to make requestVote RPC&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>, peerId,<br><span class="hljs-string">&quot;error&quot;</span>, err, <span class="hljs-string">&quot;term&quot;</span>, req.Term)<br>voteReply.Term = req.Term<br>voteReply.VoteGranted = <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">// note we may be blocked here if target rf has been killed and sendRequestVote will wait,</span><br><span class="hljs-comment">// at the same time we are killed and respCh is closed before sendRequestVote returned</span><br><span class="hljs-comment">// so we need to double check our state again here</span><br><span class="hljs-keyword">if</span> r.getState() != Candidate || r.getCurrentTerm() != req.Term&#123;<br>r.logger.Warn(<span class="hljs-string">&quot;obsolete request returned!!!!!!!! ignore it&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>respCh &lt;- voteReply<br>&#125;)<br>&#125;<br><br><span class="hljs-comment">// For each peer, request a vote</span><br><span class="hljs-keyword">for</span> serverId,_:=<span class="hljs-keyword">range</span> r.peers&#123;<br><span class="hljs-comment">// vote for myself</span><br><span class="hljs-keyword">if</span> serverId==r.me &#123;<br>r.logger.Debug(<span class="hljs-string">&quot;voting for self&quot;</span>, <span class="hljs-string">&quot;term&quot;</span>, req.Term, <span class="hljs-string">&quot;id&quot;</span>, r.me)<br><span class="hljs-comment">// Include our own vote</span><br>respCh &lt;-&amp;RequestVoteReply&#123;<br>Term:        req.Term,<br>VoteGranted: <span class="hljs-literal">true</span>,<br>VoterID: <span class="hljs-type">uint64</span>(serverId),<br>&#125;<br>r.setVotedFor(<span class="hljs-type">int32</span>(r.me))<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>r.logger.Debug(<span class="hljs-string">&quot;asking for vote&quot;</span>,<span class="hljs-string">&quot;node &quot;</span>,r.me,  <span class="hljs-string">&quot;term&quot;</span>, req.Term, <span class="hljs-string">&quot;from&quot;</span>, serverId)<br>askPeer(serverId)<br>&#125;<br>&#125;<br>r.persist()<br><span class="hljs-keyword">return</span> respCh<br>&#125;<br></code></pre></td></tr></table></figure><p>The <em>candidate</em> process is as follows:</p><ol type="1"><li>send RequestVote RPC to all nodes: elect yourself as the leader and wait for the replies from all other nodes.</li><li>If in the replies of other nodes, the <strong>term</strong> of their service is greater than the <strong>term</strong> of your own (<code>vote.Term &gt; r.getCurrentTerm()</code>), indicating that your election is behind and you are not eligible for the leader, so you set your status to <em>follower</em> and update <strong>term</strong> at the same time. Finally exit the candidate process.</li><li>If the replies from other nodes agree with your own proposal, your <em>votes</em> will be increased by one. If the number of <em>votes</em> is greater than half of the nodes, it means that your are successfully elected as the leader, and your status is updated to the <strong><em>leader</em></strong>. Finally exit the candidate process.</li><li>If the election request times out, exit the candidate process directly.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> r.getState() == Candidate &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> vote := &lt;-voteCh:<br><span class="hljs-comment">// If RPC request or response contains term T &gt; currentTerm:</span><br><span class="hljs-comment">//set currentTerm = T, convert to follower (§5.1)</span><br><span class="hljs-keyword">if</span> vote.Term &gt; r.getCurrentTerm() &#123;<br>r.logger.Warn(<span class="hljs-string">&quot;newer term discovered, fallback to follower&quot;</span>, <span class="hljs-string">&quot;term&quot;</span>, vote.Term)<br>r.setState(Follower)<br>r.setCurrentTerm(vote.Term)<br>r.setLeader(<span class="hljs-number">-1</span>)<br>r.persist()<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// Check if the vote is granted</span><br><span class="hljs-keyword">if</span> vote.VoteGranted &#123;<br>grantedVotes++<br>r.logger.Debug(<span class="hljs-string">&quot;vote granted&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>, vote.VoterID,<br><span class="hljs-string">&quot;term&quot;</span>, vote.Term, <span class="hljs-string">&quot;tally&quot;</span>, grantedVotes)<br>&#125;<br><span class="hljs-comment">// Check if we&#x27;ve become the leader</span><br><span class="hljs-keyword">if</span> grantedVotes &gt;= votesNeeded &#123;<br>r.logger.Info(<span class="hljs-string">&quot;election won&quot;</span>,<span class="hljs-string">&quot;server [&quot;</span>,r.me,<span class="hljs-string">&quot;], term&quot;</span>, vote.Term, <span class="hljs-string">&quot;tally&quot;</span>, grantedVotes)<br>r.setState(Leader)<br>r.setLeader(<span class="hljs-type">int32</span>(r.me))<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">case</span> &lt;-electionTimer:<br><span class="hljs-comment">//If election timeout elapses: start new election</span><br>r.logger.Warn(<span class="hljs-string">&quot;Election timeout reached, restarting election&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-r.shutdownCh:<br>r.logger.Warn(<span class="hljs-string">&quot;candidate server shut down!!&quot;</span>,<span class="hljs-string">&quot;peer&quot;</span>,r.me)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="safety-argument">Safety Argument</h2><p>Generally, consensus algorithms need to satisfy three basic properties, namely <strong>agreement, integrity, and termination</strong>. These three basic properties can also be summarized into two, namely <strong>Liveness and Safety</strong>. Safety refers to agreement and integrity, which means that the processed proposal comes from the correct node, and the final state of the correct node can always be consistent.</p><p>Raft ensures this security by adding some additional restrictions and measures to the process of leader election and log replication:</p><ul><li><p>Make sure the <strong>election timeouts in different peers don't always fire at the same time</strong>, or else all peers will vote only for themselves and no one will become the leader.</p></li><li><p>The system should satisﬁes the following <strong>timing requirement:</strong> <code>broadcastTime ≪ electionTimeout ≪ MTBF</code></p><p>The paper's Section 5.2 mentions election timeouts in the range of 150 to 300 milliseconds. Such a range only makes sense if the leader sends heartbeats considerably more often than once per 150 milliseconds.</p><p>Because the tester limits you to 10 heartbeats per second, we will have to use an <strong>election timeout larger than the paper's 150 to 300 milliseconds</strong>, but not too large, because then you may fail to elect a leader within five seconds.</p></li></ul><ol type="1"><li><p>To randomize the election timeouts, we may find Go's <a href="https://golang.org/pkg/math/rand/">rand</a> useful:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// randomTimeout returns a value that is between the minVal and 2x minVal.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randomTimeout</span><span class="hljs-params">(minVal time.Duration)</span></span> &lt;-<span class="hljs-keyword">chan</span> time.Time &#123;<br><span class="hljs-keyword">if</span> minVal == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>extra := time.Duration(rand.Int63()) % minVal<br><span class="hljs-keyword">return</span> time.After(minVal + extra)<br>&#125;<br></code></pre></td></tr></table></figure><p>we can use it like this:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">heartbeatTimer := randomTimeout(r.config().HeartbeatTimeout)<br></code></pre></td></tr></table></figure></li><li><p>Here we give two recommended parameter settings:</p><ul><li><p>ElectionTimeout: 150ms-300ms, HeartbeatTimeout: 50ms</p></li><li><p>ElectionTimeout: 200ms-400ms, HeartbeatTimeout: 100ms</p></li></ul><blockquote><p>ref: <a href="https://github.com/springfieldking/mit-6.824-golabs-2018/issues/1">lab2-one(%v) failed to reach agreement</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DefaultConfig</span><span class="hljs-params">()</span></span> Config &#123;<br>id := generateUUID()<br><span class="hljs-keyword">return</span> Config&#123;<br>HeartbeatTimeout:   <span class="hljs-number">100</span> * time.Millisecond,<br>ElectionTimeout:    <span class="hljs-number">200</span> * time.Millisecond,<br>CommitTimeout:      <span class="hljs-number">50</span> * time.Millisecond,<br>LeaderLeaseTimeout: <span class="hljs-number">100</span> * time.Millisecond,<br>LogLevel:           <span class="hljs-string">&quot;DEBUG&quot;</span>,<br>LocalID:            ServerID(id),<br>LogOutput:          os.Stderr,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="log-replication">Log Replication</h1><p>Log replication is initiated by the leader and executed in the function <code>rf.runLeader()</code>.</p><p>The <em>Leader</em> process is as follows:</p><ol type="1"><li><p>Start a replication routine for each peer, calling <code>r.startStopReplication()</code> to perform log replication.</p></li><li><p>Sit in the leader loop until we step down, calling <code>r.leaderLoop()</code>.</p></li><li><p>In <code>leaderLoop()</code>, we periodically check out leader state:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> r.getState() == Leader &#123;<br>  ...<br>  <span class="hljs-keyword">case</span> &lt;-lease:<br>  <br>  <span class="hljs-comment">// Check if we&#x27;ve exceeded the lease, potentially stepping down</span><br>maxDiff := r.checkLeaderLease()<br><br><span class="hljs-comment">// Next check interval should adjust for the last node we&#x27;ve</span><br><span class="hljs-comment">// contacted, without going negative</span><br>checkInterval := r.config().LeaderLeaseTimeout - maxDiff<br><span class="hljs-keyword">if</span> checkInterval &lt; minCheckInterval &#123;<br>checkInterval = minCheckInterval<br>&#125;<br>  <br>r.logger.Info(<span class="hljs-string">&quot;check lease time&quot;</span>,<span class="hljs-string">&quot;checkInterval&quot;</span>,checkInterval)<br><span class="hljs-comment">// Renew the lease timer</span><br>lease = time.After(checkInterval)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>When we exit leader state, reset <code>lastContact</code>(calling <code>r.setLastContact()</code>). Since we were the leader previously, we update our last contact time when we step down, so that <strong>we are not reporting a last contact time from before we were the leader.</strong> Otherwise, to a client it would seem our data is extremely stale.</p></li></ol><p>The core function to perform log replication is <code>startStopReplication()</code>:</p><ol type="1"><li><p>Start a new goroutine, calling <code>replicate()</code> to perform log replication for each node except the leader.</p></li><li><p>The status of each node's AppendEntries RPC is saved through the object <code>followerReplication</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// followerReplication is in charge of sending snapshots and log entries from</span><br><span class="hljs-comment">// this leader during this particular term to a remote follower.</span><br><span class="hljs-keyword">type</span> followerReplication <span class="hljs-keyword">struct</span> &#123;<br>  <br>Term         <span class="hljs-type">uint64</span><br>LeaderId     <span class="hljs-type">int32</span><br>PrevLogIndex <span class="hljs-type">uint64</span><br>PrevLogTerm  <span class="hljs-type">uint64</span><br>LeaderCommit <span class="hljs-type">uint64</span><br><br>Entries      []Log<br>EntriesLock sync.RWMutex<br><br><span class="hljs-comment">// getLastContact is updated to the current time whenever any response is</span><br><span class="hljs-comment">// received from the follower (successful or not). This is used to check</span><br><span class="hljs-comment">// whether the leader should step down (Raft.checkLeaderLease()).</span><br>LastContact time.Time<br><span class="hljs-comment">// LastContactLock protects &#x27;getLastContact&#x27;.</span><br>LastContactLock sync.RWMutex<br><br><span class="hljs-comment">// failures counts the number of failed RPCs since the last success, which is</span><br><span class="hljs-comment">// used to apply backoff.</span><br>Failures <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// stopCh is notified/closed when this leader steps down or the follower is</span><br><span class="hljs-comment">// removed from the cluster. In the follower removed case, it carries a log</span><br><span class="hljs-comment">// index; replication should be attempted with a best effort up through that</span><br><span class="hljs-comment">// index, before exiting.</span><br>stopCh <span class="hljs-keyword">chan</span> <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// stepDown is used to indicate to the leader that we</span><br><span class="hljs-comment">// should step down based on information from a follower.</span><br>stepDown <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// triggerCh is notified every time new entries are appended to the log.</span><br>triggerCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>In the function <code>replicate()</code> , call <code>replicateTo()</code> to do log replication via sending <em>AppendEntries RPC</em> as soon as the leader receives a new <em>command</em> .(After the <code>replicate()</code> goroutine detects that there is a message in <code>triggerCh</code>, it starts to call <code>replicate()</code> )</p></li><li><p>In the beginning of <code>replicate()</code> , we start an another new goroutine calling function <code>heartbeat()</code> to send <em>heartbeat RPC</em> to all the followers periodically.</p></li><li><p>One important issue here is that when 1 new <em>command</em> comes in, the function <code>replicate()</code> may still be running in <code>replicateTo()</code> due to previous command. Since the channel size of <code>triggerCh</code> is 1, if new commands come in so fast, we will fail to send the new <em>AppendEntries RPC</em> to followers. To address this issue, we have 2 mechanism:</p><ul><li><p>Add a new channel <code>&lt;-randomTimeout(r.config().CommitTimeout)</code> to send <em>AppendEntries RPC</em> periodically for compendation.</p></li><li><p>Instead of sending empty <em>AppendEntries RPC</em> as the <strong>heartbeat RPC</strong>, we will carry new <code>entries[]</code> if we have new <em>command</em> in leader's logs.</p></li></ul></li></ol><p>When the leader sends <em>AppendEntries</em> to the follower, it will take the adjacent previous log (<strong>we don't actually need the <code>Log</code> object, but only need <code>PrevLogIndex</code> and <code>PrevLogTerm</code> for consistency check!</strong>). When the follower receives AppendEntries RPC, it will find the previous log entry with same <code>Term</code> and <code>Index</code>.</p><p>If it exists and matches, it will accept the log entry; otherwise, after a rejection, the leader decrements <code>nextIndex</code> and retries the <strong>AppendEntries RPC</strong>. Eventually <code>nextIndex</code> will reach a point where the leader and follower logs match.</p><p>Then the follower deletes all the logs after the <code>Index</code> and appends the log entries sent by the leader. Once the logs are appended successfully, all the logs of the follower and the leader are consistent.</p><p>Only after the majority of followers respond to receive the log, indicating that the log can be committed, can leader response to client applying successfully.</p><h2 id="the-importance-of-details">The Importance of Details</h2><ol type="1"><li>Follower deleting the existing entry is conditional</li></ol><p>Upon receiving a heartbeat, You may truncate the follower’s log following <code>prevLogIndex</code>, and then append any entries included in the <code>AppendEntries</code> arguments. <strong>This is not correct</strong>. We can once again turn to Figure 2:</p><blockquote><p><strong>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</strong></p></blockquote><p>The <em>if</em> here is crucial. <strong>If the follower has all the entries the leader sent</strong>, the follower <strong>MUST NOT</strong> truncate its log. Any elements <em>following</em> the entries sent by the leader <strong>MUST</strong> be kept. This is because we could be receiving an outdated <code>AppendEntries</code> RPC from the leader, and truncating the log would mean “taking back” entries that we may have already told the leader that we have in our log.</p><ol start="2" type="1"><li>Leaders can only commit logs of their own term</li></ol><p>Figure 8 use a time sequence showing why a leader cannot determine commitment using log entries from older terms. To eliminate problems like the one in Figure 8, <strong>Raft never commits log entries from previous terms by counting replicas</strong>. Only log entries from the leader’s current term are committed by counting replicas.</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/fig8.png" alt="lab2 Raft Figure 8" /><figcaption aria-hidden="true">lab2 Raft Figure 8</figcaption></figure><h2 id="coding-hints">Coding Hints</h2><ol type="1"><li>One trick here to implement the rules in Figure 2 for Leaders:</li></ol><blockquote><p>If there exists an N such that <code>N &gt; commitIndex</code>, a majority of <code>matchIndex[i] ≥ N</code>, and <code>log[N].term == currentTerm</code>: set <code>commitIndex = N</code> (§5.3, §5.4).</p></blockquote><p>To obtain the majority of <code>matchIndex[i] ≥ N</code>, We can sort <code>matchIndex[]</code> in the increasing order and then fetch the middle one, which is just the <code>N</code> here. And then we can judge if <code>N &gt; commitIndex</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">matchIndex := rpcArg.PrevLogIndex + <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(rpcArg.Entries))<br>r.logger.Info(<span class="hljs-string">&quot;update sever state&quot;</span>,<span class="hljs-string">&quot;sever&quot;</span>, reply.ServerID,<span class="hljs-string">&quot; matchIndex &quot;</span>,matchIndex)<br>r.leaderState.updateStateSuccess(reply.ServerID,matchIndex)<br><br><span class="hljs-comment">//If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N,</span><br><span class="hljs-comment">//and log[N].term == currentTerm: set commitIndex = N (§5.3, §5.4).</span><br>copyMatchIndex := <span class="hljs-built_in">make</span>(uint64Slice, <span class="hljs-built_in">len</span>(r.peers))<br>r.leaderState.indexLock.Lock()<br><span class="hljs-built_in">copy</span>(copyMatchIndex, r.leaderState.matchIndex)<br>r.leaderState.indexLock.Unlock()<br>copyMatchIndex[r.me] = r.getLastIndex()<br><br><span class="hljs-comment">//sort and get the middle to judge the majority</span><br>sort.Slice(copyMatchIndex, copyMatchIndex.Less)<br>N := copyMatchIndex[<span class="hljs-built_in">len</span>(r.peers)/<span class="hljs-number">2</span>]<br>r.logger.Debug(<span class="hljs-string">&quot;check returned matchIndex&quot;</span>,<span class="hljs-string">&quot;copyMatchIndex&quot;</span>,copyMatchIndex)<br><br><span class="hljs-comment">// convert to offset due to log compact</span><br>offset := N - <span class="hljs-number">1</span> - base<br><span class="hljs-keyword">if</span> N &gt; r.getCommitIndex() &amp;&amp; currentLogs[offset].Term == currentTerm &#123;<br>  r.setCommitIndex(N)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>The code have loops that repeatedly check for certain events. Don't have these loops execute continuously without pausing, since that will slow your implementation enough that it fails tests. We insert a time waiting in each loop iteration:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> heartbeat(id <span class="hljs-type">int</span>, s *followerReplication, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#123;<br>  ...<br>  <span class="hljs-keyword">for</span> s.Term == r.getCurrentTerm()&#123;<br>r.logger.Debug(<span class="hljs-string">&quot;heartbeat show current followerReplication data&quot;</span>,<span class="hljs-string">&quot;peer&quot;</span>, id, <span class="hljs-string">&quot; followerReplication&quot;</span>,s)<br><span class="hljs-comment">// Don&#x27;t have these loops execute continuously without pausing</span><br><span class="hljs-comment">// Wait for the next heartbeat interval or forced notify</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-randomTimeout(r.config().HeartbeatTimeout / <span class="hljs-number">4</span>):<br><span class="hljs-keyword">case</span> &lt;-stopCh:<br>r.logger.Warn(<span class="hljs-string">&quot;replicate stopped heartbeat&quot;</span>,<span class="hljs-string">&quot;leader&quot;</span>,r.me,<span class="hljs-string">&quot; peer&quot;</span>,id)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// each command is sent to each peer just once.</span><br><span class="hljs-comment">// heartbeat does not send entries</span><br><span class="hljs-keyword">if</span> r.getState() != Leader &#123; <span class="hljs-comment">// has already stepped down</span><br>r.logger.Warn(<span class="hljs-string">&quot;close heartbeat due to transferring to follower&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>If <code>commitIndex &gt; lastApplied</code> <em>at any point</em> during execution, we should apply a particular log entry. It is not crucial that you do it straight away (for example, in the <code>AppendEntries</code> RPC handler), but it is important that you ensure that this application is only done by one entity. Specifically, <strong>we have a dedicated “applier”:<code>startApplyLogs()</code></strong>, so that some other routine doesn’t also detect that entries need to be applied and also tries to apply:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> startApplyLogs() &#123;<br><span class="hljs-comment">// dedicated thread calling r.app.apply from Raft</span><br>rf.goFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- rf.applyLogCh:<br><br><span class="hljs-comment">// may only be partially submitted</span><br>lastApplied := rf.getLastApplied()<br><br><span class="hljs-keyword">for</span> lastApplied &lt; rf.getCommitIndex()&#123;<br>newLastApplied := lastApplied + <span class="hljs-number">1</span><br><br>msg := ApplyMsg&#123;&#125;<br>msg.CommandValid = <span class="hljs-literal">true</span><br>msg.SnapshotValid = <span class="hljs-literal">false</span><br>msg.CommandIndex = <span class="hljs-type">int</span>(newLastApplied)<br><br>entry := rf.getEntryByOffset(newLastApplied)<br>msg.Command = entry.Data<br><br><span class="hljs-comment">// Update the last log since it&#x27;s on disk now</span><br>rf.setLastApplied(newLastApplied)<br><br>rf.applyCh &lt;- msg<br><br>lastApplied = newLastApplied<br>&#125;<br>        <br><span class="hljs-keyword">case</span> &lt;-rf.shutdownCh:<br>rf.logger.Warn(<span class="hljs-string">&quot;startApplyLogs goroutine shut down!!&quot;</span>,<span class="hljs-string">&quot;peer&quot;</span>,rf.me)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="accelerated-log-backtracking">Accelerated Log Backtracking</h2><p>To optimize accelerated log backtracking, we can follow these steps:</p><ol type="1"><li><p>If a follower <strong>does not</strong> have <code>prevLogIndex</code> in its log, it should return with <code>conflictIndex = len(log)</code> and <code>conflictTerm = None</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> lastSnapshotIndex &gt; args.PrevLogIndex || lastLogIndex &lt; args.PrevLogIndex &#123;<br>  <br>  reply.Term = currentTerm<br>  <br>  reply.Success = <span class="hljs-literal">false</span><br>  <br>  <span class="hljs-comment">// If a follower does not have prevLogIndex in its log</span><br>  <span class="hljs-comment">// it should return with conflictIndex = lastLogIndex + 1 and conflictTerm = None</span><br>  reply.ConflictIndex = lastLogIndex + <span class="hljs-number">1</span><br>  <br>  reply.ConflictTerm = <span class="hljs-number">0</span> <span class="hljs-comment">//represent conflictTerm = None.</span><br><br>  rf.persist()<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>If a follower does have <code>prevLogIndex</code> in its log, but the <strong>term does not match</strong>, it should return <code>conflictTerm = log[prevLogIndex].Term</code>, and then search its log for the first index whose entry has term equal to <code>conflictTerm</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getConflictTermIndex</span><span class="hljs-params">(conflictTerm <span class="hljs-type">uint64</span>,logEntries []Log)</span></span> <span class="hljs-type">uint64</span> &#123;<br>  <br><span class="hljs-comment">// all the indexes start from 1, so 0 means no conflict</span><br>conflictIndex := <span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br>  <br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(logEntries); i++ &#123;<br><span class="hljs-keyword">if</span> logEntries[i].Term == conflictTerm &#123;<br>      <br><span class="hljs-comment">// conflictIndex = uint64(i + 1)</span><br><span class="hljs-comment">// conflictIndex is the actual index of the log !</span><br>conflictIndex = logEntries[i].Index<br>      <br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>  <br><span class="hljs-keyword">return</span> conflictIndex<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> args.PrevLogTerm != prevLogTerm &#123;<br><br>    reply.Term = currentTerm<br>  <br>reply.Success = <span class="hljs-literal">false</span><br>  <br><span class="hljs-comment">// If a follower does have prevLogIndex in its log, but the term does not match,</span><br><span class="hljs-comment">// it should return conflictTerm = log[prevLogIndex - 1].Term</span><br>reply.ConflictTerm = prevLogTerm<br>  <br>    <span class="hljs-comment">// then search its log for the first index whose entry has term equal to conflictTerm.</span><br>reply.ConflictIndex = getConflictTermIndex(prevLogTerm,originLogEntries)<br><br>rf.persist()<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Upon receiving a conflict response, the leader should first search its log for <code>conflictTerm</code>. If it finds an entry in its log with that term, it should set <code>nextIndex</code> to be the one beyond the index of the <strong><em>last entry</em> </strong> in that term in its log.</p></li><li><p>If it does not find an entry with that term, it should set <code>nextIndex = conflictIndex</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> lastConfictTermIndex(conflictTerm <span class="hljs-type">uint64</span>) (<span class="hljs-type">uint64</span>,<span class="hljs-type">bool</span>) &#123;<br>entries := r.getLogEntries()<br>founded := <span class="hljs-literal">false</span><br>  <br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(entries); i++&#123;<br>    <br><span class="hljs-keyword">if</span> entries[i].Term==conflictTerm &#123;<br>founded = <span class="hljs-literal">true</span><br>&#125;<br>    <br><span class="hljs-keyword">if</span> entries[i].Term &gt; conflictTerm&#123;<br><span class="hljs-comment">//return uint64(i + 1),founded</span><br><span class="hljs-keyword">return</span> entries[i].Index,founded<br>&#125;<br>    <br>&#125;<br>  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>,founded<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//If AppendEntries fails because of log inconsistency:</span><br><span class="hljs-comment">//decrement nextIndex and retry (§5.3)</span><br><br><span class="hljs-comment">// The accelerated log backtracking optimization</span><br><span class="hljs-comment">// Upon receiving a conflict response, the leader should first search its log for conflictTerm.</span><br>upperboundIndex, founded := r.lastConfictTermIndex(reply.ConflictTerm)<br><br><span class="hljs-keyword">if</span> founded &#123;<br>  <span class="hljs-comment">// If it finds an entry in its log with ConflictTerm,</span><br><span class="hljs-comment">// it should set nextIndex as the one beyond the index of the last entry in that term in its log.</span><br>r.leaderState.setNextIndex(reply.ServerID, upperboundIndex)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  r.leaderState.setNextIndex(reply.ServerID, reply.ConflictIndex)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="persistence">Persistence</h1><p>For the persistent content of the state, it is provided by the Figure 2 at the <em>State</em> part : <code>currentTerm</code>,<code>voteFor</code> and <code>log[]</code>. Besides, in <em>InstallSnapshot</em>, we also need to persist <code>lastIncludedIndex</code> and <code>lastIncludedTerm</code> in order to let server be able to restore the original state after the machine reboots.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> persistData() []<span class="hljs-type">byte</span> &#123;<br>w := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>e := gob.NewEncoder(w)<br>e.Encode(rf.currentTerm)<br>e.Encode(rf.votedFor)<br>e.Encode(rf.logs)<br>e.Encode(rf.lastSnapshotIndex)<br>e.Encode(rf.lastSnapshotTerm)<br>data := w.Bytes()<br><span class="hljs-keyword">return</span> data<br>&#125;<br></code></pre></td></tr></table></figure><p>And of course we should call <code>persist()</code> every time these contents of the state change.</p><h1 id="log-compaction">Log Compaction</h1><p>Raft implements log compaction through snapshot. Server persistently store a "snapshot" of their state from time to time, at which point Raft discards log entries that precede the snapshot.The result is a smaller amount of persistent data and faster restart.</p><p>However, it's now possible for a <strong>follower to fall so far behind that the leader</strong> has discarded the log entries it needs to catch up; <strong>the leader must then send a snapshot plus the log starting at the time of the snapshot.</strong></p><p>In Raft paper, Figure 12 can be a good illustration of the role of snapshots:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft12.png" alt="lab2 Raft Figure 12" /><figcaption aria-hidden="true">lab2 Raft Figure 12</figcaption></figure><p>Simple explanation:</p><p>Suppose now that the updated information of x and y is stored in the log. The information of x is 3, 2, 0, 5 in sequence. The information of y is 1, 9, and 7 in sequence. And the <em>logs</em> with subscripts 1~ 5 have been committed, indicating that this log is no longer needed for the current node.</p><p>Then we access the last stored information as the <em>snapshot</em> (<code>persister.SaveStateAndSnapshot()</code>), that is, x=0, y=9, and record the log index (<code>lastIncludedIndex</code>) of the last snapshot storage and its corresponding term(<code>lastIncludedTerm</code>). At this point, our new <em>logs</em> only store the uncommitted index of 6 and 7, and the length of the <em>logs</em> has changed from 7 to 2.</p><p>We can start with the diagram of Raft interactions as mentioned above:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft-server.png" alt="lab2 Raft interactions" /><figcaption aria-hidden="true">lab2 Raft interactions</figcaption></figure><h2 id="functions-to-implement">Functions to Implement</h2><p>Lab 2 require us to implement <code>Snapshot()</code> ,<code>CondInstallSnapshot()</code> and the <strong><em>InstallSnapshot RPC</em></strong>.</p><p><code>Snapshot()</code> is actually called by the service to Raft, so that the Raft node updates its own snapshot information. Some one might argue that this violates Raft's principles of strong leadership. Because followers can update their own snapshots without the leader's knowledge. But in fact, this situation is reasonable. <strong>Updating the snapshot is only to update the data, which does not conflict with reaching a consensus. Data still only flows from the leader to the followers</strong>, followers just take snapshots to lighten their burden of storage.</p><p>The <em>snapshot</em> you send will be uploaded to <code>applyCh</code>, and at the same time your <em>AppendEntries</em> will also need to upload logs to <code>applyCh</code>, , which may cause conflicts. <code>CondInstallSnapshot()</code> is called to avoid the requirement that snapshots and log entries sent on <code>applyCh</code> are coordinated。But in fact, as long as you synchronize well when apply, adding a mutex, then this problem can be avoided. So you are discouraged from implementing it: instead, we suggest that you simply have it return true.</p><p>you need to send a <strong><em>InstallSnapshot RPC</em></strong> is actually when the log that the leader sends to the follower has been discarded. We add function <code>leaderSendSnapShot(server int)</code> to send the InstallSnapshot RPC. So where<code>leaderSendSnapShot()</code> called to send the snapshot should be during consistency check performed by AppendEntries RPCs. The condition is that <em>nextIndex</em> is lower than leader's snapshot: <code>rf.nextIndex[server] &lt; rf.lastIncludeIndex</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> nextIndex &lt; lastIncludeIndex&#123;<br>r.logger.Info(<span class="hljs-string">&quot;InstallSnapShot to followers&quot;</span>,<span class="hljs-string">&quot;leader&quot;</span>,r.me,<span class="hljs-string">&quot; peer&quot;</span>,serverID,<br><span class="hljs-string">&quot;current term&quot;</span>,r.getCurrentTerm(),<span class="hljs-string">&quot; Replication RPC term&quot;</span>,s.Term)<br>r.goFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;r.leaderSendSnapShot(serverID)&#125;)<br><span class="hljs-keyword">return</span> shouldStop<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="subscript-tips">Subscript Tips</h2><p>Every time you update <em>logs</em> during AppendEntries RPC process, you must take the subscript of the snapshot into count. There are two points you need to take into carefully consideration:</p><ol type="1"><li><p>After snapshot, the index(offset) of your log entries <code>log[]</code> should no longer be euqal to <code>Index</code> field of your <code>type Log struct</code>. Only <code>Log.Index</code> is actually the global index of all of your log entries.</p></li><li><p><strong>You need to do index conversion</strong> everywhere you use <code>log[]</code> in functions that process RPCs, like <code>func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)</code> and <code>func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)</code>.</p><p>For example, if you want to fetch <code>Term</code> according to <code>Log.Index</code>, you can use:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//get log term by index after snapshot</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> getLogTermByIndex(index <span class="hljs-type">uint64</span>) <span class="hljs-type">uint64</span> &#123;<br>  <br>rf.lastLock.Lock()<br><span class="hljs-keyword">var</span> offset <span class="hljs-type">int64</span><br>offset = <span class="hljs-type">int64</span>(index)-<span class="hljs-type">int64</span>(<span class="hljs-number">1</span> + rf.lastSnapshotIndex)  <span class="hljs-comment">// may overflow here, caution!!!!</span><br>  <br><span class="hljs-keyword">if</span> offset &lt; <span class="hljs-number">0</span> &#123;<br>rf.lastLock.Unlock()<br><span class="hljs-keyword">return</span> rf.lastSnapshotTerm<br>&#125;<br>rf.lastLock.Unlock()<br><br>rf.logsLock.Lock()<br><span class="hljs-keyword">defer</span> rf.logsLock.Unlock()<br><span class="hljs-keyword">return</span> rf.logs[offset].Term<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="reference">Reference</h1><ol type="1"><li><a href="https://github.com/hashicorp/raft">hashicorp-raft</a></li><li><a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">extended Raft paper</a></li><li><a href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft 协议（三）—— 集群成员变更</title>
    <link href="/2022/09/16/raft-3/"/>
    <url>/2022/09/16/raft-3/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39cfc4f351ea491aab271b4783988552~tplv-k3u1fbpfcp-zoom-crop-mark:3024:3024:3024:1702.awebp" alt="Raft 协议实战系列（五）—— 集群成员变更与日志压缩" /><figcaption aria-hidden="true">Raft 协议实战系列（五）—— 集群成员变更与日志压缩</figcaption></figure><blockquote><p>摘录自:<a href="https://juejin.cn/post/6902274909959880711">Q的博客</a>,<a href="https://youjiali1995.github.io/raft/etcd-raft-cluster-membership-change/">Raft 笔记(六) – Cluster membership change</a></p></blockquote><p>本文介绍 Raft 论文描述的两个 Raft 实践必备技术之一 ——集群成员变更。<strong>本文重点讲解 raft 集群如何动态增删节点、集群变更时脑裂的诱因及应对方案。</strong></p><hr /><p>在前文的理论描述中我们都假设了集群成员是不变的，然而在实践中有时会需要替换宕机机器或者改变复制级别（即增减节点）。一种最简单暴力达成目的的方式就是：停止集群、改变成员、启动集群。这种方式在执行时会导致集群整体不可用，此外还存在手工操作带来的风险。</p><p>为了避免这样的问题，Raft 论文中给出了一种无需停机的、自动化的改变集群成员的方式，其实本质上还是利用了 Raft 的核心算法，将集群成员配置作为一个特殊日志从 leader 节点同步到其它节点去。</p><h1 id="直接切换集群成员配置">直接切换集群成员配置</h1><p>先说结论：<strong>所有将集群从旧配置直接完全切换到新配置的方案都是不安全的</strong>。</p><p>因此我们不能想当然的将新配置直接作为日志同步给集群并 apply。因为我们不可能让集群中的全部节点在“<strong>同一时刻</strong>”<strong>原子地</strong>切换其集群成员配置，所以在切换期间不同的节点看到的集群视图可能存在不同，最终可能导致集群存在多个 leader。</p><p>为了理解上述结论，我们来看一个实际出现问题的场景，图1对其进行了展现。</p><figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00cd4fb677dc4a8987c015b6f074a3b8~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图1" /><figcaption aria-hidden="true">图1</figcaption></figure><p><strong>阶段a.</strong> 集群存在 S1 ~ S3 三个节点，我们将该成员配置表示为 C-old，绿色表示该节点当前视图（成员配置）为 C-old，其中红边的 S3 为 leader。</p><p><strong>阶段b.</strong> 集群新增了 S4、S5 两个节点，该变更从 leader 写入，我们将 S1 ~ S5 的五节点新成员配置表示为 C-new，蓝色表示该节点当前视图为 C-new。</p><p><strong>阶段c.</strong> 假设 S3 短暂宕机触发了 S1 与 S5 的超时选主。</p><p><strong>阶段d.</strong> S1 向 S2、S3 拉票，S5 向其它全部四个节点拉票。由于 S2 的日志并没有比 S1 更新，因此 S2 可能会将选票投给 S1，S1 两票当选（因为 S1 认为集群只有三个节点）。而 S5 肯定会得到 S3、S4 的选票，因为 S1 感知不到 S4，没有向它发送 RequestVote RPC，并且 S1 的日志落后于 S3，S3 也一定不会投给 S1，结果 S5 三票当选。最终集群出现了多个主节点的致命错误，也就是所谓的脑裂。</p><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c063b8c7e824bb88ffe572439c90975~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图2" /><figcaption aria-hidden="true">图2</figcaption></figure><p>图2来自论文，用不同的形式展现了和图1相同的问题。颜色代表的含义与图1是一致的，在 <strong>problem: two disjoint majorities</strong> 所指的时间点，集群可能会出现两个 leader。</p><p>但是，多主问题并不是在任何新老节点同时选举时都一定可能出现的，社区一些文章在举多主的例子时可能存在错误，下面是一个案例（笔者学习 Raft 协议也从这篇文章中受益匪浅，应该是作者行文时忽略了。文章很赞，建议大家参考学习）：</p><blockquote><p>来源：《Raft 协议详解》知乎某大神</p><p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27207160">zhuanlan.zhihu.com/p/27207160</a></p></blockquote><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85436861e4484446afac9192d02bc292~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图3" /><figcaption aria-hidden="true">图3</figcaption></figure><p>该假想场景类似图1的阶段d，模拟过程如下：</p><ol type="1"><li>S1 为集群原 leader，集群新增 S4、S5，该配置被推给了 S3，S2 尚未收到。</li><li>此时 S1 发生短暂宕机，S2、S3 分别触发选主。</li><li>最终 S2 获得了 S1 和自己的选票，S3 获得了 S4、S5 和自己的选票，集群出现两个 leader。</li></ol><p>图3过程看起来好像和图1没有什么大的不同，只是参与选主的节点存在区别，然而事实是<strong>图3的情况是不可能出现的</strong>。</p><p>注意：<strong>Raft 论文中传递集群变更信息也是通过日志追加实现的</strong>，所以也受到选主的限制。很多读者对选主限制中比较的日志是否必须是 committed 产生疑惑，回看下在《安全性》一文中的描述：</p><blockquote><p>每个 candidate 必须在 RequestVote RPC 中携带自己本地日志的最新 (term, index)，如果 follower 发现这个 candidate 的日志还没有自己的新，则拒绝投票给该 candidate。</p></blockquote><p>这里再帮大家明确下，论文里确实间接表明了，<strong>选主时比较的日志是不要求 committed 的，只需比较本地的最新日志就行</strong>！</p><p>回到图3，不可能出现的原因在于，S1 作为原 leader 已经第一个保存了新配置的日志，而 S2 尚未被同步这条日志，根据上一篇《安全性》我们讲到的<strong>选主限制</strong>，<strong>S1 不可能将选票投给 S2</strong>，因此 S2 不可能成为 leader。</p><h1 id="两阶段切换集群成员配置joint-consensus">两阶段切换集群成员配置(Joint consensus)</h1><p>最开始 <code>Raft</code> 使用 <code>joint consensus</code> 实现成员变更，<code>raft extended</code> 中也只提到了这种方式，这种方式支持一次变更多个成员，但是复杂一些。</p><p><code>joint consensus</code> 使用一种两阶段方法平滑切换集群成员配置来避免遇到前一节描述的问题。</p><p><code>C-old</code> 为当前的配置，<code>C-new</code> 为目标配置。当 <code>leader</code> 收到成员变更的请求时，会创建一个 <code>C-old-new</code> 的配置(<code>joint consensus</code>)，所有节点在接收到配置时就采用新的配置，不用等到 <code>commit</code>。 <code>joint consensus</code> 把新旧配置联系起来：</p><ul><li><code>log entries</code> 复制到2个配置的所有节点上；</li><li>使用 <code>C-old</code> 或 <code>C-old-new</code> 配置的节点都可能成为 <code>leader</code>；</li><li>处于 <code>C-old-new</code> 状态时，必须收到 <code>C-old</code> 的 <code>majority</code> 和 <code>C-new</code> 的 <code>majority</code> 的同意才能提交或选出 <code>leader</code>。</li></ul><p><strong>当 <code>C-old-new</code> 被提交之后，创建 <code>C-new</code> 配置，当 <code>C-new</code> 被提交后，整个成员变更结束</strong>，不在 <code>C-new</code> 中的节点可以关闭。<code>joint consensus</code> 确保了 <code>C-old</code> 和 <code>C-new</code> 不会同时做决定，保证了 <code>safety</code>。</p><p>具体流程如下：</p><p><strong>阶段一</strong></p><ol type="1"><li>客户端将 C-new 发送给 leader，leader 将 C-old 与 C-new 取<strong>并集</strong>并立即apply，我们表示为 <strong>C-old,new</strong>(<code>joint consensus</code>)。</li><li>Leader 将 C-old,new 包装为日志同步给其它节点。</li><li>Follower 收到 C-old,new 后立即 apply，当 <strong>C-old,new 的大多数节点（即 C-old 的大多数节点和 C-new 的大多数节点）</strong>都切换后，leader 将该日志 commit。</li></ol><p><strong>阶段二</strong></p><ol type="1"><li>Leader 接着将 C-new 包装为日志同步给其它节点。</li><li>Follower 收到 C-new 后立即 apply，如果此时发现自己不在 C-new 列表，则主动退出集群。</li><li>Leader 确认 <strong>C-new 的大多数节点</strong>都切换成功后，给客户端发送执行成功的响应。</li></ol><figure><img src="https://youjiali1995.github.io/assets/images/raft_joint_consensus.png" alt="图4" /><figcaption aria-hidden="true">图4</figcaption></figure><p>图4展示了该流程的时间线。虚线表示已经创建但尚未 commit 的成员配置日志，实线表示 committed 的成员配置日志。</p><p>为什么该方案可以保证不会出现多个 leader？我们来按流程逐阶段分析。</p><p><strong>阶段1. C-old,new 尚未 commit</strong></p><p>该阶段所有节点的配置要么是 C-old，要么是 C-old,new，但无论是二者哪种，只要原 leader 发生宕机，新 leader 都<strong>必须得到大多数 C-old 集合内节点的投票</strong>。</p><p>以图1场景为例，S5 在阶段d根本没有机会成为 leader，因为 C-old 中只有 S3 给它投票了，不满足大多数。</p><p><strong>阶段2. C-old,new 已经 commit，C-new 尚未下发</strong></p><p>该阶段 C-old,new 已经 commit，可以确保已经被 C-old,new 的大多数节点（<strong>再次强调：C-old 的大多数节点和 C-new 的大多数节点</strong>）复制。</p><p>因此当 leader 宕机时，新选出的 leader 一定是已经拥有 C-old,new 的节点，不可能出现两个 leader。</p><p><strong>阶段3. C-new 已经下发但尚未 commit</strong></p><p>该阶段集群中可能有三种节点 C-old、C-old,new、C-new，但由于已经经历了阶段2，因此 C-old 节点不可能再成为 leader。而无论是 C-old,new 还是 C-new 节点发起选举，都需要经过大多数 C-new 节点的同意，因此也不可能出现两个 leader。</p><p><strong>阶段4. C-new 已经 commit</strong></p><p>该阶段 C-new 已经被 commit，因此只有 C-new 节点可以得到大多数选票成为 leader。此时集群已经安全地完成了这轮变更，可以继续开启下一轮变更了。</p><p>以上便是对该两阶段方法可行性的分步验证，Raft 论文将该方法称之为<strong>共同一致（Joint Consensus）</strong>。</p><p>关于集群成员变更另一篇更详细的论文还给出了其它方法，简单来说就是论证<strong>一次只变更一个节点的</strong>的正确性，并给出解决可用性问题的优化方案。感兴趣的同学可以参考：<a href="https://github.com/ongardie/dissertation">《Consensus: Bridging Theory and Practice》</a>。</p><h1 id="单节点变更single-server-changes"><strong>单节点变更（single-server changes）</strong></h1><p>该算法<strong>每次只允许增加或移除一个节点</strong>，只有当上一轮成员变更结束，才能开始下一轮，复杂的成员变更转换为多次单个成员变更。 增加或删除一个节点时，新旧配置中构成 <code>majority</code> 的部分必有重叠，不会有单独一部分做出决定，保证了 <code>safety</code>: <img src="https://youjiali1995.github.io/assets/images/raft_one_node.png" alt="image" /></p><p>当发起成员变更时，<code>leader</code> 会增加一个特殊的 <code>log entry</code>，然后通过 <code>log replication</code> 复制到其他节点上。<code>raft thesis</code> 中是节点<strong>接收到</strong>成员变更的 <code>entry</code> 时，就使用 新的配置，当该 <code>entry</code> 被 <code>commit</code> 后，意味着 <code>majority</code> 节点采用了新的配置，该次成员变更结束，可以开始下一轮。采用这种方式，节点配置需要能够回退，因为未 <code>commit</code> 的 <code>entry</code> 有可能被覆盖。</p><p>因为节点只有接收到 <code>config change entry</code> 才会改变配置，需要处理不在当前配置内的节点的消息：</p><ul><li>节点需要接收不在自己集群成员内的 <code>leader</code> 的 <code>AppendEntries</code>，否则新加入的节点将永远不会加入到集群中(不会接收任何 <code>log</code>)；</li><li>节点需要给不在自己集群成员内的节点投票，比如给3个节点的集群增加了第4个节点，当 <code>leader</code> 挂了需要新增加的节点也可以投票；</li><li>被移除的节点不会收到 <code>heartbeat</code>，可能会超时发起投票影响集群(因为上面第二点)，使用 <code>check quorum</code> 和 <code>Pre-Vote</code> 可以解决。</li></ul><p><code>etcd/raft</code> 的实现有所不同：只有当成员变更的 <code>entry</code> 被 <code>apply</code> 之后，才使用新的配置(同样需要处理上面的问题)。<code>raft thesis</code> 中写道，但是我没有想到在某种情况下，使用 <code>etcd/raft</code> 的方式会有问题:</p><blockquote><p>It is only safe to start another membership change once a majority of the old cluster has moved to operating under the rules of Cnew. If servers adopted Cnew only when they learned that Cnew was committed, Raft leaders would have a difficult time knowing when a majority of the old cluster had adopted it.</p></blockquote><p>使用 <code>etcd/raft</code> 的方式需要注意: 从2个节点中移除一个时，若有一个节点挂了，则整个集群不可用，但是一般至少使用3副本。</p><h2 id="etcdraft-实现">etcd/raft 实现</h2><p>调用 <code>Node.ProposeConfChange()</code> 来发起成员变更，因为也需要通过 <code>log replication</code> 来提交，所以复用了 <code>pb.Entry</code>，需要进行 <code>marshal</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> ProposeConfChange(ctx context.Context, cc pb.ConfChange) <span class="hljs-type">error</span> &#123;<br>data, err := cc.Marshal()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> n.Step(ctx, pb.Message&#123;Type: pb.MsgProp, Entries: []pb.Entry&#123;&#123;Type: pb.EntryConfChange, Data: data&#125;&#125;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pb.ConfChange</code> 结构如下：</p><ul><li><p><code>Type</code>: 成员变更操作类型，包括增加节点、删除节点等；</p></li><li><p><code>NodeId</code>: <code>etcd/raft</code> 中使用 <code>ID</code> 代表节点，<code>ID</code> 必须非零且唯一(使用之前使用过的也不行)；</p></li><li><p><code>Context</code>: 可以用来保存节点的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ConfChange <span class="hljs-keyword">struct</span> &#123;<br>  ID               <span class="hljs-type">uint64</span>         <span class="hljs-string">`protobuf:&quot;varint,1,opt,name=ID&quot; json:&quot;ID&quot;`</span><br>  Type             ConfChangeType <span class="hljs-string">`protobuf:&quot;varint,2,opt,name=Type,enum=raftpb.ConfChangeType&quot; json:&quot;Type&quot;`</span><br>  NodeID           <span class="hljs-type">uint64</span>         <span class="hljs-string">`protobuf:&quot;varint,3,opt,name=NodeID&quot; json:&quot;NodeID&quot;`</span><br>  Context          []<span class="hljs-type">byte</span>         <span class="hljs-string">`protobuf:&quot;bytes,4,opt,name=Context&quot; json:&quot;Context,omitempty&quot;`</span><br>  XXX_unrecognized []<span class="hljs-type">byte</span>         <span class="hljs-string">`json:&quot;-&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>在 <code>raft.StepLeader()</code> 中会判断是否有未完成 <code>config change</code>，若存在，则忽略新的 <code>config change</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, e := <span class="hljs-keyword">range</span> m.Entries &#123;<br>    <span class="hljs-keyword">if</span> e.Type == pb.EntryConfChange &#123;<br>        <span class="hljs-keyword">if</span> r.pendingConfIndex &gt; r.raftLog.applied &#123; <span class="hljs-comment">// 存在未完成的 config change</span><br>            r.logger.Infof(<span class="hljs-string">&quot;propose conf %s ignored since pending unapplied configuration [index %d, applied %d]&quot;</span>,<br>                e.String(), r.pendingConfIndex, r.raftLog.applied)<br>            m.Entries[i] = pb.Entry&#123;Type: pb.EntryNormal&#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.pendingConfIndex = r.raftLog.lastIndex() + <span class="hljs-type">uint64</span>(i) + <span class="hljs-number">1</span> <span class="hljs-comment">// 设置 pendingConfIndex 为 config change entry 的 index</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 <code>config change</code> 被提交了，调用 <code>Node.ApplyConfChange()</code> 来完成成员变更：</p><ul><li>调用 <code>raft</code> 的接口增加或删除节点：<code>etcd/raft</code> 的实现很简单，就是操作 <code>raft.prs</code>(<code>NodeId</code> 到 <code>Progress</code> 的映射)；</li><li>返回最新的集群结构。 用户根据 <code>config change</code> 的类型，决定是关闭节点，还是新建连接。</li></ul><h2 id="启动">启动</h2><p>在启动一个新的集群时，<code>raft.StartNode()</code> 中需要传入集群的 <code>peer list</code>，然后使用 <code>config change</code> 的方式添加节点，使用这种方式把启动时的成员配置和成员变更统一起来，简化了实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartNode</span><span class="hljs-params">(c *Config, peers []Peer)</span></span> Node &#123;<br>r := newRaft(c)<br>r.becomeFollower(<span class="hljs-number">1</span>, None)<br><span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> peers &#123;<br>cc := pb.ConfChange&#123;Type: pb.ConfChangeAddNode, NodeID: peer.ID, Context: peer.Context&#125;<br>d, err := cc.Marshal()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unexpected marshal error&quot;</span>)<br>&#125;<br>e := pb.Entry&#123;Type: pb.EntryConfChange, Term: <span class="hljs-number">1</span>, Index: r.raftLog.lastIndex() + <span class="hljs-number">1</span>, Data: d&#125;<br>r.raftLog.<span class="hljs-built_in">append</span>(e)<br>&#125;<br>r.raftLog.committed = r.raftLog.lastIndex()<br><span class="hljs-keyword">for</span> _, peer := <span class="hljs-keyword">range</span> peers &#123;<br>r.addNode(peer.ID)<br>&#125;<br><br>n := newNode()<br>n.logger = c.Logger<br><span class="hljs-keyword">go</span> n.run(r)<br><span class="hljs-keyword">return</span> &amp;n<br>&#125;<br></code></pre></td></tr></table></figure><p><code>README</code> 中只传入了其他节点的 <code>ID</code>，不包含自己的，应该有问题，<code>peer list</code> 应该包含所有节点的 <code>ID</code>，否则节点的 <code>log</code> 有冲突，新加入节点的成员配置也会出错。</p><p>当需要新增一个节点时，首先给集群发起成员变更，然后不用传入 <code>peer list</code> 启动节点，集群配置会在 <code>log replication</code> 过程中同步到新节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">n := raft.StartNode(c, <span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure><h2 id="snapshot">Snapshot</h2><p><code>raft</code> 的集群配置通过 <code>log replication</code> 传递，同样也通过 <code>log</code> 来恢复，通过一个个应用 <code>log entry</code> 能够恢复到一致的集群成员配置。之前提到 <code>snapshot</code> 只保存了状态机的状态，为了支持成员变更， <code>snapshot</code> 中需要保存该 <code>snapshot</code> 对应的集群成员配置：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SnapshotMetadata <span class="hljs-keyword">struct</span> &#123;<br>ConfState        ConfState <span class="hljs-string">`protobuf:&quot;bytes,1,opt,name=conf_state,json=confState&quot; json:&quot;conf_state&quot;`</span><br>Index            <span class="hljs-type">uint64</span>    <span class="hljs-string">`protobuf:&quot;varint,2,opt,name=index&quot; json:&quot;index&quot;`</span><br>Term             <span class="hljs-type">uint64</span>    <span class="hljs-string">`protobuf:&quot;varint,3,opt,name=term&quot; json:&quot;term&quot;`</span><br>XXX_unrecognized []<span class="hljs-type">byte</span>    <span class="hljs-string">`json:&quot;-&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ConfState <span class="hljs-keyword">struct</span> &#123;<br>Nodes            []<span class="hljs-type">uint64</span> <span class="hljs-string">`protobuf:&quot;varint,1,rep,name=nodes&quot; json:&quot;nodes,omitempty&quot;`</span><br>Learners         []<span class="hljs-type">uint64</span> <span class="hljs-string">`protobuf:&quot;varint,2,rep,name=learners&quot; json:&quot;learners,omitempty&quot;`</span><br>XXX_unrecognized []<span class="hljs-type">byte</span>   <span class="hljs-string">`json:&quot;-&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="learner">Learner</h1><p>加入新的节点有可能降低集群的可用性，因为新的节点需要花费很长时间来同步 <code>log</code>，可能导致集群无法 <code>commit</code> 新的请求，比如原来有 3 个节点的集群，可以容忍 1 个节点出错，然后新加入了一个节点， 若原先的一个节点出错会导致集群不能 <code>commit</code> 新的请求，直到节点恢复或新节点追上: <img src="https://youjiali1995.github.io/assets/images/raft_learner.png" alt="image" /></p><p>为了避免这个问题，可以引入 <code>learner</code> 状态，新加入的节点设置为 <code>learner</code> 状态，该状态的节点不计在 <code>majority</code>，也就不参与投票和 <code>commit</code>， 当 <code>learner</code> 追上集群的进度时，提升为正常的节点，完成 <code>config change</code>。</p><p><code>etcd/raft</code> 增加了 <code>learner</code> 特性，但是没有投入使用，也没有实现判断 <code>learner</code> 进度。过程和上面类似，只是设置 <code>ConfChangeType</code> 为 <code>ConfChangeAddLearnerNode</code>。<code>etcd/raft</code> 使用 <code>raft.learnerPrs</code> 保存 <code>learner</code> 节点的 <code>NodeId</code> 到 <code>Progress</code> 的映射，当应用成员变更时，调用 <code>raft.addNodeOrLearnerNode()</code> 添加到 <code>raft.learnerPrs</code> 中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *raft)</span></span> addNodeOrLearnerNode(id <span class="hljs-type">uint64</span>, isLearner <span class="hljs-type">bool</span>) &#123;<br>pr := r.getProgress(id)<br><span class="hljs-keyword">if</span> pr == <span class="hljs-literal">nil</span> &#123;<br>r.setProgress(id, <span class="hljs-number">0</span>, r.raftLog.lastIndex()+<span class="hljs-number">1</span>, isLearner)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> isLearner &amp;&amp; !pr.IsLearner &#123;<br><span class="hljs-comment">// can only change Learner to Voter</span><br>r.logger.Infof(<span class="hljs-string">&quot;%x ignored addLearner: do not support changing %x from raft peer to learner.&quot;</span>, r.id, id)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> isLearner == pr.IsLearner &#123;<br><span class="hljs-comment">// Ignore any redundant addNode calls (which can happen because the</span><br><span class="hljs-comment">// initial bootstrapping entries are applied twice).</span><br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// change Learner to Voter, use origin Learner progress</span><br><span class="hljs-built_in">delete</span>(r.learnerPrs, id)<br>pr.IsLearner = <span class="hljs-literal">false</span><br>r.prs[id] = pr<br>&#125;<br><br><span class="hljs-keyword">if</span> r.id == id &#123;<br>r.isLearner = isLearner<br>&#125;<br><br><span class="hljs-comment">// When a node is first added, we should mark it as recently active.</span><br><span class="hljs-comment">// Otherwise, CheckQuorum may cause us to step down if it is invoked</span><br><span class="hljs-comment">// before the added node has a chance to communicate with us.</span><br>pr = r.getProgress(id)<br>pr.RecentActive = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当判断 <code>learner</code> 节点追上其他节点，需要提升为正常节点时，需要再发起一次正常的成员变更。只允许 <code>learner</code> 变为 <code>voter</code>，不允许反过来。</p><p><code>learner</code> 节点有如下特性：</p><ul><li><p>当<code>election timeout</code>时，不会成为<code>candidate</code>发起选举:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *raft)</span></span> promotable() <span class="hljs-type">bool</span> &#123;<br>  _, ok := r.prs[r.id]<br>  <span class="hljs-keyword">return</span> ok<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>不会给其他节点投票：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> pb.MsgVote, pb.MsgPreVote:<br>  <span class="hljs-keyword">if</span> r.isLearner &#123;<br>      <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> learner may need to vote, in case of node down when confchange.</span><br>      r.logger.Infof(<span class="hljs-string">&quot;%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: learner can not vote&quot;</span>,<br>          r.id, r.raftLog.lastTerm(), r.raftLog.lastIndex(), r.Vote, m.Type, m.From, m.LogTerm, m.Index, r.Term)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>不计在<code>quorum</code>中:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *raft)</span></span> quorum() <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(r.prs)/<span class="hljs-number">2</span> + <span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="leadership-transfer">Leadership transfer</h1><p>有可能需要移除的节点是 <code>leader</code>，按照 <code>raft thesis</code> 的做法会比较奇怪，<code>leader</code> 需要管理不包含自己的集群，直到提交之后再 <code>step down</code>，可以通过 <code>leadership transfer</code> 将 <code>leadership</code> 转移到其他节点， 然后再移除原先的 <code>leader</code>。<code>leadership transfer</code> 还有其他的用途，比如 <code>leader</code> 所在机器的负载比较高，要转移到低负载机器上；<code>leader</code> 要改变机房实现就近等，同时还能降低选举的影响。</p><p><code>leadership transfer</code> 的流程如下：</p><ol type="1"><li><code>leader</code> 停止接收新的请求；</li><li>通过 <code>log replication</code> 使 <code>leader</code> 和 <code>transferee</code> 的 <code>log</code> 相同，确保 <code>transferee</code> 能够赢得选举；</li><li><code>leader</code> 发送 <code>TimeoutNow</code> 给 <code>transferee</code>，<code>transferee</code> 会立即发起选举。<code>leader</code> 收到 <code>transferee</code> 的消息会 <code>step down</code>。</li></ol><p>仍有几个问题需要处理：</p><ul><li><code>transferee</code> 挂了: 当 <code>leadership transfer</code> 在 <code>election timeout</code> 时间内未完成，则终止并恢复接收客户端请求。</li><li><code>transferee</code> 有大概率成为下一个 <code>leader</code>，若失败，可以重新发起 <code>leader transfer</code>。</li><li><code>check quorum</code> 会使节点忽略 <code>RequestVote</code>，需要强制投票。</li></ul><h2 id="etcdraft-实现-1">etcd/raft 实现</h2><p>调用 <code>Node.TransferLeadership()</code> 发起 <code>leadership transfer</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(n *node)</span></span> TransferLeadership(ctx context.Context, lead, transferee <span class="hljs-type">uint64</span>) &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-comment">// manually set &#x27;from&#x27; and &#x27;to&#x27;, so that leader can voluntarily transfers its leadership</span><br><span class="hljs-keyword">case</span> n.recvc &lt;- pb.Message&#123;Type: pb.MsgTransferLeader, From: transferee, To: lead&#125;:<br><span class="hljs-keyword">case</span> &lt;-n.done:<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>leader</code> 接收到之后会做一些检查，如果有正在进行的 <code>leadership transfer</code>，则终止之前的；检查 <code>transferee</code> 的 <code>ID</code> 等。主要看一下正常的逻辑：</p><ul><li><p>设置 <code>r.electionElapsed = 0</code>，用于检测 <code>leadership transfer</code> 超时；</p></li><li><p>设置 <code>r.leadTransferee = leadTransferee</code>，表示正在进行 <code>leadership transfer</code>；</p></li><li><p>若<code>transferee</code>的<code>log</code>已经最新，则立刻发送<code>TimeoutNow</code>，否则等到<code>log</code>匹配时，再发送：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> pb.MsgTransferLeader:<br><span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// Transfer leadership should be finished in one electionTimeout, so reset r.electionElapsed.</span><br>  r.electionElapsed = <span class="hljs-number">0</span><br>  r.leadTransferee = leadTransferee<br>  <span class="hljs-keyword">if</span> pr.Match == r.raftLog.lastIndex() &#123;<br>      r.sendTimeoutNow(leadTransferee)<br>      r.logger.Infof(<span class="hljs-string">&quot;%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log&quot;</span>, r.id, leadTransferee, leadTransferee)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      r.sendAppend(leadTransferee)<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><p><code>leader</code> 不会接收新的客户端请求：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> pb.MsgProp:<br><span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> r.leadTransferee != None &#123;<br>        r.logger.Debugf(<span class="hljs-string">&quot;%x [term %d] transfer leadership to %x is in progress; dropping proposal&quot;</span>, r.id, r.Term, r.leadTransferee)<br>        <span class="hljs-keyword">return</span> ErrProposalDropped<br>    &#125;<br></code></pre></td></tr></table></figure><p>当 <code>transferee</code> 的 <code>log</code> 追上时，发送 <code>TimeoutNow</code>:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// Transfer leadership is in progress.</span><br><span class="hljs-keyword">if</span> m<span class="hljs-selector-class">.From</span> == r<span class="hljs-selector-class">.leadTransferee</span> &amp;&amp; pr<span class="hljs-selector-class">.Match</span> == r<span class="hljs-selector-class">.raftLog</span><span class="hljs-selector-class">.lastIndex</span>() &#123;<br>    r<span class="hljs-selector-class">.logger</span><span class="hljs-selector-class">.Infof</span>(<span class="hljs-string">&quot;%x sent MsgTimeoutNow to %x after received MsgAppResp&quot;</span>, r<span class="hljs-selector-class">.id</span>, m.From)<br>    r<span class="hljs-selector-class">.sendTimeoutNow</span>(m.From)<br></code></pre></td></tr></table></figure><p>当 <code>transferee</code> 收到 <code>TimeoutNow</code>，调用 <code>raft.campaign(campaignTransfer)</code>，会跳过 <code>Pre-Vote</code> 阶段，和正常投票只有一点不同，会设置 <code>Message.Context</code> 用于跳过 <code>check quorum</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ctx []<span class="hljs-type">byte</span><br><span class="hljs-keyword">if</span> t == campaignTransfer &#123;<br>    ctx = []<span class="hljs-type">byte</span>(t)<br>&#125;<br>r.send(pb.Message&#123;Term: term, To: id, Type: voteMsg, Index: r.raftLog.lastIndex(), LogTerm: r.raftLog.lastTerm(), Context: ctx&#125;)<br></code></pre></td></tr></table></figure><p>在其他节点收到携带 <code>Context</code> 的 <code>RequestVote</code> 消息时，会强制投票：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">force := bytes.Equal(m.Context, []<span class="hljs-type">byte</span>(campaignTransfer))<br></code></pre></td></tr></table></figure><p><code>leader</code> 在 <code>tickHeartbeat()</code> 中检测 <code>leadership transfer</code> 超时，设置 <code>raft.leadTransferee = None</code> 终止：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// tickHeartbeat is run by leaders to send a MsgBeat after r.heartbeatTimeout.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *raft)</span></span> tickHeartbeat() &#123;<br>r.heartbeatElapsed++<br>r.electionElapsed++<br><br><span class="hljs-keyword">if</span> r.electionElapsed &gt;= r.electionTimeout &#123;<br>r.electionElapsed = <span class="hljs-number">0</span><br><span class="hljs-comment">// If current leader cannot transfer leadership in electionTimeout, it becomes leader again.</span><br><span class="hljs-keyword">if</span> r.state == StateLeader &amp;&amp; r.leadTransferee != None &#123;<br>r.abortLeaderTransfer()<br>&#125;<br>&#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>至此我们已经将 Raft 论文中的内容基本讲解完毕了。<a href="https://raft.github.io/raft.pdf">《In Search of an Understandable Consensus Algorithm (Extended Version)》</a> 毕竟只有18页，更加侧重于理论描述而非工程实践。如果你想深入学习 Raft，或自己动手写一个靠谱的 Raft 实现，<a href="https://github.com/ongardie/dissertation">《Consensus: Bridging Theory and Practice》</a> 是你参考的不二之选。</p>]]></content>
    
    
    <categories>
      
      <category>Distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft 协议（二）—— 日志复制与日志压缩</title>
    <link href="/2022/09/16/raft-2/"/>
    <url>/2022/09/16/raft-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>摘录自<a href="https://juejin.cn/post/6899464146719342605">Q的博客</a></p></blockquote><p><strong>一句话先总结文章讲啥</strong>：基于日志的 raft 状态复制机原理，其也是分布式系统对外展现成统一视图，以及实现分布式一致性的基础。</p><hr /><h1 id="什么是日志复制">什么是日志复制</h1><p>在前文中我们讲过：共识算法通常基于<strong>状态复制机（Replicated State Machine）模型，所有节点从同一个 state 出发</strong>，经过一系列<strong>同样操作 log</strong> 的步骤，最终也必将达到<strong>一致的 state</strong>。也就是说，只要我们保证集群中所有节点的 log 一致，那么经过一系列追加操作（apply）后最终得到的状态机也就是一致的。</p><p>Raft 负责保证集群中所有节点 <strong>log 的一致性</strong>。</p><p>此外我们还提到过：raft 赋予了 leader 节点更强的领导力（<strong>Strong Leader</strong>）。那么 raft 保证 log 一致的方式就很容易理解了，即所有操作（log）都必须交给 leader 节点处理（follewer 接收写操作会转交给 leader 处理），并由 leader 节点复制给其它节点，来保证整个集群的 log 实现层面的一致。</p><p>这个过程，就叫做<strong>日志复制（Log replication）</strong>，对应的系统模型就是“<strong>日志状态复制机</strong>”。</p><h1 id="raft-日志复制机制解析">Raft 日志复制机制解析</h1><h2 id="整体流程解析">整体流程解析</h2><p>一旦 leader 被票选出来，它就承担起领导整个集群的责任了，开始接收客户端请求，并将操作包装成日志，并复制到其它节点上去。</p><p>整体流程如下：</p><ul><li>Leader 为客户端提供服务，客户端的每个请求都包含一条即将被状态复制机执行的指令。</li><li>Leader 把该指令作为一条新的日志附加到自身的日志集合，然后向其它节点发起<strong>附加条目请求（AppendEntries RPC）</strong>，来要求它们将这条日志附加到各自本地的日志集合。</li><li>当这条日志已经确保被<strong>安全的复制</strong>，即大多数（N/2+1）节点都已经复制后，leader 会将该日志 <strong>apply</strong> 到它本地的状态机中，然后把操作成功的结果返回给客户端。</li></ul><p>整个集群的日志模型可以宏观表示为下图（x ← 3 代表x赋值为3 ）：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d6b91f49ac4d11bee43f86f33566d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="Raft 集群日志模型" /><figcaption aria-hidden="true">Raft 集群日志模型</figcaption></figure><p>每条日志除了存储状态机的操作指令外（譬如 x ← 3 这种赋值指令，代表 x 赋值为3），还会拥有一个<strong>唯一的整数索引值</strong>（<strong>log index</strong>）来表明它在日志集合中的位置。此外，每条日志还会存储一个 <strong>term</strong> 号（日志条目方块最上方的数字，相同颜色 term 号相同），该 term 表示 leader 收到这条指令时的当前任期，term 相同的 log 是由同一个 leader 在其任期内发送的。</p><p>当一条日志被 leader 节点认为可以安全的 apply 到状态机时，称这条日志是 <strong>committed</strong>（上图中的 <strong>committed entries</strong>）。那么什么样的日志可以被 commit 呢？答案是：<strong>当 leader 得知这条日志被集群过半的节点复制成功时</strong>。因此在上图中我们可以看到 (term3, index7) 这条日志以及之前的日志都是 committed，尽管有两个节点拥有的日志并不完整。</p><p>Raft 保证所有 committed 日志都已经被<strong>持久化</strong>，且“<strong>最终</strong>”一定会被状态机apply。</p><blockquote><p><em>注：这里的“最终”用词很微妙，它表明了一个特点：Raft保证的只是日志的一致性，而我们真正期望的状态机的一致性需要我们做一些额外工作，这一点在后续《线性一致性与性能优化》一篇会着重介绍。</em></p></blockquote><h2 id="raft-日志复制流程图解">Raft 日志复制流程图解</h2><p>我们通过 <a href="https://raft.github.io/">raft 动画</a>来模拟常规日志复制这一过程。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11bd5a3d291b43d2b31fea3a75fb3655~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img" /> **图 1*</p><p>如图1，S1 当选 leader，此时还没有任何日志。我们模拟客户端向 S1 发起一个请求。</p><figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a17a0e447534541a520ec97a9942cdd~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图2" /><figcaption aria-hidden="true">图2</figcaption></figure><p>如图2，S1 收到客户端请求后新增了一条日志 (term2, index1)，然后并行地向其它节点发起 AppendEntries RPC。</p><figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b0c350086014a52a4989f02f5262153~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图 3" /><figcaption aria-hidden="true">图 3</figcaption></figure><p>如图3，S2、S4 率先收到了请求，各自附加了该日志，并向 S1 回应响应。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f062cd961a24c5a951f2c025f065bd4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图 4" /><figcaption aria-hidden="true">图 4</figcaption></figure><p>如图4，所有节点都附加了该日志，但由于 leader 尚未收到任何响应，因此暂时还不清楚该日志到底是否被成功复制。</p><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97dbbaaf72cc4a2ba148cb252bce95ec~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图 5" /><figcaption aria-hidden="true">图 5</figcaption></figure><p>如图5，当 S1 收到<strong>2个节点</strong>的响应时，该日志条目的边框就已经变为实线，表示该日志已经<strong>安全的复制</strong>，因为在5节点集群中，2个 follower 节点加上 leader 节点自身，副本数已经确保过半，此时 <strong>S1 将响应客户端的请求</strong>。</p><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a127762b466a48719967d52ab9f0636c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图 6" /><figcaption aria-hidden="true">图 6</figcaption></figure><p>如图6，leader 后续会持续发送心跳包给 followers，心跳包中会携带当前<strong>已经安全复制（我们称之为 committed）的日志索引</strong>，此处为 (term2, index1)。</p><figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ebe584867b4c0b98b1e46f595a5007~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图 7" /><figcaption aria-hidden="true">图 7</figcaption></figure><p>如图7，所有 follower 都通过心跳包得知 (term2, index1) 的 log 已经成功复制 （committed），因此所有节点中该日志条目的边框均变为实线。</p><h2 id="raft-对日志一致性的保证">Raft 对日志一致性的保证</h2><p>前边我们使用了 (term2, index1) 这种方式来表示一条日志条目，这里为什么要带上 term，而不仅仅是使用 index？原因是 term 可以用来检查不同节点间日志是否存在不一致的情况，阅读下一节后会更容易理解这句话。</p><p>Raft 保证：<strong>如果不同的节点日志集合中的两个日志条目拥有相同的 term 和 index，那么它们一定存储了相同的指令。</strong></p><p>为什么可以作出这种保证？因为 raft 要求 leader 在一个 term 内针对同一个 index 只能创建一条日志，并且永远不会修改它。</p><p>同时 raft 也保证：<strong>如果不同的节点日志集合中的两个日志条目拥有相同的 term 和 index，那么它们之前的所有日志条目也全部相同。</strong></p><p>这是因为 leader 发出的 AppendEntries RPC 中会额外携带<strong>上一条</strong>日志的 (term, index)，如果 follower 在本地找不到相同的 (term, index) 日志，则<strong>拒绝接收这次新的日志</strong>。</p><p>所以，只要 follower 持续正常地接收来自 leader 的日志，那么就可以通过归纳法验证上述结论。</p><h2 id="可能出现的日志不一致场景">可能出现的日志不一致场景</h2><p>在所有节点正常工作的时候，leader 和 follower的日志总是保持一致，AppendEntries RPC 也永远不会失败。然而我们总要面对任意节点随时可能宕机的风险，如何在这种情况下继续保持集群日志的一致性才是我们真正要解决的问题。</p><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/012758dde1ba4305b417d860236a2ecc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="日志不一致场景图" /><figcaption aria-hidden="true">日志不一致场景图</figcaption></figure><p>上图展示了一个 term8 的 leader 刚上任时，集群中日志可能存在的混乱情况。例如 follower 可能缺少一些日志（a ~ b），可能多了一些未提交的日志（c ~ d），也可能既缺少日志又多了一些未提交日志（e ~ f）。</p><p><em>注：Follower 不可能比 leader 多出一些已提交（committed）日志，这一点是通过选举上的限制来达成的，会在下一篇 Safety 部分介绍。</em></p><p>我们先来尝试复现上述 a ~ f 场景，最后再讲 raft 如何解决这种不一致问题。</p><p><strong>场景a~b. Follower 日志落后于 leader</strong></p><p>这种场景其实很简单，即 <strong>follower 宕机了一段时间</strong>，follower-a 从收到 (term6, index9) 后开始宕机，follower-b 从收到 (term4, index4) 后开始宕机。这里不再赘述。</p><p><strong>场景c. Follower 日志比 leader 多 term6</strong></p><p>当 term6 的 leader 正在将 (term6, index11) 向 follower 同步时，该 leader 发生了宕机，且此时只有 follower-c 收到了这条日志的 AppendEntries RPC。然后经过一系列的选举，term7 可能是选举超时，也可能是 leader 刚上任就宕机了，最终 term8 的 leader 上任了，成就了我们看到的场景 c。</p><p><strong>场景d. Follower 日志比 leader 多 term7</strong></p><p>当 term6 的 leader 将 (term6, index10) 成功 commit 后，发生了宕机。此时 term7 的 leader 走马上任，连续同步了两条日志给 follower，然而还没来得及 commit 就宕机了，随后集群选出了 term8 的 leader。</p><p><strong>场景e. Follower 日志比 leader 少 term5 ~ 6，多 term4</strong></p><p>当 term4 的 leader 将 (term4, index7) 同步给 follower，且将 (term4, index5) 及之前的日志成功 commit 后，发生了宕机，紧接着 follower-e 也发生了宕机。这样在 term5~7 内发生的日志同步全都被 follower-e 错过了。当 follower-e 恢复后，term8 的 leader 也刚好上任了。</p><p><strong>场景f. Follower 日志比 leader 少 term4 ~ 6，多 term2 ~ 3</strong></p><p>当 term2 的 leader 同步了一些日志（index4 ~ 6）给 follower 后，尚未来得及 commit 时发生了宕机，但它很快恢复过来了，又被选为了 term3 的 leader，它继续同步了一些日志（index7~11）给 follower，但同样未来得及 commit 就又发生了宕机，紧接着 follower-f 也发生了宕机，当 follower-f 醒来时，集群已经前进到 term8 了。</p><h2 id="如何处理日志不一致">如何处理日志不一致</h2><p>通过上述场景我们可以看到，真实世界的集群情况很复杂，那么 raft 是如何应对这么多不一致场景的呢？其实方式很简单暴力，想想 <strong>Strong Leader</strong> 这个词。</p><p><strong>Raft 强制要求 follower 必须复制 leader 的日志集合来解决不一致问题。</strong></p><p>也就是说，follower 节点上任何与 leader 不一致的日志，都会被 leader 节点上的日志所覆盖。这并不会产生什么问题，因为某些选举上的限制，如果 follower 上的日志与 leader 不一致，那么该日志在 follower 上<strong>一定是未提交的</strong>。未提交的日志并不会应用到状态机，也不会被外部的客户端感知到。</p><p>要使得 follower 的日志集合跟自己保持完全一致，leader 必须先找到二者间<strong>最后一次</strong>达成一致的地方。因为一旦这条日志达成一致，在这之前的日志一定也都一致（回忆下前文）。这个确认操作是在 AppendEntries RPC 的一致性检查步骤完成的。</p><p>Leader 针对每个 follower 都维护一个 <strong>next index</strong>，表示下一条需要发送给该follower 的日志索引。当一个 leader 刚刚上任时，它初始化所有 next index 值为自己最后一条日志的 index+1。但凡某个 follower 的日志跟 leader 不一致，那么下次 AppendEntries RPC 的一致性检查就会失败。在被 follower 拒绝这次 Append Entries RPC 后，leader 会减少 next index 的值并进行重试。</p><p>最终一定会存在一个 next index 使得 leader 和 follower 在这之前的日志都保持一致。极端情况下 next index 为1，表示 follower 没有任何日志与 leader 一致，leader 必须从第一条日志开始同步。</p><p>针对每个 follower，一旦确定了 next index 的值，leader 便开始从该 index 同步日志，follower 会删除掉现存的不一致的日志，保留 leader 最新同步过来的。</p><p>整个集群的日志会在这个简单的机制下自动趋于一致。此外要注意，<strong>leader 从来不会覆盖或者删除自己的日志</strong>，而是强制 follower 与它保持一致。</p><p>这就要求集群票选出的 leader 一定要具备“日志的正确性（原文是 Safety，但用“正确性”可以帮大家更好理解）”，这也就是前文提到的：选举上的限制。</p><p>前面的章节我们讲述了 Raft 算法是如何选主和复制日志的，然而到目前为止我们描述的<strong>这套机制还不能保证每个节点的状态机会严格按照相同的顺序 apply 日志</strong>。想象以下场景：</p><ol type="1"><li>Leader 将一些日志复制到了大多数节点上，进行 commit 后发生了宕机。</li><li>某个 follower 并没有被复制到这些日志，但它参与选举并当选了下一任 leader。</li><li>新的 leader 又同步并 commit 了一些日志，这些日志覆盖掉了其它节点上的上一任 committed 日志。</li><li>各个节点的状态机可能 apply 了不同的日志序列，出现了不一致的情况。</li></ol><p>因此我们需要对“选主+日志复制”这套机制加上一些额外的限制，来保证<strong>状态机的安全性</strong>，也就是是 Raft 算法的正确性。</p><h1 id="安全性">安全性</h1><p>通常来说，共识算法需要满足三项基本性质[1]，分别为<strong>一致性（agreement）</strong>、<strong>正确性（integrity）</strong>、<strong>最终确定性（termination）</strong>。一致性，要求所有的正确节点都获得相同的状态。正确性，决策的结果需要来自于正确节点的提案。最终确定性，要求决策在有限的时间内产生。这三项基本性质也可以概括为两项，即<strong>活性（liveness）</strong>与<strong>安全性（safety）</strong>。对于活性与安全性，有一种比较直观的描述方式：某个事件最终会发生，且这个最终会发生的事件合理[2]。活性指的就是最终确定性，意味着该系统最终总能获取某个状态。安全性指的是一致性与正确性，意味着处理的提案来自于正确节点，且正确节点最终状态总能一致。</p><p>接下来介绍 Raft 对选主和日志复制的算法限制，以保证其安全性（论文原文是 “Safety”，其实此处翻译为 <strong>“正确性”</strong> 更合适一些，国内“安全性”一般对应 “Security”，但出于对论文作者的敬意，本文继续使用“安全性”）。</p><h2 id="对选举的限制">对选举的限制</h2><p>我们再来分析下前文所述的 committed 日志被覆盖的场景，根本问题其实发生在第2步。Candidate 必须有足够的资格才能当选集群 leader，否则它就会给集群带来不可预料的错误。Candidate 是否具备这个资格可以在选举时添加一个小小的条件来判断，即：</p><p><strong>每个 candidate 必须在 RequestVote RPC 中携带自己本地日志的最新 (term, index)，如果 follower 发现这个 candidate 的日志还没有自己的新，则拒绝投票给该 candidate。</strong></p><p>Candidate 想要赢得选举成为 leader，必须得到集群大多数节点的投票，那么<strong>它的日志就一定至少不落后于大多数节点</strong>。又因为一条日志只有复制到了大多数节点才能被 commit，因此<strong>能赢得选举的 candidate 一定拥有所有 committed 日志</strong>。</p><p>因此前一篇文章我们才会断定地说：Follower 不可能比 leader 多出一些 committed 日志。</p><p>比较两个 (term, index) 的逻辑非常简单：如果 term 不同 term 更大的日志更新，否则 index 大的日志更新。</p><h2 id="对提交的限制">对提交的限制</h2><p>除了对选举增加一点限制外，我们还需对 commit 行为增加一点限制，来完成我们 Raft 算法核心部分的最后一块拼图。</p><p>回忆下什么是 commit：</p><blockquote><p>当 leader 得知某条日志被集群过半的节点复制成功时，就可以进行 commit，committed 日志一定最终会被状态机 apply。</p></blockquote><p>所谓 commit 其实就是对日志简单进行一个标记，表明其可以被 apply 到状态机，并针对相应的客户端请求进行响应。</p><p>然而 leader 并不能在任何时候都随意 commit 旧任期留下的日志，即使它已经被复制到了大多数节点。Raft 论文给出了一个经典场景：</p><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1b4e211fca44ca9bf5a67639e92d4d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图8" /><figcaption aria-hidden="true">图8</figcaption></figure><p>图8从左到右按时间顺序模拟了问题场景。</p><p><strong>阶段a</strong>：S1 是 leader，收到请求后将 (term2, index2) 只复制给了 S2，尚未复制给 S3 ~ S5。</p><p><strong>阶段b</strong>：S1 宕机，S5 当选 term3 的 leader（S3、S4、S5 三票），收到请求后保存了 (term3, index2)，尚未复制给任何节点。</p><p><strong>阶段c</strong>：S5 宕机，S1 恢复，S1 重新当选 term4 的 leader，继续将 (term2, index2) 复制给了 S3，已经满足大多数节点，我们将其 commit。</p><p><strong>阶段d</strong>：S1 又宕机，S5 恢复，S5 重新当选 leader（S2、S3、S4 三票），将 (term3, inde2) 复制给了所有节点并 commit。注意，此时发生了致命错误，已经 committed 的 (term2, index2) 被 (term3, index2) 覆盖了。</p><p>为了避免这种错误，我们需要添加一个额外的限制：</p><p><strong>Leader 只允许 commit 包含当前 term 的日志。</strong></p><p>针对上述场景，问题发生在阶段c，即使作为 term4 leader 的 S1 将 (term2, index2) 复制给了大多数节点，它也不能直接将其 commit，而是必须等待 term4 的日志到来并成功复制后，一并进行 commit。</p><p><strong>阶段e</strong>：在添加了这个限制后，要么 (term2, index2) 始终没有被 commit，这样 S5 在阶段d将其覆盖就是安全的；要么 (term2, index2) 同 (term4, index3) 一起被 commit，这样 S5 根本就无法当选 leader，因为大多数节点的日志都比它新，也就不存在前边的问题了。</p><p>以上便是对算法增加的两个小限制，它们对确保状态机的安全性起到了至关重要的作用。</p><p>至此我们对 Raft 算法的核心部分，已经介绍完毕，如果您坚持阅读到本文，相信已经能很好掌握 Raft 协议的核心算法机制。</p><h1 id="日志压缩log-compaction">日志压缩（Log compaction）</h1><p>接下来介绍Raft 实践必备技术之一——日志压缩，<strong>重点讲解状态机日志膨胀的应对方案</strong>。</p><p>尽管我们已经通过了解了 Raft 算法的核心部分，但相较于算法理论来说，在工程实践中仍有一些现实问题需要我们去面对。Raft 非常贴心的在论文中给出了两个常见问题的解决方案，它们分别是：</p><ol type="1"><li><strong>集群成员变更</strong>：如何安全地改变集群的节点成员。</li><li><strong>日志压缩</strong>：如何解决日志集合无限制增长带来的问题。</li></ol><p>首先我们将讲解日志压缩技术。</p><hr /><p>我们知道 Raft 核心算法维护了日志的一致性，通过 apply 日志我们也就得到了一致的状态机，客户端的操作命令会被包装成日志交给 Raft 处理。</p><p>然而在实际系统中，客户端操作是连绵不断的，但日志却不能无限增长：</p><ul><li><p>首先它会占用很高的存储空间；</p></li><li><p>其次每次系统重启时都需要完整回放一遍所有日志才能得到最新的状态机。</p></li></ul><p>因此 Raft 提供了一种机制去清除日志里积累的陈旧信息，叫做<strong>日志压缩</strong>。</p><p><strong>快照</strong>（<strong>Snapshot</strong>）是一种常用的、简单的日志压缩方式，ZooKeeper、Chubby 等系统都在用。简单来说，就是将某一时刻系统的状态 dump 下来并落地存储，这样该时刻之前的所有日志就都可以丢弃了。所以大家对“压缩”一词不要产生错误理解，我们并没有办法将状态机快照“解压缩”回日志序列。</p><p>注意，<strong>在 Raft 中我们只能为 committed 日志做 snapshot</strong>，因为只有 committed 日志才是确保最终会应用到状态机的。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00ef776fc5b64e56bd2abbfae3371329~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="图5" /> 图5 展示了一个节点用快照替换了 (term1, index1) ~ (term3, index5) 的日志。</p><p>快照一般包含以下内容：</p><ol type="1"><li><strong>日志的元数据</strong>：最后一条被该快照 apply 的日志 term 及 index</li><li><strong>状态机</strong>：前边全部日志 apply 后最终得到的状态机</li></ol><p>当 leader 需要给某个 follower 同步一些旧日志，但这些日志已经被 leader 做了快照并删除掉了时，leader 就需要把该快照发送给 follower。</p><p>同样，当集群中有新节点加入，或者某个节点宕机太久落后了太多日志时，leader 也可以直接发送快照，大量节约日志传输和回放时间。</p><p>当增加了 <code>snapshot</code> 之后，发送 <code>log</code> 的过程如下:</p><ol type="1"><li><code>leader</code> 的 <code>next</code> 记录了需要发送给 <code>follower</code> 的下一个 <code>entry</code>;</li><li>若 <code>next</code> 仍在 <code>log</code> 中，则发送后续的 <code>entries</code>；</li><li>若 <code>next</code> 在 <code>snapshot</code> 中，则发送 <code>snapshot</code>，发送成功后，再发送后续的 <code>entries</code>；</li><li><code>follower</code> 收到 <code>snapshot</code> 时，如果 <code>log</code> 与 <code>snapshot</code> 有冲突或者 <code>snapshot</code> 比 <code>log</code> 新，则丢弃全部 <code>log</code>，应用 <code>snapshot</code>。</li></ol><p>每个节点独立的选择何时做 <code>snapshot</code>，而不是由 <code>leader</code> 统一发起 <code>snapshot</code>：</p><ul><li><code>snapshot</code> 只清理 <code>committed log</code>，每个节点有能力独立的做 <code>snapshot</code>，不会带来一致性问题；</li><li>如果由 <code>leader</code> 做 <code>snapshot</code> 然后发送给其他节点，会浪费网络带宽；</li><li>每个节点的配置和状态可能不同，可以独立选择合适的时机做 <code>snapshot</code>。</li></ul><p>同步快照使用一个新的 RPC 方法，叫做 <strong>InstallSnapshot RPC</strong>。</p><h1 id="reference">Reference</h1><ol type="1"><li>Coulouris G F, Dollimore J, Kindberg T. Distributed systems: concepts and design[M]. pearson education, 2005.</li><li>Owicki S, Lamport L. Proving liveness properties of concurrent programs[J]. ACM Transactions on Programming Languages and Systems (TOPLAS), 1982, 4(3): 455-495.</li></ol>]]></content>
    
    
    <categories>
      
      <category>Distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft 协议（一）—— 领导者选举</title>
    <link href="/2022/09/16/raft-1/"/>
    <url>/2022/09/16/raft-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>摘录自<a href="https://juejin.cn/user/1275089220539869/posts">Q的博客</a></p></blockquote><h1 id="raft是什么">Raft是什么？</h1><blockquote><p><em>Raft is a consensus algorithm for managing a replicated log. It produces a result equivalent to (multi-)Paxos, and it is as efficient as Paxos, but its structure is different from Paxos; this makes Raft more understandable than Paxos and also provides a better foundation for building practical systems.</em></p><p>--《In Search of an Understandable Consensus Algorithm》</p></blockquote><p>在分布式系统中，为了消除单点提高系统可用性，通常会使用副本来进行容错，但这会带来另一个问题，即如何保证多个副本之间的一致性？</p><p>所谓的一致性并不是指集群中所有节点在任一时刻的状态必须完全一致，而是指一个目标，即让一个分布式系统看起来只有一个数据副本，并且读写操作都是原子的，这样应用层就可以忽略系统底层多个数据副本间的同步问题。也就是说，我们可以将一个强一致性（线性一致性）分布式系统当成一个整体，一旦某个客户端成功的执行了写操作，那么所有客户端都一定能读出刚刚写入的值。即使发生网络分区故障，或者少部分节点发生异常，整个集群依然能够像单机一样提供服务。</p><p>共识算法（Consensus Algorithm）就是用来做这个事情的，它保证即使在小部分（≤ (N-1)/2）节点故障的情况下，系统仍然能正常对外提供服务。共识算法通常基于状态复制机（Replicated State Machine）模型，也就是所有节点从同一个 state 出发，经过同样的操作 log，最终达到一致的 state。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/715f38a55fae4ef6bed7bb7cfd134825~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Replicated State Machine" /> 共识算法是构建强一致性分布式系统的基石，Paxos 是共识算法的代表，而 Raft 则是其作者在博士期间研究 Paxos 时提出的一个变种，主要优点是容易理解、易于实现，甚至关键的部分都在论文中给出了伪代码实现。</p><h1 id="raft基本概念">Raft基本概念</h1><h2 id="raft一致性相关子问题">Raft一致性相关子问题</h2><p>Raft 使用 Quorum 机制来实现共识和容错，我们将对 Raft 集群的操作称为提案，每当发起一个提案，必须得到大多数（&gt; N/2）节点的同意才能提交。</p><p>Raft 核心算法将一致性问题拆分为三个子问题，逐个解决，大大提升了算法的易用性：</p><ul><li><strong>Leader election</strong>：集群中必须存在一个 leader 节点。</li><li><strong>Log replication</strong>：Leader 节点负责接收客户端请求，并将请求操作序列化成日志同步。</li><li><strong>Safety</strong>：包括 leader 选举限制、日志提交限制等一系列措施，来确保 state machine safety。</li></ul><p>除核心算法外还有集群成员变更、日志压缩等。</p><h2 id="集群中节点角色概念">集群中节点角色概念</h2><p>Raft 集群中每个节点都处于以下三种角色之一：</p><ul><li><strong>Leader</strong>：所有请求的处理者，接收客户端发起的操作请求，写入本地日志后同步至集群其它节点。</li><li><strong>Follower</strong>：请求的被动更新者，从 leader 接收更新请求，写入本地文件。如果客户端的操作请求发送给了 follower，会首先由 follower 重定向给 leader。</li><li><strong>Candidate</strong>：如果 follower 在一定时间内没有收到 leader 的心跳，则判断 leader 可能已经故障，此时启动 leader election 过程，本节点切换为 candidate 直到选主结束。</li></ul><h2 id="选举相关概念">选举相关概念</h2><p>每开始一次新的选举，称为一个 term，每个 term 都有一个严格递增的整数与之关联。</p><p>节点的状态切换如图所示: <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9f2d1f2d3674a50900eda504ecaa326~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="节点状态图" /></p><p>具体说明如下：</p><ul><li><strong>Starts up</strong>：节点刚启动时自动进入 follower 状态。</li><li><strong>Times out, starts election</strong>：进去 follower 状态后开启一个选举定时器，到期时切换为 candidate 并发起选举，leader 节点的心跳会部分重置这个定时器。</li><li><strong>Times out, new election</strong>：进入 candidate 状态后开启一个超时定时器，如果到期时还未选出新的 leader，就保持 candidate 状态并重新开始下一次选举。</li><li><strong>Receives votes from majority of servers</strong>：Candidate 状态节点收到半数以上选票，切换状态成为新的 leader。</li><li><strong>Discovers current leader or new term</strong><ul><li>Candidate 状态节点收到 leader 或更高 term 号（本文后续有介绍）的消息，表示已经有 leader 了，切回 follower。</li></ul></li><li><strong>Discovers server with higher term</strong>：Leader 节点收到更高 term 号的消息，表示已经存在新 leader 了，切回 follower。这种切换一般发生在网络分区时，比如旧 leader 宕机后恢复。</li></ul><h2 id="term相关概念">Term相关概念</h2><p>每当 candidate 触发 leader election 时都会增加 term，如果一个 candidate 赢得选举，他将在本 term 中担任 leader 的角色，但并不是每个 term 都一定对应一个 leader，比如上述的 “times out, new election” 情况（对应下图中的t3），可能在选举超时时都没有产生一个新的 leader，此时将递增 term 号并开始一次新的选举。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3e463285d0e4d6299fca19c7ef7e334~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="Term 示意图" /></p><p>Term 更像是一个逻辑时钟（logic clock）的作用，有了它，可以发现哪些节点的状态已经过期。每一个节点都保存一个 current term，在通信时带上这个term号。</p><p>节点间通过 RPC 来通信，主要有两类 RPC 请求:</p><p><strong>RequestVote RPCs:</strong> 用于 candidate 拉票选举</p><p><strong>AppendEntries RPCs:</strong> 用于 leader 向其它节点复制日志以及同步心跳</p><h1 id="什么是选主">什么是选主</h1><p>选主（Leader election）就是在分布式系统内抉择出一个主节点来负责一些特定的工作。在执行了选主过程后，集群中每个节点都会识别出一个特定的、唯一的节点作为leader。</p><p>我们开发的系统如果遇到选主的需求，通常会直接基于 zookeeper 或 etcd 来做，把这部分的复杂性收敛到第三方系统。然而作为 etcd 基础的 raft 自身也存在“选主”的概念，这是两个层面的事情：基于 etcd 的选主指的是利用第三方 etcd 让集群对谁做主节点的决策达成一致，技术上来说利用的是 etcd 的一致性状态机、lease 以及 watch 机制，这个事情也可以改用单节点的 MySQL/Redis 来做，只是无法获得高可用性；而 raft 本身的选主则指的是在 raft 集群自身内部通过票选、心跳等机制来协调出一个大多数节点认可的主节点作为集群的 leader 去协调所有决策。</p><p><strong>当你的系统利用 etcd 来写入谁是主节点的时候，这个决策也在 etcd 内部被它自己集群选出的主节点处理并同步给其它节点。</strong></p><h1 id="raft-为什么要进行选主">Raft 为什么要进行选主？</h1><p>按照论文所述，原生的 Paxos 算法使用了一种点对点（peer-to-peer）的方式，所有节点地位是平等的。在理想情况下，算法的目的是制定<strong>一个决策</strong>，这对于简化的模型比较有意义。但在工业界很少会有系统会使用这种方式，当有一系列的决策需要被制定的时候，先选出一个 leader 节点然后让它去协调所有的决策，这样算法会更加简单快速。</p><p>此外，和其它一致性算法相比，raft 赋予了 leader 节点更强的领导力，称之为 <strong>Strong Leader</strong>。比如说日志条目只能从 leader 节点发送给其它节点而不能反着来，这种方式简化了日志复制的逻辑，使 raft 变得更加简单易懂。</p><h1 id="raft选主过程">Raft选主过程</h1><p>下图的节点状态转移图，我们在前一篇文章已经看到了，但只是做了简单的描述，接下来我们会结合具体的Leader election细节来深刻理解节点的状态转换。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63189931b5cd47fcb2b60f2145422524~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="节点状态图" /></p><h2 id="follower状态转移过程">Follower状态转移过程</h2><p>Raft 的选主基于一种心跳机制，集群中每个节点刚启动时都是 follower 身份（<strong>Step: starts up</strong>），leader 会周期性的向所有节点发送心跳包来维持自己的权威，那么首个 leader 是如何被选举出来的呢？方法是如果一个 follower 在一段时间内没有收到任何心跳，也就是选举超时，那么它就会主观认为系统中没有可用的 leader，并发起新的选举（<strong>Step: times out, starts election</strong>）。</p><p>这里有一个问题，即这个“选举超时时间”该如何制定？如果所有节点在同一时刻启动，经过同样的超时时间后同时发起选举，整个集群会变得低效不堪，极端情况下甚至会一直选不出一个主节点。Raft 巧妙的使用了一个随机化的定时器，让每个节点的“超时时间”在一定范围内随机生成，这样就大大的降低了多个节点同时发起选举的可能性。</p><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc2b320077124da39bade7adeaf7ef08~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="一个五节点Raft集群的初始状态，所有节点都是follower身份，term为1，且每个节点的选举超时定时器不同" /><figcaption aria-hidden="true">一个五节点Raft集群的初始状态，所有节点都是follower身份，term为1，且每个节点的选举超时定时器不同</figcaption></figure><p>若 follower 想发起一次选举，follower 需要先增加自己的当前 term，并将身份切换为 candidate。然后它会向集群其它节点发送“请给自己投票”的消息（RequestVote RPC）。</p><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/316b81a42ea843a192cc2f3578fbdb81~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S1 率先超时，变为 candidate，term + 1，并向其它节点发出拉票请求" /><figcaption aria-hidden="true">S1 率先超时，变为 candidate，term + 1，并向其它节点发出拉票请求</figcaption></figure><h2 id="candicate状态转移过程">Candicate状态转移过程</h2><p>Follower 切换为 candidate 并向集群其他节点发送“请给自己投票”的消息后，接下来会有三种可能的结果，也即上面<strong>节点状态图中 candidate 状态向外伸出的三条线</strong>。</p><p><strong>1. 选举成功（Step: receives votes from majority of servers）</strong></p><p>当candicate从整个集群的<strong>大多数</strong>（N/2+1）节点获得了针对同一 term 的选票时，它就赢得了这次选举，立刻将自己的身份转变为 leader 并开始向其它节点发送心跳来维持自己的权威。</p><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a851f56a384b4a0f9da76644d645ae1f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="“大部分”节点都给了S1选票" /><figcaption aria-hidden="true">“大部分”节点都给了S1选票</figcaption></figure><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6e0e622b7384ac78f733e471b280c27~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S1变为leader，开始发送心跳维持权威" /><figcaption aria-hidden="true">S1变为leader，开始发送心跳维持权威</figcaption></figure><p>每个节点针对每个 term 只能投出一张票，并且按照先到先得的原则。这个规则确保只有一个 candidate 会成为 leader。</p><p><strong>2. 选举失败（Step: discovers current leader or new term）</strong></p><p>Candidate 在等待投票回复的时候，可能会突然收到其它自称是 leader 的节点发送的心跳包，如果这个心跳包里携带的 term <strong>不小于</strong> candidate 当前的 term，那么 candidate 会承认这个 leader，并将身份切回 follower。这说明其它节点已经成功赢得了选举，我们只需立刻跟随即可。但如果心跳包中的 term 比自己小，candidate 会拒绝这次请求并保持选举状态。</p><figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4ce0c7fdf3b4039a0e4b0b200af731a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S4、S2 依次开始选举" /><figcaption aria-hidden="true">S4、S2 依次开始选举</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2535cfeb9cfb44d4a0a04506f09f7485~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S4 成为 leader，S2 在收到 S4 的心跳包后，由于 term 不小于自己当前的 term，因此会立刻切为 follower 跟随S4" /><figcaption aria-hidden="true">S4 成为 leader，S2 在收到 S4 的心跳包后，由于 term 不小于自己当前的 term，因此会立刻切为 follower 跟随S4</figcaption></figure><p><strong>3. 选举超时（Step: times out, new election）</strong></p><p>第三种可能的结果是 candidate 既没有赢也没有输。如果有多个 follower 同时成为 candidate，选票是可能被瓜分的，如果没有任何一个 candidate 能得到大多数节点的支持，那么每一个 candidate 都会超时。此时 candidate 需要增加自己的 term，然后发起新一轮选举。如果这里不做一些特殊处理，选票可能会一直被瓜分，导致选不出 leader 来。这里的“特殊处理”指的就是前文所述的<strong>随机化选举超时时间</strong>。</p><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04163db3b7ca4b4c8fbfdf4e7253a98f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S1~S5都在参与选举" /><figcaption aria-hidden="true">S1~S5都在参与选举</figcaption></figure><figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/517e2f7939394b3ca35936702a107f07~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="没有任何节点愿意给他人投票" /><figcaption aria-hidden="true">没有任何节点愿意给他人投票</figcaption></figure><figure><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b52e004bd4654cb1b51cdb409182156f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="如果没有随机化超时时间，所有节点将会继续同时发起选举……" /><figcaption aria-hidden="true">如果没有随机化超时时间，所有节点将会继续同时发起选举……</figcaption></figure><p>以上便是 candidate 三种可能的选举结果。</p><h2 id="leader-切换状态转移过程">Leader 切换状态转移过程</h2><p>节点状态图中的最后一条线是：<strong>discovers server with higher term</strong>。想象一个场景：当 leader 节点发生了宕机或网络断连，此时其它 follower 会收不到 leader 心跳，首个触发超时的节点会变为 candidate 并开始拉票（由于随机化各个 follower 超时时间不同），由于该 candidate 的 term 大于原 leader 的 term，因此所有 follower 都会投票给它，这名 candidate 会变为新的 leader。一段时间后原 leader 恢复了，收到了来自新leader 的心跳包，发现心跳中的 term 大于自己的 term，此时该节点会立刻切换为 follower 并跟随的新 leader。</p><p>上述流程的动画模拟如下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33f858652afc4be6bb1d7b1f1dc33eaa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S4 作为 term2 的 leader" /><figcaption aria-hidden="true">S4 作为 term2 的 leader</figcaption></figure><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d45e677f6c2428d9b9db7022416fe26~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S4 宕机，S5 即将率先超时" /><figcaption aria-hidden="true">S4 宕机，S5 即将率先超时</figcaption></figure><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1418b09699fe4614a594a565c55055d5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S5 当选 term3 的 leader" /><figcaption aria-hidden="true">S5 当选 term3 的 leader</figcaption></figure><figure><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0d9d314c75c4bd989dadf044ecd6307~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S4 宕机恢复后收到了来自 S5 的 term3 心跳" /><figcaption aria-hidden="true">S4 宕机恢复后收到了来自 S5 的 term3 心跳</figcaption></figure><figure><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/31b9745a2fa94fb693a7ea1257aa5f7f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="S4 立刻变为 S5 的 follower" /><figcaption aria-hidden="true">S4 立刻变为 S5 的 follower</figcaption></figure><p>以上就是 raft 的选主逻辑，但还有一些细节（譬如是否给该 candidate 投票还有一些其它条件）依赖算法的其它部分基础，我们会在后续“安全性”一篇描述。</p>]]></content>
    
    
    <categories>
      
      <category>Distributed</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Distributed</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache的基本原理</title>
    <link href="/2022/09/14/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/14/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>对于没有接触过底层技术的朋友来说，或许从未听说过cache。毕竟cache的存在对程序员来说是透明的。在接触cache之前，先为你准备段code分析。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>][<span class="hljs-number">128</span>];<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">128</span>; j++)<br>                arr[i][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>如果你曾经学习过C/C++语言，这段code自然不会陌生。如此简单的将<code>arr</code>数组所有元素置1。 你有没有想过这段code还有下面的一种写法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>][<span class="hljs-number">128</span>];<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>                arr[j][i] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>功能完全一样，但是我们一直在重复着第一种写法（或许很多的书中也是建议这么编码），你是否想过这其中的缘由？文章的主角是cache，所以你一定猜到了答案。那么cache是如何影响这2段code的呢？</p><h1 id="为什么需要cache">为什么需要cache</h1><p>在思考为什么需要cache之前，我们首先先来思考另一个问题：我们的程序是如何运行起来的？</p><p>我们应该知道程序是运行在 RAM之中，RAM 就是我们常说的DDR（例如： DDR3、DDR4等）。我们称之为main memory（主存）。当我们需要运行一个进程的时候，首先会从磁盘设备（例如，eMMC、UFS、SSD等）中将可执行程序load到主存中，然后开始执行。在CPU内部存在一堆的通用寄存器（register）。如果CPU需要将一个变量（假设地址是A）加1，一般分为以下3个步骤：</p><ol type="1"><li>CPU 从主存中读取地址A的数据到内部通用寄存器 x0（ARM64架构的通用寄存器之一）。</li><li>通用寄存器 x0 加1。</li><li>CPU 将通用寄存器 x0 的值写入主存。</li></ol><p>我们将这个过程可以表示如下：</p><figure><img src="https://pic1.zhimg.com/80/v2-1aa0caac22aec470dd15d0a7ca1f4c80_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>其实现实中，CPU通用寄存器的速度和主存之间存在着太大的差异。两者之间的速度大致如下关系：</p><figure><img src="https://pic2.zhimg.com/80/v2-cce58cab829ecc2755f6797b41bea821_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>CPU register的速度一般小于1ns，主存的速度一般是65ns左右。速度差异近百倍。因此，上面举例的3个步骤中，步骤1和步骤3实际上速度很慢。当CPU试图从主存中load/store 操作时，由于主存的速度限制，CPU不得不等待这漫长的65ns时间。如果我们可以提升主存的速度，那么系统将会获得很大的性能提升。如今的DDR存储设备，动不动就是几个GB，容量很大。如果我们采用更快材料制作更快速度的主存，并且拥有几乎差不多的容量。其成本将会大幅度上升。我们试图提升主存的速度和容量，又期望其成本很低，这就有点难为人了。因此，我们有一种折中的方法，那就是制作一块速度极快但是容量极小的存储设备。那么其成本也不会太高。这块存储设备我们称之为cache memory。在硬件上，我们将cache放置在CPU和主存之间，作为主存数据的缓存。 当CPU试图从主存中load/store数据的时候， CPU会首先从cache中查找对应地址的数据是否缓存在cache 中。如果其数据缓存在cache中，直接从cache中拿到数据并返回给CPU。当存在cache的时候，以上程序如何运行的例子的流程将会变成如下：</p><figure><img src="https://pic2.zhimg.com/80/v2-bc15d8c0612599fc3de51c4382e07aa5_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>CPU和主存之间直接数据传输的方式转变成CPU和cache之间直接数据传输。cache负责和主存之间数据传输。</p><h1 id="多级cache存储结构">多级cache存储结构</h1><p>cahe的速度在一定程度上同样影响着系统的性能。一般情况cache的速度可以达到1ns，几乎可以和CPU寄存器速度媲美。但是，这就满足人们对性能的追求了吗？并没有。当cache中没有缓存我们想要的数据的时候，依然需要漫长的等待从主存中load数据。为了进一步提升性能，引入多级cache。前面提到的cache，称之为L1 cache（第一级cache）。我们在L1 cache 后面连接L2 cache，在L2 cache 和主存之间连接L3 cache。等级越高，速度越慢，容量越大。但是速度相比较主存而言，依然很快。不同等级cache速度之间关系如下：</p><figure><img src="https://pic1.zhimg.com/80/v2-0910f3308b1d0e425c308307869a3f68_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>经过3级cache的缓冲，各级cache和主存之间的速度最萌差也逐级减小。在一个真实的系统上，各级cache之间硬件上是如何关联的呢？我们看下Cortex-A53架构上各级cache之间的硬件抽象框图如下：</p><figure><img src="https://pic3.zhimg.com/80/v2-155a251f204f87982b21b742002ef136_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在Cortex-A53架构上，L1 cache分为单独的instruction cache（ICache）和data cache（DCache）。L1 cache是CPU私有的，每个CPU都有一个L1 cache。一个cluster 内的所有CPU共享一个L2 cache，L2 cache不区分指令和数据，都可以缓存。所有cluster之间共享L3 cache。L3 cache通过总线和主存相连。</p><h2 id="多级cache之间的配合工作">多级cache之间的配合工作</h2><p>首先引入两个名词概念，命中和缺失。 CPU要访问的数据在cache中有缓存，称为“命中” (hit)，反之则称为“缺失” (miss)。多级cache之间是如何配合工作的呢？我们假设现在考虑的系统只有两级cache。</p><figure><img src="https://pic2.zhimg.com/80/v2-4974c1f109f00f887fceda68b37bd3f5_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当CPU试图从某地址load数据时，首先从L1 cache中查询是否命中，如果命中则把数据返回给CPU。如果L1 cache缺失，则继续从L2 cache中查找。当L2 cache命中时，数据会返回给L1 cache以及CPU。如果L2 cache也缺失，很不幸，我们需要从主存中load数据，将数据返回给L2 cache、L1 cache及CPU。这种多级cache的工作方式称之为inclusive cache。某一地址的数据可能存在多级缓存中。与inclusive cache对应的是exclusive cache，这种cache保证某一地址的数据缓存只会存在于多级cache其中一级。也就是说，任意地址的数据不可能同时在L1和L2 cache中缓存。</p><h1 id="直接映射缓存direct-mapped-cache">直接映射缓存(Direct mapped cache)</h1><p>我们继续引入一些cache相关的名词。cache的大小称之为cahe size，代表cache可以缓存最大数据的大小。我们将cache平均分成相等的很多块，每一个块大小称之为cache line，其大小是cache line size。例如一个64 Bytes大小的cache。如果我们将64 Bytes平均分成64块，那么cache line就是1字节，总共64行cache line。如果我们将64 Bytes平均分成8块，那么cache line就是8字节，总共8行cache line。现在的硬件设计中，一般cache line的大小是4-128 Byts。为什么没有1 byte呢？原因我们后面讨论。</p><p>这里有一点需要注意，cache line是cache和主存之间数据传输的最小单位。什么意思呢？当CPU试图load一个字节数据的时候，如果cache缺失，那么cache控制器会从主存中一次性的load cache line大小的数据到cache中。例如，cache line大小是8字节。CPU即使读取一个byte，在cache缺失后，cache会从主存中load 8字节填充整个cache line。又是因为什么呢？后面说完就懂了。</p><p>我们假设下面的讲解都是针对64 Bytes大小的cache，并且cache line大小是8字节。我们可以类似把这块cache想想成一个数组，数组总共8个元素，每个元素大小是8字节。就像下图这样。</p><figure><img src="https://pic1.zhimg.com/80/v2-3e0de5f8b95e27dbd41328c9d089224c_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>现在我们考虑一个问题，CPU从0x0654地址读取一个字节，cache控制器是如何判断数据是否在cache中命中呢？cache大小相对于主存来说，可谓是小巫见大巫。所以cache肯定是只能缓存主存中极小一部分数据。我们如何根据地址在有限大小的cache中查找数据呢？现在硬件采取的做法是对地址进行散列（可以理解成地址取模操作）。我们接下来看看是如何做到的？</p><figure><img src="https://pic2.zhimg.com/80/v2-e8deb539258684ad9d4dffef08b02c09_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们一共有8行cache line，cache line大小是8 Bytes。所以我们可以利用地址低3 bits（如上图地址蓝色部分）用来寻址8 bytes中某一字节，我们称这部分bit组合为offset。同理，8行cache line，为了覆盖所有行。我们需要3 bits（如上图地址黄色部分）查找某一行，这部分地址部分称之为index。现在我们知道，如果两个不同的地址，其地址的bit3-bit5如果完全一样的话，那么这两个地址经过硬件散列之后都会找到同一个cache line。所以，当我们找到cache line之后，只代表我们访问的地址对应的数据可能存在这个cache line中，但是也有可能是其他地址对应的数据。所以，我们又引入tag array区域，tag array和data array一一对应。每一个cache line都对应唯一一个tag，tag中保存的是整个地址位宽去除index和offset使用的bit剩余部分（如上图地址绿色部分）。tag、index和offset三者组合就可以唯一确定一个地址了。因此，当我们根据地址中index位找到cache line后，取出当前cache line对应的tag，然后和地址中的tag进行比较，如果相等，这说明cache命中。如果不相等，说明当前cache line存储的是其他地址的数据，这就是cache缺失。在上述图中，我们看到tag的值是0x19，和地址中的tag部分相等，因此在本次访问会命中。由于tag的引入，因此解答了我们之前的一个疑问“为什么硬件cache line不做成一个字节？”。这样会导致硬件成本的上升，因为原本8个字节对应一个tag，现在需要8个tag，占用了很多内存。tag也是cache的一部分，但是我们谈到cache size的时候并不考虑tag占用的内存部分。</p><p>我们可以从图中看到tag旁边还有一个valid bit，这个bit用来表示cache line中数据是否有效（例如：1代表有效；0代表无效）。当系统刚启动时，cache中的数据都应该是无效的，因为还没有缓存任何数据。cache控制器可以根据valid bit确认当前cache line数据是否有效。所以，上述比较tag确认cache line是否命中之前还会检查valid bit是否有效。只有在有效的情况下，比较tag才有意义。如果无效，直接判定cache缺失。</p><p>上面的例子中，cache size是64 Bytes并且cache line size是8 bytes。offset、index和tag分别使用3 bits、3 bits和42 bits（假设地址宽度是48 bits）。我们现在再看一个例子：512 Bytes cache size，64 Bytes cache line size。根据之前的地址划分方法，offset、index和tag分别使用6 bits、3 bits和39 bits。如下图所示。</p><figure><img src="https://pic2.zhimg.com/80/v2-f6fdf760d314f146941e2192957f1a81_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="直接映射缓存的优缺点">直接映射缓存的优缺点</h2><p>直接映射缓存在硬件设计上会更加简单，因此成本上也会较低。根据直接映射缓存的工作方式，我们可以画出主存地址0x00-0x88地址对应的cache分布图。</p><figure><img src="https://pic2.zhimg.com/80/v2-b3d111caabc93c638bb08bde5026d711_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们可以看到，地址0x00-0x3f地址处对应的数据可以覆盖整个cache。0x40-0x7f地址的数据也同样是覆盖整个cache。我们现在思考一个问题，如果一个程序试图依次访问地址0x00、0x40、0x80，cache中的数据会发生什么呢？首先我们应该明白0x00、0x40、0x80地址中index部分是一样的。因此，这3个地址对应的cache line是同一个。所以，当我们访问0x00地址时，cache会缺失，然后数据会从主存中加载到cache中第0行cache line。当我们访问0x40地址时，依然索引到cache中第0行cache line，由于此时cache line中存储的是地址0x00地址对应的数据，所以此时依然会cache缺失。然后从主存中加载0x40地址数据到第一行cache line中。同理，继续访问0x80地址，依然会cache缺失。这就相当于每次访问数据都要从主存中读取，所以cache的存在并没有对性能有什么提升。访问0x40地址时，就会把0x00地址缓存的数据替换。这种现象叫做cache颠簸（cache thrashing）。针对这个问题，我们引入多路组相连缓存。我们首先研究下最简单的两路组相连缓存的工作原理。</p><h1 id="两路组相连缓存two-way-set-associative-cache">两路组相连缓存(Two-way set associative cache)</h1><p>我们依然假设64 Bytes cache size，cache line size是8 Bytes。什么是路（way）的概念。我们将cache平均分成多份，每一份就是一路。因此，两路组相连缓存就是将cache平均分成2份，每份32 Bytes。如下图所示。</p><figure><img src="https://pic1.zhimg.com/80/v2-4653656ec3d4d5942bae805df6723690_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>cache被分成2路，每路包含4行cache line。我们将所有索引一样的cache line组合在一起称之为组。例如，上图中一个组有两个cache line，总共4个组。我们依然假设从地址0x0654地址读取一个字节数据。由于cache line size是8 Bytes，因此offset需要3 bits，这和之前直接映射缓存一样。不一样的地方是index，在两路组相连缓存中，index只需要2 bits，因为一路只有4行cache line。上面的例子根据index找到第2行cache line（从0开始计算），第2行对应2个cache line，分别对应way 0和way 1。因此index也可以称作set index（组索引）。先根据index找到set，然后将组内的所有cache line对应的tag取出来和地址中的tag部分对比，如果其中一个相等就意味着命中。</p><p>因此，两路组相连缓存较直接映射缓存最大的差异就是：第一个地址对应的数据可以对应2个cache line，而直接映射缓存一个地址只对应一个cache line。那么这究竟有什么好处呢？</p><h2 id="两路组相连缓存优缺点">两路组相连缓存优缺点</h2><p>两路组相连缓存的硬件成本相对于直接映射缓存更高。因为其每次比较tag的时候需要比较多个cache line对应的tag（某些硬件可能还会做并行比较，增加比较速度，这就增加了硬件设计复杂度）。为什么我们还需要两路组相连缓存呢？因为其可以有助于降低cache颠簸可能性。那么是如何降低的呢？根据两路组相连缓存的工作方式，我们可以画出主存地址0x00-0x4f地址对应的cache分布图。</p><figure><img src="https://pic4.zhimg.com/80/v2-9db10cd5b86e5a10f08980ab1d1cfc07_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>我们依然考虑直接映射缓存一节的问题“如果一个程序试图依次访问地址0x00、0x40、0x80，cache中的数据会发生什么呢？”。现在0x00地址的数据可以被加载到way 1，0x40可以被加载到way 0。这样是不是就在一定程度上避免了直接映射缓存的尴尬境地呢？在两路组相连缓存的情况下，0x00和0x40地址的数据都缓存在cache中。试想一下，如果我们是4路组相连缓存，后面继续访问0x80，也可能被被缓存。</p><p>因此，当cache size一定的情况下，组相连缓存对性能的提升最差情况下也和直接映射缓存一样，在大部分情况下组相连缓存效果比直接映射缓存好。同时，其降低了cache颠簸的频率。从某种程度上来说，直接映射缓存是组相连缓存的一种特殊情况，每个组只有一个cache line而已。因此，直接映射缓存也可以称作单路组相连缓存。</p><h1 id="全相连缓存full-associative-cache">全相连缓存(Full associative cache)</h1><p>既然组相连缓存那么好，如果所有的cache line都在一个组内。岂不是性能更好。是的，这种缓存就是全相连缓存。我们依然以64 Byts大小cache为例说明。</p><figure><img src="https://pic3.zhimg.com/80/v2-1e61e8d13030ed4f0b42c2d1a854ffce_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由于所有的cache line都在一个组内，因此地址中不需要set index部分。因为，只有一个组让你选择，间接来说就是你没得选。我们根据地址中的tag部分和所有的cache line对应的tag进行比较（硬件上可能并行比较也可能串行比较）。哪个tag比较相等，就意味着命中某个cache line。因此，在全相连缓存中，任意地址的数据可以缓存在任意的cache line中。所以，这可以最大程度的降低cache颠簸的频率。但是硬件成本上也是更高。</p><h1 id="一个四路组相连缓存实例问题">一个四路组相连缓存实例问题</h1><p>考虑这么一个问题，32 KB大小4路组相连cache，cache line大小是32 Bytes。请思考以下2个问题：</p><ol type="1"><li>多少个组？</li><li>假设地址宽度是48 bits，index、offset以及tag分别占用几个bit？</li></ol><p>总共4路，因此每路大小是8 KB。cache line size是32 Bytes，因此一共有256组（8 KB / 32 Bytes）。由于cache line size是32 Bytes，所以offset需要5位。一共256组，所以index需要8位，剩下的就是tag部分，占用35位。这个cache可以绘制下图表示。</p><figure><img src="https://pic4.zhimg.com/80/v2-ad47fa00875dcca7ea3e58b828edaeef_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="cache分配策略cache-allocation-policy">Cache分配策略(Cache allocation policy)</h1><p>cache的分配策略是指我们什么情况下应该为数据分配cache line。cache分配策略分为读和写两种情况。</p><h2 id="读分配read-allocation">读分配(read allocation)</h2><p>当CPU读数据时，发生cache缺失，这种情况下都会分配一个cache line缓存从主存读取的数据。默认情况下，cache都支持读分配。</p><h2 id="写分配write-allocation">写分配(write allocation)</h2><p>当CPU写数据发生cache缺失时，才会考虑写分配策略。当我们不支持写分配的情况下，写指令只会更新主存数据，然后就结束了。当支持写分配的时候，我们首先从主存中加载数据到cache line中（相当于先做个读分配动作），然后会更新cache line中的数据。</p><h1 id="cache更新策略cache-update-policy">Cache更新策略(Cache update policy)</h1><p>cache更新策略是指当发生cache命中时，写操作应该如何更新数据。cache更新策略分成两种：写直通和回写。</p><h2 id="写直通write-through">写直通(write through)</h2><p>当CPU执行store指令并在cache命中时，我们更新cache中的数据并且更新主存中的数据。<strong>cache和主存的数据始终保持一致</strong>。</p><h2 id="写回write-back">写回(write back)</h2><p>当CPU执行store指令并在cache命中时，我们只更新cache中的数据。并且每个cache line中会有一个bit位记录数据是否被修改过，称之为dirty bit（翻翻前面的图片，cache line旁边有一个D就是dirty bit）。我们会将dirty bit置位。主存中的数据只会在cache line被替换或者显示的clean操作时更新。因此，主存中的数据可能是未修改的数据，而修改的数据躺在cache中。<strong>cache和主存的数据可能不一致。</strong></p><p>同时思考个问题，为什么cache line大小是cache控制器和主存之间数据传输的最小单位呢？这也是因为每个cache line只有一个dirty bit。这一个dirty bit代表着整个cache line是否被修改的状态。</p><h2 id="实例">实例</h2><p>假设我们有一个64 Bytes大小直接映射缓存，cache line大小是8 Bytes，采用写分配和写回机制。当CPU从地址0x2a读取一个字节，cache中的数据将会如何变化呢？假设当前cache状态如下图所示(tag旁边valid一栏的数字1代表合法。0代表非法。后面Dirty的1代表dirty，0代表没有写过数据，即非dirty)。</p><figure><img src="https://pic3.zhimg.com/80/v2-ff2a4d78af3ff8d411e092a96941fd6a_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>根据index找到对应的cache line，对应的tag部分valid bit是合法的，但是tag的值不相等，因此发生缺失。此时我们需要从地址0x28地址（请注意cacheline大小对齐）加载8字节数据到该cache line中。但是，我们发现当前cache line的dirty bit置位。因此，cache line里面的数据不能被简单的丢弃，由于采用写回机制，所以我们需要将cache中的数据0x11223344写到地址0x0128地址（这个地址根据tag中的值及所处的cache line行计算得到）。这个过程如下图所示。</p><figure><img src="https://pic3.zhimg.com/80/v2-1630dc6c3c099fdc1b92c8f33f1eea32_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当写回操作完成，我们将主存中0x28地址开始的8个字节加载到该cache line中，并清除dirty bit。然后根据offset找到0x52返回给CPU。</p><h1 id="问题解答">问题解答</h1><p>回到最初提到的问题。不知你是否已经明白其中的原因。我们下篇文章仔细展开该问题。</p><h2 id="问题背景">问题背景</h2><p>先贴出建议的代码片段1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>][<span class="hljs-number">128</span>];<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">128</span>; j++)<br>                arr[i][j] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>与之对比的代码片段2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">10</span>][<span class="hljs-number">128</span>];<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">128</span>; i++)<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>                arr[j][i] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>在有了cache的基础知识后，我们就可以简单的解答这个问题了。我们假设使用的L1 cache line大小是64字节，采用写分配及写回策略。继续假设数组<code>arr</code>内存首地址是64字节对齐。</p><h2 id="问题分析">问题分析</h2><p>在有了以上背景假设后，我们先分析下片段1导致的cache miss/hit情况。当执行<code>arr[0][0] = 1</code>时， cache控制器发现<code>arr[0][0]</code>的值不在cache中，此时发生一次cache miss。然后从主存中读取<code>arr[0][0]到arr[0][15]</code> 的内存值到cache中。当执行访问<code>arr[0][1] = 1</code> 时会发生一次cache hit。此时内存访问速度极快。接着继续往下执行，会一直cache hit。直到执行<code>arr[0][16] = 1</code>，此时会cache miss。总结来说就是访问内存每发生一次cache miss。接下来会发生15次cache hit。因此这种初始化方法<strong>cache命中率很高</strong>。</p><p>我们再来分析下片段2。当执行<code>arr[0][0] = 1</code>时， cache控制器发现<code>arr[0][0]</code>的值不在cache中，此时发生一次cache miss。然后从主存中读取<code>arr[0][0]</code>到<code>arr[0][15]</code> 的内存值到cache中。当执行访问<code>arr[1][0] = 1</code>时依然发生一次cache miss。一直执行到<code>arr[9][0] = 1</code>依然是一次cache miss。现在思考下，访问<code>arr[0][1]</code>会是怎么情况呢？ 此时就需要考虑cache的大小了。如果cache大小大于数组arr大小，cache此时相当于缓存了整个arr数组的内容。那么后续访问其他元素，确实是cache hit。似乎和片段1代码分析结果差不多。但是如果cache的大小很小，例如只有数组一半大小，那么cache命中率就很明显会降低。同样的cache大小，片段1的代码依然会获得很高的cache命中率。</p><h2 id="总结">总结</h2><p>在大多数情况下，片段1代码的性能比片段2好。因此我们倾向片段1代码的写法。</p><h1 id="cache组织方式">Cache组织方式</h1><p>我们这里一直避开了一个关键问题。我们都知道cache控制器根据地址查找缓存并判断是否命中cache，这里的地址究竟是虚拟地址(virtual address，VA)还是物理地址(physical address，PA)？可以前往下面的文章一探究竟。</p><p>但是，我们一直避开了一个关键问题。我们都知道cache控制器根据地址查找判断是否命中，这里的地址究竟是虚拟地址(virtual address，VA)还是物理地址(physical address，PA)？我们应该清楚CPU发出对某个地址的数据访问，这个地址其实是虚拟地址，虚拟地址经过MMU转换成物理地址，最终从这个物理地址读取数据。因此cache的硬件设计既可以采用虚拟地址也可以采用物理地址甚至是取两者地址部分组合作为查找cache的依据。</p><h2 id="虚拟高速缓存vivt">虚拟高速缓存(VIVT)</h2><p>我们首先介绍的是虚拟高速缓存，这种cache硬件设计简单。在cache诞生之初，大部分的处理器都使用这种方式。虚拟高速缓存以虚拟地址作为查找对象。如下图所示。</p><figure><img src="https://pic1.zhimg.com/80/v2-1a6af4b2fdf482c39f5f03e554b3a494_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>虚拟地址直接送到cache控制器，如果cache hit。直接从cache中返回数据给CPU。如果cache miss，则把虚拟地址发往MMU，经过MMU转换成物理地址，根据物理地址从主存(main memory)读取数据。由于我们根据虚拟地址查找高速缓存，所以我们是用虚拟地址中部分位域作为索引(index)，找到对应的的cacheline。然后根据虚拟地址中部分位域作为标记(tag)来判断cache是否命中。因此，我们针对这种index和tag都取自虚拟地址的高速缓存称为虚拟高速缓存，简称VIVT(Virtually Indexed Virtually Tagged)。另外，我们复习下cache控制器查找数据以及判断是否命中的规则：通过index查找对应的cacheline，通过tag判断是否命中cache。 虚拟高速缓存的优点是不需要每次读取或者写入操作的时候把虚拟地址经过MMU转换为物理地址，这在一定的程度上提升了访问cache的速度，毕竟MMU转换虚拟地址需要时间。同时硬件设计也更加简单。但是，正是使用了虚拟地址作为tag，所以引入很多软件使用上的问题。 操作系统在管理高速缓存正确工作的过程中，主要会面临两个问题。歧义(ambiguity)和别名(alias)。为了保证系统的正确工作，操作系统负责避免出现歧义和别名。</p><h3 id="歧义ambiguity">歧义(ambiguity)</h3><p>歧义是指不同的数据在cache中具有相同的tag和index。cache控制器判断是否命中cache的依据就是tag和index，因此这种情况下，cache控制器根本没办法区分不同的数据。这就产生了歧义。什么情况下发生歧义呢？我们知道不同的物理地址存储不同的数据，只要相同的虚拟地址映射不同的物理地址就会出现歧义。例如两个互不相干的进程，就可能出现相同的虚拟地址映射不同的物理地址。假设A进程虚拟地址0x4000映射物理地址0x2000。B进程虚拟地址0x4000映射物理地址0x3000。当A进程运行时，访问0x4000地址会将物理地址0x2000的数据加载到cacheline中。当A进程切换到B进程的时候，B进程访问0x4000会怎样？当然是会cache hit，此时B进程就访问了错误的数据，B进程本来想得到物理地址0x3000对应的数据，但是却由于cache hit得到了物理地址0x2000的数据。操作系统如何避免歧义的发生呢？当我们切换进程的时候，可以选择flush所有的cache。flush cache操作有两种： - 使主存储器有效。针对write back高速缓存，首先应该使主存储器有效，保证已经修改数据的cacheline写回主存储器，避免修改的数据丢失。 - 使高速缓存无效。保证切换后的进程不会错误的命中上一个进程的缓存数据。</p><p>因此，切换后的进程刚开始执行的时候，将会由于大量的cache miss导致性能损失。所以，VIVT高速缓存明显的缺点之一就是经常需要flush cache以保证歧义不会发生，最终导致性能的损失。VIVT高速缓存除了面对歧义问题外，还面临另一个问题：别名(alias)。</p><h3 id="别名alias">别名(alias)</h3><p>当不同的虚拟地址映射相同的物理地址，而这些虚拟地址的index不同，此时就发生了别名现象(多个虚拟地址被称为别名)。通俗点来说就是指同一个物理地址的数据被加载到不同的cacheline中就会出现别名现象。 考虑这样的一个例子。虚拟地址0x2000和0x4000都映射到相同的物理地址0x8000。这意味着进程既可以从0x2000读取数据，也能从地址0x4000读取数据。假设系统使用的是直接映射VIVT高速缓存，cache更新策略采用写回机制，并且使用虚拟地址的位&lt;15...4&gt;作为index。那么虚拟地址0x2000和虚拟地址0x4000的index分别是0x200和0x400。这意味同一个物理地址的数据会加载到不同的cacheline。假设物理地址0x8000存储的数据是0x1234。程序先访问0x2000把数据0x1234加载到第0x200(index)行cacheline中。接着访问0x4000，会将0x1234再一次的加载到第0x400(index)行cacheline中。现在程序将0x2000地址数据修改成0x5678。由于采用的是写回策略，因此修改的数据依然躺在cacheline中。当程序访问0x4000的时候由于cache hit导致读取到旧的数据0x1234。这就造成了数据不一致现象，这不是我们想要的结果。可以选择下面的方法避免这个问题。</p><figure><img src="https://pic3.zhimg.com/80/v2-c2a5303f950c195b800917f117b36f72_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>针对共享数据所在页的映射方式采用nocache映射。例如上面的例子中，0x2000和0x4000映射物理地址0x8000的时候都采用nocache的方式，这样不通过cache的访问，肯定可以避免这种问题。但是这样就损失了cache带来的性能好处。这种方法既适用于不同进程共享数据，也适用于同一个进程共享数据。 如果是不同进程之间共享数据，还可以在进程切换时主动flush cache(使主存储器有效和使高速缓存无效)的方式避免别名现象。但是，如果是同一个进程共享数据该怎么办？除了nocache映射之外，还可以有另一种解决方案。这种方法只针对直接映射高速缓存，并且使用了写分配机制有效。在建立共享数据映射时，保证每次分配的虚拟地址都索引到相同的cacheline。这种方式，后面还会重点说。</p><h2 id="物理高速缓存pipt">物理高速缓存(PIPT)</h2><p>基于对VIVT高速缓存的认识，我们知道VIVT高速缓存存在歧义和名别两大问题。主要问题原因是：tag取自虚拟地址导致歧义，index取自虚拟地址导致别名。所以，如果想让操作系统少操心，最简单的方法是tag和index都取自物理地址。物理的地址tag部分是独一无二的，因此肯定不会导致歧义。而针对同一个物理地址，index也是唯一的，因此加载到cache中也是唯一的cacheline，所以也不会存在别名。我们称这种cache为物理高速缓存，简称PIPT(Physically Indexed Physically Tagged)。PIPT工作原理如下图所示。</p><figure><img src="https://pic4.zhimg.com/80/v2-69fb9056736bae258ecfb10246fc1d77_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>CPU发出的虚拟地址经过MMU转换成物理地址，物理地址发往cache控制器查找确认是否命中cache。虽然PIPT方式在软件层面基本不需要维护，但是硬件设计上比VIVT复杂很多。因此硬件成本也更高。同时，由于虚拟地址每次都要翻译成物理地址，因此在查找性能上没有VIVT方式简洁高效，毕竟PIPT方式需要等待虚拟地址转换物理地址完成后才能去查找cache。顺便提一下，为了加快MMU翻译虚拟地址的速度，硬件上也会加入一块cache，作用是缓存虚拟地址和物理地址的映射关系，这块cache称之为TLB(Translation Lookaside Buffer)。当MMU需要转换虚拟地址时，首先从TLB中查找，如果cache hit，则直接返回物理地址。如果cache miss则需要MMU查找页表。这样就加快了虚拟地址转换物理地址的速度。如果系统采用的PIPT的cache，那么软件层面基本不需要任何的维护就可以避免歧义和别名问题。这是PIPT最大的优点。现在的CPU很多都是采用PIPT高速缓存设计。在Linux内核中，可以看到针对PIPT高速缓存的管理函数都是空函数，无需任何的管理。</p><h2 id="物理标记的虚拟高速缓存vipt">物理标记的虚拟高速缓存(VIPT)</h2><p>为了提升cache查找性能，我们不想等到虚拟地址转换物理地址完成后才能查找cache。因此，我们可以使用虚拟地址对应的index位查找cache，与此同时(硬件上同时进行)将虚拟地址发到MMU转换成物理地址。当MMU转换完成，同时cache控制器也查找完成，此时比较cacheline对应的tag和物理地址tag域，以此判断是否命中cache。我们称这种高速缓存为VIPT(Virtually Indexed Physically Tagged)。</p><figure><img src="https://pic4.zhimg.com/80/v2-12969d6792ebc4b5256e1822ffde6caf_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>VIPT以物理地址部分位作为tag，因此我们不会存在歧义问题。但是，采用虚拟地址作为index，所以可能依然存在别名问题。是否存在别名问题，需要考虑cache的结构，我们需要分情况考虑。</p><h3 id="vipt-cache为什么不存在歧义">VIPT Cache为什么不存在歧义</h3><p>在这里重点介绍下为什么VIPT Cache不存在歧义。假设以32位CPU为例，页表映射最小单位是4KB。我们假设虚拟地址&lt;12:4&gt;位(这是一个有别名问题的VIPT Cache)作为index，于此同时将虚拟地址&lt;31:12&gt;发送到MMU转换得到物理地址的&lt;31:12&gt;，这里<strong>我们把&lt;31:12&gt;作为tag，并不是&lt;31:13&gt;</strong>。这地方很关键，也就是说VIPT的tag取决于物理页大小的剩余位数，而不是去掉index和offset的剩余位数。物理tag是惟一的，所以不存在歧义。</p><h3 id="vipt-cache什么情况不存在别名">VIPT Cache什么情况不存在别名</h3><p>我们知道VIPT的优点是查找cache和MMU转换虚拟地址同时进行，所以性能上有所提升。歧义问题虽然不存在了，但是别名问题依旧可能存在，那么什么情况下别名问题不会存在呢？Linux系统中映射最小的单位是页，一页大小是4KB。那么意味着虚拟地址和其映射的物理地址的位&lt;11...0&gt;是一样的。针对直接映射高速缓存，如果cache的size小于等于4KB，是否就意味着无论使用虚拟地址还是物理地址的低位查找cache结果都是一样呢？是的，因为虚拟地址和物理地址对应的index是一样的。这种情况，VIPT实际上相当于PIPT，软件维护上和PIPT一样。如果示例是一个四路组相连高速缓存呢？只要满足一路的cache的大小小于等于4KB，那么也不会出现别名问题。</p><h3 id="vipt-cache的别名问题">VIPT Cache的别名问题</h3><p>假设系统使用的是直接映射高速缓存，cache大小是8KB，cacheline大小是256字节。这种情况下的VIPT就存在别名问题。因为index来自虚拟地址位&lt;12...8&gt;，虚拟地址和物理地址的位&lt;11...8&gt;是一样的，但是bit12却不一定相等。 假设虚拟地址0x0000和虚拟地址0x1000都映射相同的物理地址0x4000。那么程序读取0x0000时，系统将会从物理地址0x4000的数据加载到第0x00行cacheline。然后程序读取0x1000数据，再次把物理地址0x4000的数据加载到第0x10行cacheline。这不，别名出现了。相同物理地址的数据被加载到不同cacheline中。</p><h3 id="如何解决vipt-cache别名问题">如何解决VIPT Cache别名问题</h3><p>我们接着上面的例子说明。首先出现问题的场景是共享映射，也就是多个虚拟地址映射同一个物理地址才可能出现问题。我们需要想办法避免相同的物理地址数据加载到不同的cacheline中。如何做到呢？那我们就避免上个例子中0x1000映射0x4000的情况发生。我们可以将虚拟地址0x2000映射到物理地址0x4000，而不是用虚拟地址0x1000。0x2000对应第0x00行cacheline，这样就避免了别名现象出现。因此，在建立共享映射的时候，返回的虚拟地址都是按照cache大小对齐的地址，这样就没问题了。如果是多路组相连高速缓存的话，返回的虚拟地址必须是满足一路cache大小对齐。在Linux的实现中，就是通过这种方法解决别名问题。</p><h2 id="不存在的pivt高速缓存">不存在的PIVT高速缓存</h2><p>按照排列组合来说，应该还存在一种PIVT方式的高速缓存。因为PIVT没有任何优点，却包含以上的所有缺点。你想想，PIVT方式首先要通过MMU转换成物理地址，然后才能根据物理地址index域查找cache。这在速度上没有任何优势，而且还存在歧义和别名问题。请忘记它吧。不，应该不算是忘记，因为它从来就没出现过。</p><h2 id="总结-1">总结</h2><p>VIVT Cache问题太多，软件维护成本过高，是最难管理的高速缓存。所以现在基本只存在历史的文章中。现在我们基本看不到硬件还在使用这种方式的cache。现在使用的方式是PIPT或者VIPT。如果多路组相连高速缓存的一路的大小小于等于4KB，一般硬件采用VIPT方式，因为这样相当于PIPT，岂不美哉。当然，如果一路大小大于4KB，一般采用PIPT方式，也不排除VIPT方式，这就需要操作系统多操点心了。</p><h1 id="note">Note</h1><ul><li>tag array 存储在硬件 cache 里，占用真实 cache 内存。但是我们提到 cache size 的时候，并没有考虑 tag 的占用。所以计算时，请忽略 tag 占用。</li></ul><blockquote><p>摘录自：<a href="https://zhuanlan.zhihu.com/p/107096130">https://zhuanlan.zhihu.com/p/107096130</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Architecture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何阅读 Java 字节码（Byte Code）</title>
    <link href="/2022/09/14/Java-Byte-Code/"/>
    <url>/2022/09/14/Java-Byte-Code/</url>
    
    <content type="html"><![CDATA[<h1 id="字节码byte-code">字节码（Byte Code）</h1><p>学习 Java 的都知道，我们所编写的 <code>.java</code> 代码文件通过编译将会生成 <code>.class</code> 文件，最初的方式就是通过 JDK 的 <code>javac</code> 指令来编译，再通过 <code>java</code> 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。</p><p>对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。</p><h1 id="字节码文件结构">字节码文件结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> add(a, b);<br>        System.out.println(c);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们先编写一个简单的 Java 代码作为演示例子，然后编译这个 Hello.java 文件得到 Hello.class 文件。我们知道 .class 是二进制文件，它无法被直接查看，当然我们可以通过一些二进制文件查看工具来阅读里面的内容。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8dea7c42a8e491098dfce263479c38d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="（在 Visual Studio Code 里使用 hexdump for VSCode 插件查看到的内容）" /><figcaption aria-hidden="true">（在 Visual Studio Code 里使用 hexdump for VSCode 插件查看到的内容）</figcaption></figure><p>一个符合标准的 <code>.class</code> 文件是以 <code>CA FE BA BE</code> 开头，这个四个字节均为魔数，JVM 根据这个开头来判断一个文件是否可能为 <code>.class</code> 文件，如果是才会继续执行。</p><p>魔数后面四个字节 <code>00 00 00 34</code> 是版本号，前两个字节为次版本号，后两个字节为主版本号，在对主版本号进行转换可以得到 52，该序号对应的 Java 版本为 1.8。</p><p>如果需要查阅最新的 Java 版本对应的版本号，可以在官方查看 Java SE 最新版本的文档</p><blockquote><p>Oracle Java SE Specifications：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Findex.html">docs.oracle.com/javase/spec…</a></p></blockquote><p>在版本号后面则是常量池，它包含常量池计数器（constant_pool_count）和常量池数据区两个部分。前面两个字节 00 28 是计数器，用于表示常量池的容量计数值，代表常量池数据区有 <code>constant_pool_count - 1</code> 个常量。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/662392269d41446ea26919114d18ae33~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="常量池结构" /><figcaption aria-hidden="true">常量池结构</figcaption></figure><p>在常量池后面还有访问标志，很显然这个文件对于我们来说阅读起来并不方便，但是我们可以转换为助记符来帮助我们阅读。</p><h2 id="使用-javap-命令">使用 javap 命令</h2><p>当我们拥有一个 <code>.class</code> 文件时，我们可以通过 <code>javap</code> 来将字节码指令转换为助记符，这个命令有一些参数，你可以通过 <code>javap -help</code> 来查看所有参数的说明，这里为了显示尽量详细的内容，使用 <code>javap -verbose Hello</code>，其效果如下，但由于内容太长，我们不一次性展示所有内容，而是分区域来进行阅读。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Classfile /F:/project/java/JavaMain/<span class="hljs-keyword">out</span>/production/JavaMain/Hello.<span class="hljs-keyword">class</span><br>  Last modified <span class="hljs-number">2021</span><span class="hljs-number">-3</span><span class="hljs-number">-26</span>; size <span class="hljs-number">645</span> bytes<br>  MD5 checksum ca1b2193159aece89c05c7f9d3b54c7b<br>  Compiled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;Hello.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span><br>  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0<br>  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52<br>  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span><br></code></pre></td></tr></table></figure><p>最开始几行是关于这个文件的基本信息，之后是类的信息，我们的关注点从类这里开始。</p><p>在类里面，它包含了主版本号（major version），次版本号（minor version），访问标志（flags）。</p><p>对于版本号，和我们上面所讲的一样，因此这里不再重复。而 flags 是关于这个类的相关修饰符，根据官方文档，它可能拥有的值如下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed8c7325c495469da2d0b0e382ab1903~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="常量池">常量池</h2><p>在类信息的下面，则是常量池，它类似一个表，每个常量由编号、类型、值，这 3 个部分组成。我们列出一小部分来了解它的结构。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Constant</span> <span class="hljs-selector-tag">pool</span>:<br>   <span class="hljs-selector-id">#1</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#6</span>.<span class="hljs-selector-id">#26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-selector-id">#2</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#5</span>.<span class="hljs-selector-id">#27</span>         <span class="hljs-comment">// Hello.add:(II)I</span><br>   <span class="hljs-selector-id">#3</span> = <span class="hljs-selector-tag">Fieldref</span>           <span class="hljs-selector-id">#28</span>.<span class="hljs-selector-id">#29</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   <span class="hljs-selector-id">#4</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#30</span>.<span class="hljs-selector-id">#31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   <span class="hljs-selector-id">#5</span> = <span class="hljs-selector-tag">Class</span>              <span class="hljs-selector-id">#32</span>            <span class="hljs-comment">// Hello</span><br>   <span class="hljs-selector-id">#6</span> = <span class="hljs-selector-tag">Class</span>              <span class="hljs-selector-id">#33</span>            <span class="hljs-comment">// java/lang/Object</span><br>   <span class="hljs-selector-id">#7</span> = <span class="hljs-selector-tag">Utf8</span>               &lt;<span class="hljs-selector-tag">init</span>&gt;<br>   <span class="hljs-selector-id">#8</span> = <span class="hljs-selector-tag">Utf8</span>               ()<span class="hljs-selector-tag">V</span><br>   <span class="hljs-selector-id">#9</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">Code</span><br>  <span class="hljs-selector-id">#10</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">LineNumberTable</span><br>  <span class="hljs-selector-id">#11</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">LocalVariableTable</span><br>  <span class="hljs-selector-id">#12</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">this</span><br>  <span class="hljs-selector-id">#13</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">LHello</span>;<br>  <span class="hljs-selector-id">#14</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">main</span><br>  <span class="hljs-selector-id">#15</span> = <span class="hljs-selector-tag">Utf8</span>               ([Ljava/lang/String;)<span class="hljs-selector-tag">V</span><br></code></pre></td></tr></table></figure><p>在这里列出了前 15 个常量，每个常量都有一个编号，编号以符号 <code>#</code> 开头，编号后面是 <code>=</code> 加上该常量的类型，具体类型说明请参考官方 jvms 文档的 The Constant Pool 的解释。这里我们从中挑选几个常量来进行说明。</p><p>由于我们使用的命令是 <code>javap -verbose</code> 因此它会给我们加上一些注释说明，我们可以看到 <code>#2</code> 常量后面的注释是 <code>Hello.add:(II)I</code>，那么我们可以猜测它应该是我们代码中所编写的 <code>add()</code> 方法，由于这个方法是静态，因此它被加入到这个类中的常量区。那么这个常量的值呢？</p><p>对于 Methodref 类型，它的值是该方法的名称，对于一个方法而言，它的名称是一个字符串，因此构成方法名称的字符串也会被添加到常量池中，<code>#2</code> 这个方法，它的名称引用了常量池中其它的两个常量，也就是 <code>#5</code> 和 <code>#27</code>，而这两个常量以及与它们相关的其它常量在常量池中的值如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"> <span class="hljs-selector-id">#2</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#5</span>.<span class="hljs-selector-id">#27</span>         <span class="hljs-comment">// Hello.add:(II)I</span><br> <span class="hljs-selector-id">#5</span> = <span class="hljs-selector-tag">Class</span>              <span class="hljs-selector-id">#32</span>            <span class="hljs-comment">// Hello</span><br><span class="hljs-selector-id">#22</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">add</span><br><span class="hljs-selector-id">#23</span> = <span class="hljs-selector-tag">Utf8</span>               (II)<span class="hljs-selector-tag">I</span><br><span class="hljs-selector-id">#27</span> = <span class="hljs-selector-tag">NameAndType</span>        <span class="hljs-selector-id">#22</span>:<span class="hljs-selector-id">#23</span>        <span class="hljs-comment">// add:(II)I</span><br><span class="hljs-selector-id">#32</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">Hello</span><br></code></pre></td></tr></table></figure><p>在常量池中我们可以看到，<code>#5</code> 是一个类，它的值和方法一样都是名称，因此它引用了常量 #32，对于 <code>Utf8</code> 类型的常量，其值则是一个字符串，也就是常量 <code>#32</code> 的值就是字符串 <em>Hello</em>。因此 <code>#5</code> 的值就是 <em>Hello</em>。同样的 <code>#27</code> 的值是 <code>add:(II)I</code>，将它们组合起来 <code>#2</code> 的值就是 <code>Hello.add:(II)I</code> 了。</p><h2 id="包含的方法">包含的方法</h2><p>与 Java 代码一样，我们所定义的方法在类里面，而在字节码中我们定义在类中的方法也放在大括号里面，而这个大括号就在常量池下方。</p><p>对于每个方法，都包含首行的声明，以及紧接在后面的 descriptor（描述符号），flags（访问标识），Code（代码），我们把 Code 部分的内容先省略，先看一下类中所拥有的所有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hello</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br>    descriptor: (II)I<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们并没有给类写构造方法，但这里却生成了 <code>public Hello();</code>，这也说明了为什么我们在 Java 中不给类写构造方法，默认会有一个无参的构造方法。</p><p>另外我们可以看到到 <code>add(int, int)</code> 方法的 descriptor 为 <code>(II)I</code>，这与我们上面观察常量池时 <code>Hello.add:(II)I</code> 冒号后面带的字符是一样的，这其实是这个方法的参数以及返回值的缩写。当我们在 Java 中编写重载方法时，由于方法名一样，JVM 可以通过 descriptor 来区分所调用的方法是哪一个。</p><p>而 flags 与 Class 的 flags 类似，用于声明方法所拥有的修饰符。而最后的 Code 中包含的则是该方法的代码所执行的指令。</p><h2 id="code-的结构">Code 的结构</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">([Ljava/lang/String;)V</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_STATIC</span><br>  <span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=4,</span> <span class="hljs-string">args_size=1</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">iconst_1</span><br>       <span class="hljs-attr">1:</span> <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">2:</span> <span class="hljs-string">iconst_1</span><br>       <span class="hljs-attr">3:</span> <span class="hljs-string">istore_2</span><br>       <span class="hljs-attr">4:</span> <span class="hljs-string">iload_1</span><br>       <span class="hljs-attr">5:</span> <span class="hljs-string">iload_2</span><br>       <span class="hljs-attr">6:</span> <span class="hljs-string">invokestatic</span>  <span class="hljs-comment">#2                  // Method add:(II)I</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">istore_3</span><br>      <span class="hljs-attr">10:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-attr">13:</span> <span class="hljs-string">iload_3</span><br>      <span class="hljs-attr">14:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#4                  // Method java/io/PrintStream.println:(I)V</span><br>      <span class="hljs-attr">17:</span> <span class="hljs-string">return</span><br>    <span class="hljs-attr">LineNumberTable:</span><br>      <span class="hljs-attr">line 3:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">line 4:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">line 5:</span> <span class="hljs-number">4</span><br>      <span class="hljs-attr">line 6:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">line 7:</span> <span class="hljs-number">17</span><br>    <span class="hljs-attr">LocalVariableTable:</span><br>      <span class="hljs-string">Start</span>  <span class="hljs-string">Length</span>  <span class="hljs-string">Slot</span>  <span class="hljs-string">Name</span>   <span class="hljs-string">Signature</span><br>          <span class="hljs-number">0</span>      <span class="hljs-number">18</span>     <span class="hljs-number">0</span>  <span class="hljs-string">args</span>   [<span class="hljs-string">Ljava/lang/String;</span><br>          <span class="hljs-number">2</span>      <span class="hljs-number">16</span>     <span class="hljs-number">1</span>     <span class="hljs-string">a</span>   <span class="hljs-string">I</span><br>          <span class="hljs-number">4</span>      <span class="hljs-number">14</span>     <span class="hljs-number">2</span>     <span class="hljs-string">b</span>   <span class="hljs-string">I</span><br>         <span class="hljs-number">10</span>       <span class="hljs-number">8</span>     <span class="hljs-number">3</span>     <span class="hljs-string">c</span>   <span class="hljs-string">I</span><br></code></pre></td></tr></table></figure><p>以 main 方法为例子，在 Code 中可以分为 3 个部分，第一个部分是代码的指令表，该部分第一行是该方法的指令以及执行过程的相关信息，这一行信息包括：</p><ul><li>args_size 是参数数量，在主函数中，因为有 args 这个参数，所以在这里 args_size 为 1；</li><li>locals 是该方法中的本地变量有多少个，在我们的主函数里面有定义了 3 个变量，加上一个参数，因此有 4 个变量；</li><li>stack 是方法在执行过程中，操作数栈中最大深度，这个在之后讲解指令执行过程时可以看出。</li></ul><p>在这一行信息之后是字节码指令，一条指令包括偏移量以及执行的指令码，PC Register 利用偏移量来判断指令执行位置。</p><p>第二部分是 LineNumberTable，它是一个代码行对照表，用于标识我们 Java 代码中对应的行数的代码在 Code 中从哪个位置开始。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">LineNumberTable:</span><br>  <span class="hljs-attr">line 3:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">line 4:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">line 5:</span> <span class="hljs-number">4</span><br>  <span class="hljs-attr">line 6:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">line 7:</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p><code>line 3: 0</code> 代表 Java 源码文件中的第三行代码从偏移量为 0 的位置开始，而继续往下看可以看到第四行代码从偏移量为 2 的位置开始，也就是说第三行代码所对应的字节码指令有 <code>iconst_1</code> 和 <code>istore_1</code> 两条。这也可以让 JVM 执行指令出现错误时，帮助我们定位到对应的源码位置。</p><p>第三部分为 LocalVariableTable，调试器可以使用它在方法执行的过程中确定局部变量的值，它是一个可选的属性，在程序执行的时候并不需要它。</p><ul><li>第一个属性 start 为这个变量可见的起始偏移位置，它的值必须是在 Code 中存在的偏移量值。</li><li>第二个属性 length 为该变量的有效长度，在这个例子中，我们的变量直到方法末尾都有效，因此你会发现 <code>start + lenth</code> 的值都是 18 （方法中执行的指令数）。当我们在一个局部的代码块里面声明一个变量，那么它的有效期长度将会更短。</li><li>Slot 为变量在 local variable 中的位置，这可以帮助我们在指令中确定对应的变量，而 Name 则是变量名，Signature 为该变量的类型。</li></ul><p>当我们初步了解了 Code 属性的格式后，我们就可以对其中的指令执行进行分析了，但在此之前，我们需要先有一点 JVM 内存布局的基础知识，这对于我们之后了解指令的执行过程非常重要。</p><h1 id="jvm-内存结构">JVM 内存结构</h1><p>我们的 Java 程序在运行时是通过 <code>main()</code> 方法启动，它是程序的入口，我们的进程在启动时会为该方法创建一个主线程来执行代码。当我们使用多线程时，那么程序的进程将会拥有多个线程。每个线程的资源都拥有独自的资源，当然它们也可以共享进程的资源，那么在 JVM 中，根据资源的可用范围，可将内存区域分为线程独占和线程共享两个类别。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592d930aadd94e0a947fb844f97b8727~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="JVM内存布局" /><figcaption aria-hidden="true">JVM内存布局</figcaption></figure><p>对于每一个线程，都可将其拥有的内存空间分为 PC Register、Native Method Stack、JVM Stack 这 3 个区域，这 3 个区域对于线程来说都是独占的，其它线程无法进行访问。</p><ul><li><strong>PC Register</strong> 用于记录当前线程指令的执行位置。由于一个进程可能有多个线程，而 CPU 会在不同线程之间切换，为了能够记录各个线程的当前执行的指令，每个线程都需要有一个 PC Register，来保证各个线程都可以进行独立运算。</li><li><strong>JVM Stack</strong> 用于存放调用方法时压入栈的栈帧。相信学过数据结构的对栈应该不陌生，JVM Stack 压入的单位为栈帧（Frame），用于存储数据、动态链接、方法返回值和调度异常等。每次调用一个方法都会创建一个新的栈帧压入 JVM Stack 来存储该方法的信息，当该方法调用完成时，对应的栈帧也会跟着被销毁。一个栈帧都有自己的局部变量数组、操作数栈、对当前方法类的运行常量池的引用。</li><li><strong>Native Method Stack</strong> 则是用于调用操作系统本地方法时使用的栈空间。</li></ul><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55b35eb303f476c960a3d375a3a3965~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="JVM Stack 结构" /><figcaption aria-hidden="true">JVM Stack 结构</figcaption></figure><p>每个线程都可用访问的内存空间为线程共享区域，它包含 Head 和 Method Area 两个部分，Head 用于存放实例对象，也是 GC 回收的主要区域，而 Method Area 用于存放类结构与静态变量。</p><p>现在我们初步了解了 JVM 内存的布局，那么接下来可以继续看指令的执行过程了。</p><h1 id="指令的执行过程">指令的执行过程</h1><p>由于 Java 程序从 <code>main()</code> 方法开始，我们也是从这个方法的指令开始进行分析。</p><p>假设程序运行 0 号指令前的状态如下，在 mian 方法栈帧里面，有着 operand stack（操作数栈），它的最大长度为 2（与 Code 下的 stack 的值一致），此外还有一个 local variable（本地变量表）来存放变量的值，其中下标为 0 的变量为主方法的参数 args，我们直接用这个字符串填充在那里来做一个标识（实际的值可能是一个空数组）。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56b46e0ada1147858d65b84bfa68c071~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>接下来我们一步步执行方法中的指令，在这里我们先对出现的几个指令做一个简单的介绍：</p><ul><li><code>iconst_&lt;i&gt;</code> 放一个 int 常量（-1, 0, 1, 2, 3, 4 or 5) 到 operand stack 中</li><li><code>istore_&lt;n&gt;</code> 从 operand stack 中获取一个 int 到 local variable 的 n 中</li><li><code>iload_&lt;n&gt;</code> 从 local variable 中读取 int 变量 n 的值到操作数栈中</li><li><code>invokestatic</code> 调用一个 class 的 static 方法</li><li><code>getstatic</code> 从 class 中获取一个 static 字段</li><li><code>invokevirtual</code> 调用一个实例方法，基于类的调度</li><li><code>return</code> 从方法中返回一个 void，<code>ireturn</code> 从方法中返回 operand stack 栈顶的 int</li></ul><p><em>更多的指令与详细的说明请查看文章最后参考中的官方指令文档</em></p><p>现在我们开始分析指令的执行，我们在上面知道了，我们的 Java 代码所对应的指令分别是偏移量为 0 和 1 的两个，最开始执行的是 <code>0: iconst_1</code>，该指令会把 int 常量 1 放置到 operand stack 中，之后执行的是 <code>1: istore_1</code>，把 operand stack 栈顶的 int 常量取出放到 local variable 下标为 1 的变量中，该过程图示如下。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0716730b1a0e4897a8f345f11df12cc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="iconst_1 与 istore_1 的执行过程" /><figcaption aria-hidden="true">iconst_1 与 istore_1 的执行过程</figcaption></figure><p>我们可以通过查看 LocalVariableTable 得知下标为 1 的变量在我们的 Java 程序中是 int 变量 a，因此上面这两条指令常量 1 赋值给变量 a。同样的，后面两条指令则是将常量 1 赋值给变量 b。这里要注意，操作数栈的数是被取出操作，被取出的数将不会继续在 operand stack 里面。</p><p>执行完 0~3 这 4 条指令后，就来到了本例中最为关键的方法调用了。在执行 <code>iload_1</code> 和 <code>iload_2</code> 后，operand stack 中将会存放着变量 a 和 b 的值，作为 <code>invokestatic</code> 调用函数时传入的参数。</p><p>而执行到 <code>invokestatic #2</code> 这个指令的时候，该指令为调用一个 class 的 static 方法，也就是调用常量池中 <code>#2</code> 的方法，该方法为 <code>Hello.add:(II)I</code>。</p><p>当执行 invokestatic 时会依次读取 operand stack 的数据作为方法的参数，并创建一个新的栈帧来执行方法，将数据放到 local variable 对应变量位置。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59adc8ee20d0400f807836a7a52e6249~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>之后开始执行 <code>add()</code> 方法中的指令，首先执行的是两个 <code>iload</code> 指令，将 loca variable 对应下标的变量的值放到 operand stack 中，之后执行 <code>iadd</code> 取出 operand stack 中的值并进行加法运算，再把结果放到，最后执行 ireturn 取出 operand stack 顶部的 int 值进行返回。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8bcf3779bc3430ba736dd17b0e29f5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="执行了两个 iload 指令" /><figcaption aria-hidden="true">执行了两个 iload 指令</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5dd7d4698594e98bea8b4f1f7949400~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="执行 iadd 指令" /><figcaption aria-hidden="true">执行 iadd 指令</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bee9441a876f419aa1a006cc7d20f3c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="ireturn 取出栈顶的 int 常量作为方法的返回值" /><figcaption aria-hidden="true">ireturn 取出栈顶的 int 常量作为方法的返回值</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e753288ac6e4a1ebc18e9f18a684b7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="执行 istore_3" /><figcaption aria-hidden="true">执行 istore_3</figcaption></figure><p>当执行完 <code>ireturn</code> 后，add 方法也就执行完成了，对应的栈帧也会跟着销毁。之后回到 main 方法中继续往下执行，到 <code>istore_3</code> 指令，该指令将栈顶的 int 值取出放到了 local variable 中 Solt 为 3 的地方，这样执行完 4~9 这几条指令后就完成了我们代码中的 <code>int c = add(a, b);</code> 这一行代码。那么接下来就是执行 <code>System.out.println(c);</code> 对应的指令将 2 打印到控制台了。</p><p>到这里其实我们就已经知道如何去阅读我们代码生成的 Byte Code 了，这里我就不继续往下分析本文例子的代码了，阅读过程中如果遇到了没见过的指令，我们可以在 Oracle 官方指令文档里面查阅对应的说明。</p><p>那可能有人会觉得，如果每次查看一个类都需要去 command line 执行 <code>javap</code> 来查看对应的助记符，这样非常麻烦呀。那么接下来我们讲一下如何在 IntelliJ IDEA 里面直接阅读 Byte Code。</p><h1 id="在-intellij-idea-阅读">在 IntelliJ IDEA 阅读</h1><p>如果你希望在 IntelliJ IDEA 里阅读 Byte Code，那么可以按照 <strong>Bytecode Viewer</strong> 这一个插件，只需要在 Plugins 里面查找就能找到。</p><p>安装完这个插件，在顶部菜单栏的 View 中将会多出一个 Show Bytecode 按钮选项，我们可以在对应的 <code>.java</code> 文件中点击 View -&gt; Show Bytecode，展示出该文件的 Byte Code。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b63f89e92e44356aecaa751ba26bcb6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="View -&gt; Show Bytecode" /><figcaption aria-hidden="true">View -&gt; Show Bytecode</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ff2c64b7ce24747a709434ccd0260f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在这里所展示的 Byte Code 格式与我们上面使用 <code>javap</code> 显示出来的不一样。首先在这里我们看不到常量池，因此在指令里也不会用引用的方式来表示常量池的内容。</p><p>在这里它会将每一行 Java 代码的指令都区分开。例如 main 方法中的第一行指令对应的就是 L0 那一块，第一行的 LINENUMBER 对应上面 <code>javap</code> 中的 LineNumberTable，直接在这里描述当前 L0 这一块的指令对应的代码在文件中的位置。也因此我们不会在生成的这个 Byte Code 里面看到 LineNumberTable，因为它直接分布在各个指令块中了。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485654e735254ab7aef5432bd118a604~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="main 方法中的 L5" /><figcaption aria-hidden="true">main 方法中的 L5</figcaption></figure><p>在方法的最后，会多出一块内容来描述方法的信息，在这里会将 LocalVariableTable 里的变量都列出来，但格式与 javap 的 LocalVariableTable 中的描述格式不一样，每一行 LOCALVARIABLE 代表一个变量，描述格式从左到右依次为变量名、类型、开始可见时的指令块、最后有效的位置、Solt。除了描述方法中出现的变量外，操作数栈最大深度和本地变量个数也在放在这里。</p><p>由于该插件主要是为了阅读 Byte Code 中的指令，因此是以一种更加方便阅读指令的方式展示 Byte Code，例如对指令根据源码做分块，并把对应代码行数放在指令块的第一行，这样我们就不需要去对照 LineNumberTable 寻找当前指令的代码所在的位置了，反过来由于进行了分块查询对应代码的指令也很方便。但这个插件显示的内容也少了很多东西，如果需要查看初始常量池的内容，那就需要使用 <code>javap</code> 了。</p><h1 id="参考">参考</h1><ul><li>字节码增强技术探索：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F09%2F05%2Fjava-bytecode-enhancement.html">tech.meituan.com/2019/09/05/…</a></li><li>一文看懂 JVM 内存布局及 GC 原理：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2F3wyretkqrhivtw4frmr3">www.infoq.cn/article/3wy…</a></li><li>Oracle 官方说明文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse16%2Fhtml%2Fjvms-4.html%23jvms-4.10">docs.oracle.com/javase/spec…</a></li><li>Oracle 官方指令文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse16%2Fhtml%2Fjvms-6.html">docs.oracle.com/javase/spec…</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot接收前端传来的json数据</title>
    <link href="/2022/09/06/SpringBoot%E6%8E%A5%E6%94%B6%E5%89%8D%E7%AB%AF%E4%BC%A0%E6%9D%A5%E7%9A%84json%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/09/06/SpringBoot%E6%8E%A5%E6%94%B6%E5%89%8D%E7%AB%AF%E4%BC%A0%E6%9D%A5%E7%9A%84json%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<p>当前端传来json数据时，后端有多种方式接收 前端json数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>id<span class="hljs-punctuation">:</span><span class="hljs-number">121</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">//数字</span><br>name<span class="hljs-punctuation">:</span><span class="hljs-string">&quot;lhj&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">//字符串</span><br>scoreList<span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span>     <span class="hljs-comment">//对象</span><br><span class="hljs-punctuation">&#123;</span>Java<span class="hljs-punctuation">:</span><span class="hljs-number">95</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>  <br><span class="hljs-punctuation">&#123;</span>Python<span class="hljs-punctuation">:</span><span class="hljs-number">98</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span>C++<span class="hljs-punctuation">:</span><span class="hljs-number">94</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="一使用pojo">一、使用POJO</h1><p>若前端传递过来的数据刚好和我们的bean实体对象属性一致，则可以使用对象的形式接收。</p><p>后端实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Score</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> List&lt;ScoreList&gt; scoreList;<br>&#125;<br></code></pre></td></tr></table></figure><p>后端Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/student/score&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Score score)</span>&#123;<br>System.out.println(score);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>前端数据和bean对象属性要一致</li><li>必须使用<code>@RequestBody</code>注解</li></ul><h1 id="二使用map接收">二、使用Map接收</h1><p>后台Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/lhj/getdata&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map&lt;String,Object&gt;map)</span>&#123;<br>System.out.println(map);<br>&#125;<br></code></pre></td></tr></table></figure><p>前端传来的是一个json对象时：{【id，name】},可以用Map来获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/update&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateAttr</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Map&lt;String, String&gt; map)</span> &#123;<br>    <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">&quot;id&quot;</span>)&#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> Integer.parseInt(map.get(<span class="hljs-string">&quot;id&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">if</span>(map.containsKey(<span class="hljs-string">&quot;name&quot;</span>)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">objname</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-string">&quot;name&quot;</span>).toString();<br>    &#125;<br>    <span class="hljs-comment">// 操作 ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>Map&lt;String,Object&gt;</code>，值的类型建议设置为Object，这样可以使Map能接收各种类型的数据，如字符串、数字、数组和对象等。</p><h1 id="三以requestparam接收">三、以RequestParam接收</h1><p><strong>前端传来的是json数据不多时</strong>：[id:id],可以直接用<code>@RequestParam</code>来获取值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/update&quot;)</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateAttr</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> (<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-type">int</span> id) &#123;<br>    <span class="hljs-type">int</span> res=xxService.deleteData(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四以list接收">四、以List接收</h1><p><strong>当前端传来这样一个json数组：<code>[&#123;id,name&#125;,&#123;id,name&#125;,&#123;id,name&#125;,…]</code>时，用List接收</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/update&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">updateAttr</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;Accomodation&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span>(Accomodation accomodation:list)&#123;<br>        System.out.println(accomodation.toString());<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五以jsonobject形式接收">五、以JSONobject形式接收</h1><p>此接收匹配所有的类型，需要前后台传参数对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-meta">@PostMapping(&quot;/info&quot;)</span><br><span class="hljs-keyword">public</span> JSONObject <span class="hljs-title function_">merchantForInfo</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> JSONObject jsonObject)</span> &#123;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> jsonObject.getInteger(<span class="hljs-string">&quot;type&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">bankname</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;bankname&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">bankcard</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;bankcard&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">idno</span> <span class="hljs-operator">=</span> jsonObject.getString(<span class="hljs-string">&quot;idno&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Json字符串属性名和JavaBean中的属性名匹配</title>
    <link href="/2022/09/06/Json-JavaBean/"/>
    <url>/2022/09/06/Json-JavaBean/</url>
    
    <content type="html"><![CDATA[<p>目的：都是为了解决json字符串的某些属性名和JavaBean中的属性名匹配不上的问题。</p><h1 id="默认的json解析框架-jackson">默认的JSON解析框架 jackson</h1><ol type="1"><li>JsonProperty是位于jackson包里面，搭配<code>ObjectMapper().writeValueAsString(实体类)</code>方法使用，将实体类转换成字符串。</li></ol><p>搭配<code>ObjectMapper().readValue(字符串)</code>方法使用，将字符串转换成实体类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试例子：</p><p>实体类：User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-meta">@JsonProperty(&quot;JsonPropertyName&quot;)</span><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> String sex;<br><span class="hljs-keyword">private</span> Integer age;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sex;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br><span class="hljs-built_in">this</span>.sex = sex;<br>&#125;<br> <br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String sex, Integer age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.sex = sex;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>();<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [name=&quot;</span> + name + <span class="hljs-string">&quot;, sex=&quot;</span> + sex + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testJsonProperty</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;<br>User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;shiyu&quot;</span>,<span class="hljs-string">&quot;man&quot;</span>,<span class="hljs-number">22</span>);<br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(user));<br>String str=<span class="hljs-string">&quot;&#123;\&quot;sex\&quot;:\&quot;man\&quot;,\&quot;age\&quot;:22,\&quot;JsonPropertyName\&quot;:\&quot;shiyu\&quot;&#125;&quot;</span>;<br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>().readValue(str, User.class).toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">&#123;&quot;sex&quot;:&quot;man&quot;,&quot;age&quot;:22,&quot;JsonPropertyName&quot;:&quot;shiyu&quot;&#125;<br>User [name=shiyu, sex=man, age=22]<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>JSONField是位于fastjson包里面，搭配<code>JSON.toJSONString(实体类)</code>方法使用，将实体类转换成json字符串。搭配<code>JSON.parseObject(字符串,实体类.class)</code>方法使用，将字符串转换成实体类。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试例子：</p><p>实体类：User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.fastjson.annotation.JSONField;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><span class="hljs-meta">@JSONField(name=&quot;JSONFieldName&quot;)</span><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> String sex;<br><span class="hljs-keyword">private</span> Integer age;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> sex;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br><span class="hljs-built_in">this</span>.sex = sex;<br>&#125;<br> <br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(Integer age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, String sex, Integer age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.sex = sex;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>();<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [name=&quot;</span> + name + <span class="hljs-string">&quot;, sex=&quot;</span> + sex + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSONField</span><span class="hljs-params">()</span>&#123;<br>User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;shiyu&quot;</span>,<span class="hljs-string">&quot;man&quot;</span>,<span class="hljs-number">22</span>);<br>System.out.println(JSON.toJSONString(user));<br>String str=<span class="hljs-string">&quot;&#123;\&quot;JSONFieldName\&quot;:\&quot;shiyu\&quot;,\&quot;age\&quot;:22,\&quot;sex\&quot;:\&quot;man\&quot;&#125;&quot;</span>;<br>System.out.println(JSON.parseObject(str, User.class).toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<span class="hljs-string">&quot;JSONFieldName&quot;</span>:<span class="hljs-string">&quot;shiyu&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:22,<span class="hljs-string">&quot;sex&quot;</span>:<span class="hljs-string">&quot;man&quot;</span>&#125;<br>User [name=shiyu, sex=man, age=22]<br></code></pre></td></tr></table></figure><h1 id="alibaba的fastjson">alibaba的<a href="https://so.csdn.net/so/search?q=fastjson&amp;spm=1001.2101.3001.7020">fastjson</a></h1><p>接收请求时json转实体类用的<code>@JsonProperty</code>，返回响应时实体类转json返回时用<code>@JSONField</code></p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/20210429104717140.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Brief Introduction to Spring Cloud</title>
    <link href="/2022/09/05/spring-cloud-intro/"/>
    <url>/2022/09/05/spring-cloud-intro/</url>
    
    <content type="html"><![CDATA[<p>提起微服务，不得不提 Spring Cloud 全家桶系列，Spring Cloud 是一个服务治理平台，是若干个框架的集合（A lightweight event-driven <strong>microservices</strong> framework），提供了全套的分布式系统解决方案。包含了：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等等。</p><p>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state).</p><p>Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.</p><p>boiler plate patterns 参考了 boilerplate code，就是一些代码量很少，可以拿过来放到系统中直接使用的样板代码。我认为 boiler plate patterns 可以白话地理解为套路模式。</p><p>分布式系统间的协作都是有套路的，开发者使用 Spring Cloud 就可以快速地构建包括这些套路的服务和应用。</p><p>Spring Cloud 通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，Spring Cloud 就是这些微服务的大管家，采用了微服务这种架构之后，项目的数量会非常多，Spring Cloud 做为大管家需要管理好这些微服务，自然需要很多小弟来帮忙。</p><h1 id="子项目">子项目</h1><p>Spring Cloud 包含很多子项目，我们重点围绕 Netflix 和 Alibaba 两个标准实现给大家介绍：</p><figure><img src="https://pic3.zhimg.com/80/v2-db96197b4c11df192e401f55a4e96782_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="spring-cloud-netflix-第一代">Spring Cloud Netflix 第一代</h2><figure><img src="https://pic4.zhimg.com/80/v2-403fe073e211fa0d25bec05efc1f9367_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>Netflix是一家美国公司，在美国、加拿大提供互联网随选流媒体播放，定制DVD、蓝光光碟在线出租业务。该公司成立于1997年，总部位于加利福尼亚州洛斯盖图，1999年开始订阅服务。2009年，该公司可提供多达10万部DVD电影，并有1千万的订户。2007年2月25日，Netflix宣布已经售出第10亿份DVD。HIS一份报告中表示，2011年Netflix网络电影销量占据美国用户在线电影总销量的45%。</p></blockquote><p>针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Ribbon、Feign、Hystrix、Zuul、Archaius 等。</p><ul><li><code>Netflix Eureka</code>：一个基于 Rest 服务的服务治理组件，包括服务注册中心、服务注册与服务发现机制的实现，实现了云端负载均衡和中间层服务器的故障转移。</li><li><code>Netflix Ribbon</code>：客户端负载均衡的服务调用组件。</li><li><code>Netflix Hystrix</code>：<strong>容错管理工具</strong>，实现断路器模式，通过控制服务的节点，从而对延迟和故障提供更强大的容错能力。</li><li><code>Netflix Feign</code>：基于 Ribbon 和 Hystrix 的<strong>声明式服务调用组件</strong>。</li><li><code>Netflix Zuul</code>：微服务网关，提供动态路由，访问过滤等服务。</li><li><code>Netflix Archaius</code>：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li></ul><h2 id="spring-cloud-alibaba-第二代">Spring Cloud Alibaba 第二代</h2><figure><img src="https://pic1.zhimg.com/80/v2-f3e12f5bb438a71e2f7a1bdba3b61e90_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案。Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>这幅图是 Spring Cloud Alibaba 系列组件，其中包含了阿里开源组件，阿里云商业化组件，以及集成 Spring Cloud 组件。</p><figure><img src="https://pic3.zhimg.com/80/v2-648400ab6106da89560fb26845f4deba_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>阿里开源组件</strong></p><ul><li><code>Nacos</code>：阿里巴巴开源产品，一个更易于构建云原生应用的<strong>动态服务发现、配置管理和服务管理</strong>平台。Nacos (official site: <a href="https://nacos.io/">nacos.io</a>) is an easy-to-use platform designed for <strong>dynamic service discovery</strong> and configuration and service management. It helps you to build cloud native applications and microservices platform easily.</li><li><code>Sentinel</code>：面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从<strong>流量控制、熔断降级、系统负载</strong>保护等多个维度保护服务的稳定性。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架，用于实现服务通信。</li><li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li></ul><p><strong>阿里商业化组件</strong></p><ul><li><code>Alibaba Cloud ACM</code>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><code>Alibaba Cloud OSS</code>：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><code>Alibaba Cloud SchedulerX</code>：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><code>Alibaba Cloud SMS</code>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><p>作为 Spring Cloud 体系下的新实现，Spring Cloud Alibaba 跟官方的组件或其它的第三方实现如 Netflix，Consul，Zookeeper 等对比，具备了更多的功能：</p><figure><img src="https://pic1.zhimg.com/80/v2-558276887d809f32da1f81fc43a8b91c_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="常用组件">常用组件</h1><ul><li><code>Spring Cloud Netflix Eureka</code>：服务注册中心。</li><li><code>Spring Cloud Zookeeper</code>：服务注册中心。</li><li><code>Spring Cloud Consul</code>：服务注册和配置管理中心。</li><li><code>Spring Cloud Netflix Ribbon</code>：<strong>客户端负载均衡</strong>。</li><li><code>Spring Cloud Netflix Hystrix</code>：服务容错保护。</li><li><code>Spring Cloud Netflix Feign</code>：声明式服务调用。</li><li><code>Spring Cloud OpenFeign(可替代 Feign)</code>：OpenFeign 是 Spring Cloud 在 Feign 的基础上支持了 Spring MVC 的注解，如 <code>@RequesMapping</code>等等。OpenFeign 的 <code>@FeignClient</code> 可以解析 SpringMVC 的 <code>@RequestMapping</code> 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。</li><li><code>Spring Cloud Netflix Zuul</code>：API 网关服务，过滤、安全、监控、限流、路由。</li><li><code>Spring Cloud Gateway(可替代 Zuul)</code>：Spring Cloud Gateway 是 Spring 官方基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，Spring Cloud Gateway 旨在为微服务架构提供一种简单而有效的统一的 API 路由管理方式。Spring Cloud Gateway 作为 Spring Cloud 生态系中的网关，目标是替代 Netflix Zuul，其不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。</li><li><code>Spring Cloud Security</code>：安全认证。</li><li><code>Spring Cloud Config</code>：分布式配置中心。配置管理工具，支持使用 Git 存储配置内容，支持应用配置的外部化存储，支持客户端配置信息刷新、加解密配置内容等。</li><li><code>Spring Cloud Bus</code>：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</li><li><code>Spring Cloud Stream</code>：消息驱动微服务。</li><li><code>Spring Cloud Sleuth</code>：分布式服务跟踪。</li><li><code>Spring Cloud Alibaba Nacos</code>：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>Spring Cloud Alibaba Sentinel</code>：面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>Spring Cloud Alibaba RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Spring Cloud Alibaba Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架，用于实现服务通信。</li><li><code>Spring Cloud Alibaba Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li></ul><h1 id="总结">总结</h1><figure><img src="https://pic2.zhimg.com/80/v2-a786c069f918246e386b3bbd657e1905_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>虽然 Eureka，Hystrix 等不再继续开发或维护，但是目前来说不影响使用，不管怎么说感谢开源，向 Netflix 公司的开源致敬。</p></blockquote><h1 id="版本说明">版本说明</h1><figure><img src="https://pic3.zhimg.com/80/v2-ba7d3020c302034419cf31d3b9bf7872_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="为什么-spring-cloud-版本用的是单词而不是数字">为什么 Spring Cloud 版本用的是单词而不是数字？</h2><p>这样设计的目的是为了更好的管理每个 Spring Cloud 的子项目的清单。避免总版本号与子项目的版本号混淆。</p><blockquote><p>例如：Spring Cloud 2.2.0.RELEASE 的 Spring Cloud Netflix 2.2.2.RELEASE 如果使用这种方式会让开发者混淆版本号。</p></blockquote><h2 id="定义规则">定义规则</h2><p>采用伦敦的地铁站名称来作为版本号的命名，根据首字母排序，字母顺序靠后的版本号越大。</p><p><strong>Spring 官方详细的版本查看接口：<a href="https://link.zhihu.com/?target=https%3A//start.spring.io/actuator/info">https://start.spring.io/actuator/info</a></strong></p><h2 id="发布计划">发布计划</h2><figure><img src="https://pic3.zhimg.com/80/v2-9ae319033005f32e05ecef772ea481a2_1440w.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="子项目版本说明">子项目版本说明</h2><p>例如：<strong>Spring Cloud Alibaba 2.1.0.RELEASE</strong></p><ul><li>2：主版本号。当功能模块有较大更新或者整体架构发生变化时，主版本号会更新。</li><li>1：次版本号。次版本表示只是局部的一些变动。</li><li>0：修改版本号。一般是 bug 的修复或者是小的变动。</li><li>RELEASE：希腊字母版本号。标注当前版本的软件处于哪个开发阶段。</li></ul><h2 id="希腊字母版本说明">希腊字母版本说明</h2><ul><li>Base：设计阶段。只有相应的设计没有具体的功能实现。</li><li>Alpha：软件的初级版本。存在较多的 bug。</li><li>Bate：表示相对 Alpha 有了很大的进步，消除了严重的 bug，还存在一些潜在的 bug。</li><li>Gamma：是 Beta 版做过一些修改，成为正式发布的候选版本（Release Candidate）</li><li>Release：该版本表示最终版。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Clud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同一电脑上同时使用GitHub和Gitee</title>
    <link href="/2022/09/02/github-gitee/"/>
    <url>/2022/09/02/github-gitee/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>有些教程说并需要清空全局用户名和邮箱。这是错的！！！！</p><p>并不需要清除这些。全局用户名和邮箱只是你SSH对方时候，作为本机的识别标识。</p>          </div><h1 id="创建-ssh-key">创建 ssh key</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入用户目录下的 .ssh 文件夹下，路径会因你使用的操作系统不同而略有差异</span><br><span class="hljs-comment"># 没有这个文件夹也无所谓，直接运行下一句命令也可以</span><br><span class="hljs-built_in">cd</span> ~/.ssh<br><br><span class="hljs-comment"># 生成 key，将邮件地址替换为你 Gitee 或者 Github 使用的邮件地址</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;xxx@xxx.com&quot;</span><br></code></pre></td></tr></table></figure><p>接下来应该会看到下面的提示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Generating</span> <span class="hljs-keyword">public</span><span class="hljs-operator">/</span><span class="hljs-keyword">private</span> rsa key pair.<br><span class="hljs-type">Enter</span> file <span class="hljs-keyword">in</span> which to save the key (<span class="hljs-operator">/</span>c<span class="hljs-operator">/</span><span class="hljs-type">Users</span><span class="hljs-operator">/</span>your_user_name<span class="hljs-operator">/</span>.ssh<span class="hljs-operator">/</span>id_rsa): <span class="hljs-operator">/</span>c<span class="hljs-operator">/</span><span class="hljs-type">Users</span><span class="hljs-operator">/</span>your_user_name<span class="hljs-operator">/</span>.ssh<span class="hljs-operator">/</span>id_rsa_gitee<br></code></pre></td></tr></table></figure><p>这一步如果默认回车，会生成名为 id_rsa 的文件，你可以输入不同的名字来便于识别文件，比如生成 Gitee 的 ssh key 可以设置为 id_rsa_gitee，设置 Github 的 ssh key 可以设置为 id_rsa_github . 然后一直回车就可以了</p><h1 id="在-gitee-和-github-添加-public-key">在 Gitee 和 Github 添加 public key</h1><p>找到用户目录下的 .ssh 文件夹，查看并复制创建好的 id_rsa_gitee.pub 或 id_rsa_github.pub 的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br><span class="hljs-comment"># 查看 id_rsa_gitee.pub 文件内容</span><br><span class="hljs-built_in">cat</span> id_rsa_gitee.pub<br></code></pre></td></tr></table></figure><p>复制文件内容打开 Gitee 和 Github 的网站找到设置，再找到 SSH Keys，添加复制的 public key 。 id_rsa_gitee.pub的添加给Gitee ，id_rsa_github .pub的添加到Github 。</p><h1 id="创建配置文件">创建配置文件</h1><p>在 .ssh 文件夹中创建 config 文件，添加以下内容以区分两个 ssh key：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># gitee</span><br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/id</span>_rsa_gitee<br><br><span class="hljs-comment"># github</span><br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/id</span>_rsa_github<br></code></pre></td></tr></table></figure><h1 id="测试连接是否正常">测试连接是否正常</h1><p>在命令行输入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ssh -T git<span class="hljs-keyword">@github</span>.com<br></code></pre></td></tr></table></figure><p>若返回如下内容，则 Github 连接正常：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Hi yourname! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure><p>继续在命令行输入：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ssh -T git<span class="hljs-keyword">@gitee</span>.com<br></code></pre></td></tr></table></figure><p>若返回如下内容，则 Gitee 连接正常。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust">Hi yourname! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Kaze+Gitee Pages 搭建静态博客网站</title>
    <link href="/2022/08/30/Hexo-Kaze-Gitee/"/>
    <url>/2022/08/30/Hexo-Kaze-Gitee/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>建网站本身是一个很大的工程，涉及前端页面的搭建，网站数据的存储，还要购置服务器资源，甚至是后期的维护，过程相当繁琐。</p><p>不过如果仅仅是想搭建个人的网站，写写博客，想要美观，又不想操心太多和写博客无关的事情。那么，Hexo + Kaze + Gitee Pages 的方式就很适合你。</p><p>本文就讲下如何借助这三样免费的技术或服务，来搭建一个可访问的静态博客网站。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/bda1e275b460aa88f2e023392ad910bb.png" alt="bda1e275b460aa88f2e023392ad910bb.png" /><figcaption aria-hidden="true">bda1e275b460aa88f2e023392ad910bb.png</figcaption></figure><h1 id="hexo-简介">Hexo 简介</h1><h2 id="hexo-是什么">Hexo 是什么？</h2><p><a href="https://hexo.io/docs/">Hexo</a>[1] 是一个快速，简单且功能强大的博客框架。如果你用 Markdown 写博客，Hexo 可以在几秒内生成带有精美主题的静态文件。</p><h2 id="hexo-安装">Hexo 安装</h2><h3 id="前置要求">前置要求</h3><ul><li>Node.js(版本 10.13 以上，建议使用 12.0 以上版本)</li><li>Git</li></ul><h3 id="安装-git">安装 Git</h3><ul><li><p>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>[2]。</p></li><li><p>Mac：使用 <a href="https://brew.sh/">Homebrew</a>[3] 安装。</p></li><li><p>Linux(Ubuntu，Debian)：<code>sudo apt-get install git-core</code></p></li><li><p>Linux(Fedora，Red Hat，CentOS)：<code>sudo yum install git-core</code></p></li></ul><h3 id="安装-node.js">安装 Node.js</h3><p>Node.js 为大多数平台提供了 官方安装程序[4]。</p><p>替代安装方法：</p><ul><li>Windows：使用 nvs[5] 安装它。</li><li>Mac：使用 Homebrew[6] 安装。</li><li>Linux(基于 DEB / RPM)：与 NodeSource[7] 一起安装。</li><li>其他：通过相应的软件包管理器进行安装。请参阅 Node.js 提供的指南[8]。</li></ul><h3 id="安装-hexo">安装 Hexo</h3><p>用 npm 安装 Hexo。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g hexo-cli<br></code></pre></td></tr></table></figure><p>使用以下指令查看是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo version<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/48c8eefd10f68b12e1f587971c2f286e.png" alt="48c8eefd10f68b12e1f587971c2f286e.png" /><figcaption aria-hidden="true">48c8eefd10f68b12e1f587971c2f286e.png</figcaption></figure><p>如果你想卸载 Hexo，使用以下指令：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="运行-hexo">运行 hexo</h3><p>安装后，你可以通过 <code>hexo</code>运行 Hexo。比如通过 <code>hexo help</code> 指令来获取使用帮助。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">hexo help<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/409d93031d2120880acd225e9c7dee86.png" alt="409d93031d2120880acd225e9c7dee86.png" /><figcaption aria-hidden="true">409d93031d2120880acd225e9c7dee86.png</figcaption></figure><p>帮助里提到 <code>hexo init</code> 命令可以创建一个新的 Hexo 文件夹，这个文件夹其实就是利用 Hexo 生成的站点信息了。接下来讲下怎么建站。</p><h1 id="hexo-建站">Hexo 建站</h1><h2 id="初始化操作">初始化操作</h2><p>使用 <code>hexo init</code>指令就可以在指定文件夹下建立站点信息，我一般用域名做名称，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift">hexo <span class="hljs-keyword">init</span> java4u.cn<br></code></pre></td></tr></table></figure><p>站点初始化中：</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/e8a6ba2002283d33f15b4d2af55da634.png" alt="e8a6ba2002283d33f15b4d2af55da634.png" /><figcaption aria-hidden="true">e8a6ba2002283d33f15b4d2af55da634.png</figcaption></figure><p>站点初始化完成，会生成指定的文件夹：</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/064fb5da16e15506ac9e8d0168b1d353.png" alt="064fb5da16e15506ac9e8d0168b1d353.png" /><figcaption aria-hidden="true">064fb5da16e15506ac9e8d0168b1d353.png</figcaption></figure><h2 id="目录结构">目录结构</h2><p>进入该站点，我们看下目录结构，如下：</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/bbc758343f8b9e4061728b39705bdcac.png" alt="bbc758343f8b9e4061728b39705bdcac.png" /><figcaption aria-hidden="true">bbc758343f8b9e4061728b39705bdcac.png</figcaption></figure><p>这些文件有着各自的职责：</p><ul><li><p>_config.landscape.yml：自定义的主题配置文件，此处的 landscape 是默认主题。配置其他主题可以参考这种方式。</p></li><li><p>_config.yml：站点全局的配置文件。</p></li><li><p>node_modules：node 模块文件夹。包含可执行文件和依赖的资源。</p></li><li><p>package-lock.json：node_modules 文件中所有模块的版本信息，模块来源。</p></li><li><p>package.json：Hexo 框架的基本参数信息以及它所依赖的插件。</p></li><li><p>scaffolds：scaffolds 原意是脚手架，这里可以理解为模板文件夹。当你创建新的文章时，Hexo 会根据该文件夹下的对应文件进行初始化构建。</p></li><li><p>source：资源文件夹。这里是你放自己资源比如博文和图片的地方。<code>_posts</code> 文件夹下的 Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹下。其他文件或文件夹，如果开头命名不是 <code>_</code> (下划线)，也都会被拷贝过去。</p></li><li><p>themes：主题文件夹。Hexo 会根据主题来生成静态页面。</p></li></ul><p>基于这样的结构，Hexo 就具备了生成静态网站的能力。</p><h2 id="本地启动">本地启动</h2><p>我们先本地启动，看下实际效果。输入以下命令：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">hexo <span class="hljs-built_in">server</span><br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/5cc75a44459f5436ea15ca69fb36cda7.png" alt="5cc75a44459f5436ea15ca69fb36cda7.png" /><figcaption aria-hidden="true">5cc75a44459f5436ea15ca69fb36cda7.png</figcaption></figure><p>Hexo 会启动服务，将默认生成的网站运行在本机的 4000 端口上，可以直接访问 <code>http://localhost:4000</code> 就能看到网站首页，它基于默认主题生成，同时有一篇默认文章。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/b0415eba97e110e9c3700fa52a78ed6a.png" alt="b0415eba97e110e9c3700fa52a78ed6a.png" /><figcaption aria-hidden="true">b0415eba97e110e9c3700fa52a78ed6a.png</figcaption></figure><p>这个页面只是官方提供的一个样例，看到它就意味着你本地环境跑通了。我们可以通过修改配置的方式，对页面相关元素做调整。</p><h2 id="核心配置">核心配置</h2><p>以下是我们需要了解或者修改的配置信息。</p><h3 id="package.json">package.json</h3><p>这个文件列出了 Hexo 的基本参数信息以及它所依赖的插件。可以看到，EJS[9]，Stylus[10] 和 Markdown[11] 渲染器都是默认安装的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,  <br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,  <br>    <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,  <br>      <span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <br>        <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;hexo generate&quot;</span>,    <br>          <span class="hljs-string">&quot;clean&quot;</span>: <span class="hljs-string">&quot;hexo clean&quot;</span>,    <br>            <span class="hljs-string">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;hexo deploy&quot;</span>,    <br>              <span class="hljs-string">&quot;server&quot;</span>: <span class="hljs-string">&quot;hexo server&quot;</span>  <br>      &#125;,  <br>        <span class="hljs-string">&quot;hexo&quot;</span>: &#123;    <br>          <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span>  <br>        &#125;,  <br>          <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;    <br>            <span class="hljs-string">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^5.0.0&quot;</span>,    <br>              <span class="hljs-string">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <br>                <span class="hljs-string">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <br>                  <span class="hljs-string">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,    <br>                    <span class="hljs-string">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <br>                      <span class="hljs-string">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span>,    <br>                        <span class="hljs-string">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^3.0.0&quot;</span>,    <br>                          <span class="hljs-string">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,    <br>                            <span class="hljs-string">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^2.0.0&quot;</span>,    <br>                              <span class="hljs-string">&quot;hexo-theme-landscape&quot;</span>: <span class="hljs-string">&quot;^0.0.3&quot;</span>  <br>          &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果后边要切换主题，记得把最后一个默认的主题依赖删除掉。</p></blockquote><h3 id="config.yml">_config.yml</h3><p>可设置网站、网址、目录、文章、分类&amp;标签、日期/时间格式、分页和扩展等信息。</p><h3 id="网站">网站</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/a9d712d8e2fc006a9b0aacb7bae0bd84.png" alt="a9d712d8e2fc006a9b0aacb7bae0bd84.png" /><figcaption aria-hidden="true">a9d712d8e2fc006a9b0aacb7bae0bd84.png</figcaption></figure><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>title</code></td><td style="text-align: left;">网站标题</td></tr><tr class="even"><td style="text-align: left;"><code>subtitle</code></td><td style="text-align: left;">网站副标题</td></tr><tr class="odd"><td style="text-align: left;"><code>description</code></td><td style="text-align: left;">网站描述，用于 SEO</td></tr><tr class="even"><td style="text-align: left;"><code>keywords</code></td><td style="text-align: left;">网站的关键词，支持多个关键词。</td></tr><tr class="odd"><td style="text-align: left;"><code>author</code></td><td style="text-align: left;">文章作者。</td></tr><tr class="even"><td style="text-align: left;"><code>language</code></td><td style="text-align: left;">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr class="odd"><td style="text-align: left;"><code>timezone</code></td><td style="text-align: left;">网站时区。Hexo 默认使用你电脑的时区。请参考 时区列表[12] 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><h3 id="url">URL</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/7914f5f7af790c204a057011036eed1e.png" alt="7914f5f7af790c204a057011036eed1e.png" /><figcaption aria-hidden="true">7914f5f7af790c204a057011036eed1e.png</figcaption></figure><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>url</code></td><td style="text-align: left;">网址, must starts with <code>http://</code> or <code>https://</code></td><td style="text-align: left;">http://example.com</td></tr><tr class="even"><td style="text-align: left;"><code>root</code></td><td style="text-align: left;">网站根目录，如果放子目录，设置 <code>/blog/</code></td><td style="text-align: left;">/</td></tr><tr class="odd"><td style="text-align: left;"><code>permalink</code></td><td style="text-align: left;">文章的 永久链接[13] 格式</td><td style="text-align: left;"><code>:year/:month/:day/:title/</code></td></tr><tr class="even"><td style="text-align: left;"><code>permalink_defaults</code></td><td style="text-align: left;">永久链接中各部分的默认值</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>pretty_urls</code></td><td style="text-align: left;">改写 <code>permalink</code>[14] 的值来美化 URL</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>pretty_urls.trailing_index</code></td><td style="text-align: left;">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td style="text-align: left;"><code>true</code></td></tr><tr class="odd"><td style="text-align: left;"><code>pretty_urls.trailing_html</code></td><td style="text-align: left;">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td style="text-align: left;"><code>true</code></td></tr></tbody></table><h3 id="目录">目录</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/b05165191376b2ae89c859ff3489cd78.png" alt="b05165191376b2ae89c859ff3489cd78.png" /><figcaption aria-hidden="true">b05165191376b2ae89c859ff3489cd78.png</figcaption></figure><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>source_dir</code></td><td style="text-align: left;">资源文件夹，这个文件夹用来存放内容。</td><td style="text-align: left;"><code>source</code></td></tr><tr class="even"><td style="text-align: left;"><code>public_dir</code></td><td style="text-align: left;">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td style="text-align: left;"><code>public</code></td></tr><tr class="odd"><td style="text-align: left;"><code>tag_dir</code></td><td style="text-align: left;">标签文件夹</td><td style="text-align: left;"><code>tags</code></td></tr><tr class="even"><td style="text-align: left;"><code>archive_dir</code></td><td style="text-align: left;">归档文件夹</td><td style="text-align: left;"><code>archives</code></td></tr><tr class="odd"><td style="text-align: left;"><code>category_dir</code></td><td style="text-align: left;">分类文件夹</td><td style="text-align: left;"><code>categories</code></td></tr><tr class="even"><td style="text-align: left;"><code>code_dir</code></td><td style="text-align: left;">Include code 文件夹，<code>source_dir</code> 下的子目录</td><td style="text-align: left;"><code>downloads/code</code></td></tr><tr class="odd"><td style="text-align: left;"><code>i18n_dir</code></td><td style="text-align: left;">国际化(i18n)文件夹</td><td style="text-align: left;"><code>:lang</code></td></tr><tr class="even"><td style="text-align: left;"><code>skip_render</code></td><td style="text-align: left;">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。</td><td style="text-align: left;"></td></tr></tbody></table><h3 id="文章">文章</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/3940f054b0c964bb6892093281a28676.png" alt="3940f054b0c964bb6892093281a28676.png" /><figcaption aria-hidden="true">3940f054b0c964bb6892093281a28676.png</figcaption></figure><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>new_post_name</code></td><td style="text-align: left;">新文章的文件名称</td><td style="text-align: left;">:title.md</td></tr><tr class="even"><td style="text-align: left;"><code>default_layout</code></td><td style="text-align: left;">预设布局</td><td style="text-align: left;">post</td></tr><tr class="odd"><td style="text-align: left;"><code>auto_spacing</code></td><td style="text-align: left;">在中文和英文之间加入空格</td><td style="text-align: left;">false</td></tr><tr class="even"><td style="text-align: left;"><code>titlecase</code></td><td style="text-align: left;">把标题转换为 title case</td><td style="text-align: left;">fals</td></tr><tr class="odd"><td style="text-align: left;"><code>external_link</code></td><td style="text-align: left;">在新标签中打开链接</td><td style="text-align: left;">true</td></tr><tr class="even"><td style="text-align: left;"><code>external_link.enable</code></td><td style="text-align: left;">在新标签中打开链接</td><td style="text-align: left;"><code>true</code></td></tr><tr class="odd"><td style="text-align: left;"><code>external_link.field</code></td><td style="text-align: left;">对整个网站(<code>site</code>)生效或仅对文章(<code>post</code>)生效</td><td style="text-align: left;"><code>site</code></td></tr><tr class="even"><td style="text-align: left;"><code>external_link.exclude</code></td><td style="text-align: left;">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td style="text-align: left;"><code>[]</code></td></tr><tr class="odd"><td style="text-align: left;"><code>filename_case</code></td><td style="text-align: left;">把文件名称转换为 (1) 小写或 (2) 大写</td><td style="text-align: left;">0</td></tr><tr class="even"><td style="text-align: left;"><code>render_drafts</code></td><td style="text-align: left;">显示草稿</td><td style="text-align: left;">false</td></tr><tr class="odd"><td style="text-align: left;"><code>post_asset_folder</code></td><td style="text-align: left;">启动 Asset 文件夹[15]</td><td style="text-align: left;">false</td></tr><tr class="even"><td style="text-align: left;"><code>relative_link</code></td><td style="text-align: left;">把链接改为与根目录的相对地址，建议使用绝对地址。</td><td style="text-align: left;">false</td></tr><tr class="odd"><td style="text-align: left;"><code>future</code></td><td style="text-align: left;">显示未来的文章</td><td style="text-align: left;">true</td></tr><tr class="even"><td style="text-align: left;"><code>highlight</code></td><td style="text-align: left;">代码块的设置, see Highlight.js[16] section for usage guide</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>prismjs</code></td><td style="text-align: left;">代码块的设置, see PrismJS[17] section for usage guide</td><td style="text-align: left;"></td></tr></tbody></table><h3 id="分类-标签">分类 &amp; 标签</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/ca4f2e0662a5e17d9a584fd3aeb757e7.png" alt="ca4f2e0662a5e17d9a584fd3aeb757e7.png" /><figcaption aria-hidden="true">ca4f2e0662a5e17d9a584fd3aeb757e7.png</figcaption></figure><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>default_category</code></td><td style="text-align: left;">默认分类</td><td style="text-align: left;"><code>uncategorized</code></td></tr><tr class="even"><td style="text-align: left;"><code>category_map</code></td><td style="text-align: left;">分类别名</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;"><code>tag_map</code></td><td style="text-align: left;">标签别名</td><td style="text-align: left;"></td></tr></tbody></table><h3 id="日期时间格式">日期/时间格式</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/a83d703d3dc42389934650c2c5347927.png" alt="a83d703d3dc42389934650c2c5347927.png" /><figcaption aria-hidden="true">a83d703d3dc42389934650c2c5347927.png</figcaption></figure><p>Hexo 使用 Moment.js[18] 来解析和显示时间。</p><table style="width:100%;"><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>date_format</code></td><td style="text-align: left;">日期格式</td><td style="text-align: left;"><code>YYYY-MM-DD</code></td></tr><tr class="even"><td style="text-align: left;"><code>time_format</code></td><td style="text-align: left;">时间格式</td><td style="text-align: left;"><code>HH:mm:ss</code></td></tr><tr class="odd"><td style="text-align: left;"><code>updated_option</code></td><td style="text-align: left;">当 Front Matter 中没有指定 <code>updated</code>[19] 时 <code>updated</code> 的取值，支持 mtime(文件最后修改时间)，date(使用 date 的值)，empty(不指定)</td><td style="text-align: left;"><code>mtime</code></td></tr></tbody></table><h3 id="分页">分页</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/4275a4ad9a21feb4e345997cb84f2792.png" alt="4275a4ad9a21feb4e345997cb84f2792.png" /><figcaption aria-hidden="true">4275a4ad9a21feb4e345997cb84f2792.png</figcaption></figure><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>per_page</code></td><td style="text-align: left;">每页显示的文章量 (0 = 关闭分页功能)</td><td style="text-align: left;"><code>10</code></td></tr><tr class="even"><td style="text-align: left;"><code>pagination_dir</code></td><td style="text-align: left;">分页目录</td><td style="text-align: left;"><code>page</code></td></tr></tbody></table><h3 id="扩展">扩展</h3><figure><img src="https://img-blog.csdnimg.cn/img_convert/4bbeef3cc97c063aa50269e818cc028c.png" alt="4bbeef3cc97c063aa50269e818cc028c.png" /><figcaption aria-hidden="true">4bbeef3cc97c063aa50269e818cc028c.png</figcaption></figure><p>【主题】</p><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>theme</code></td><td style="text-align: left;">当前主题名称。值为<code>false</code>时禁用主题</td><td style="text-align: left;">landscape</td></tr><tr class="even"><td style="text-align: left;"><code>theme_config</code></td><td style="text-align: left;">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td><td style="text-align: left;">无初始配置</td></tr><tr class="odd"><td style="text-align: left;"><code>deploy</code></td><td style="text-align: left;">部署部分的设置</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>meta_generator</code></td><td style="text-align: left;">Meta generator[20] 标签。值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td><td style="text-align: left;">true</td></tr></tbody></table><p>【部署】</p><p>配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span>  <br><span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <br><span class="hljs-attr">repo:</span>  <span class="hljs-comment">#https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io  branch: [branch]  message: [message]</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">描述</th><th style="text-align: left;">默认</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;"><code>repo</code></td><td style="text-align: left;">库(Repository)地址</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><code>branch</code></td><td style="text-align: left;">分支名称</td><td style="text-align: left;"><code>gh-pages</code> (GitHub) <code>coding-pages</code> (Coding.net) <code>master</code> (others)</td></tr><tr class="odd"><td style="text-align: left;"><code>message</code></td><td style="text-align: left;">自定义提交信息</td><td style="text-align: left;"><code>Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;</code>)</td></tr><tr class="even"><td style="text-align: left;"><code>token</code></td><td style="text-align: left;">Optional token value to authenticate with the repo. Prefix with <code>$</code> to read token from environment variable</td><td style="text-align: left;"></td></tr></tbody></table><h1 id="常用指令">常用指令</h1><h2 id="创建文章">创建文章</h2><p>使用以下指令：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;test&quot;</span><br></code></pre></td></tr></table></figure><p>或者简写：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">hexo n <span class="hljs-string">&quot;test&quot;</span><br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/40c0e78ae8caca227ea62e99a609fa01.png" alt="40c0e78ae8caca227ea62e99a609fa01.png" /><figcaption aria-hidden="true">40c0e78ae8caca227ea62e99a609fa01.png</figcaption></figure><h2 id="运行服务器">运行服务器</h2><p>输入以下命令以启动服务器，你的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，你无须重启服务器。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">hexo <span class="hljs-built_in">server</span><br></code></pre></td></tr></table></figure><p>或者简写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo s<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/4698666cba614faddb6add08eab32b6c.png" alt="4698666cba614faddb6add08eab32b6c.png" /><figcaption aria-hidden="true">4698666cba614faddb6add08eab32b6c.png</figcaption></figure><h2 id="生成静态文件">生成静态文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo generate<br></code></pre></td></tr></table></figure><p>或者简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo g<br></code></pre></td></tr></table></figure><p>监视文件变动立即重新生成。该操作会阻塞命令。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">hexo g <span class="hljs-attr">--watch</span><br></code></pre></td></tr></table></figure><p>生成完毕后自动部署网站。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">hexo generate <span class="hljs-attr">--deploy</span><br></code></pre></td></tr></table></figure><h2 id="部署">部署</h2><p>Hexo 提供了快速方便的一键部署功能，让你只需一条命令就能将网站部署到服务器上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo deploy<br></code></pre></td></tr></table></figure><p>或者简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo d<br></code></pre></td></tr></table></figure><h1 id="hexo-主题">Hexo 主题</h1><h2 id="为什么选择-kaze">为什么选择 Kaze</h2><p>Hexo 默认主题为 landscape，但我觉得不够美观，这里推荐 <strong>kaze[21]</strong> ,它有以下特性：</p><ul><li>响应式设计，适配桌面端、平板、手机等各种设备</li><li>前端性能优化，加载快速，眨眼之间即可加载完成<ul><li>图片懒加载，应用懒加载技术加快页面的生成速度</li><li>资源压缩，提升本地资源请求速度</li><li>精简设计，不包含 Jquery 等额外库</li></ul></li><li>支持侧边栏小组件，例如最近文章，作者卡片</li><li>暗黑模式，享受黑夜的魅力</li><li>代码高亮，支持 <strong>prismjs</strong></li><li>公式渲染，支持 <strong>katex</strong> 和 <strong>mathjax</strong></li><li>评论系统，集成 <strong>valine</strong>、<strong>gitalk</strong> 和 <strong>livere</strong></li><li>访问量统计和谷歌分析支持</li></ul><h2 id="安装-kaze">安装 Kaze</h2><p>在 <code>your site/themes</code> 下输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> themesgit <span class="hljs-built_in">clone</span> https://github.com/theme-kaze/hexo-theme-Kaze.git<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/0d703fe586809b6b76702b6856440efe.png" alt="0d703fe586809b6b76702b6856440efe.png" /><figcaption aria-hidden="true">0d703fe586809b6b76702b6856440efe.png</figcaption></figure><p>安装成功后，会生出目录：hexo-theme-Kaze。</p><p>修改站点配置文件 <code>_config.yml</code> 下的主题值为：hexo-theme-Kaze。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/8b590c918ef1233e0e4d061f6fe95555.png" alt="8b590c918ef1233e0e4d061f6fe95555.png" /><figcaption aria-hidden="true">8b590c918ef1233e0e4d061f6fe95555.png</figcaption></figure><p>用 <code>hexo server</code> 启动 Hexo 服务看下效果。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/492f95d43eeb6d7d66bf4c98d1e1ee48.png" alt="492f95d43eeb6d7d66bf4c98d1e1ee48.png" /><figcaption aria-hidden="true">492f95d43eeb6d7d66bf4c98d1e1ee48.png</figcaption></figure><p>会看到已经生成了默认的主题，只是很多东西都没有，需要改造一下。</p><h2 id="主题配置">主题配置</h2><p>可在该主题目录下的 **_config.yml** 文件里配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">color:</span>  <br><span class="hljs-attr">text-color:</span> <span class="hljs-string">&quot;#3c4858&quot;</span>  <br><span class="hljs-attr">text-strong-color:</span> <span class="hljs-string">&quot;#2f3d4e&quot;</span>  <br><span class="hljs-attr">text-light-color:</span> <span class="hljs-string">&quot;#909faf&quot;</span>  <br><span class="hljs-attr">divider-color:</span> <span class="hljs-string">&quot;#e6e8ee&quot;</span>  <br><span class="hljs-attr">title-color:</span> <span class="hljs-string">&quot;#475b6d&quot;</span>  <br><span class="hljs-attr">link-color:</span> <span class="hljs-string">&quot;#3273dc&quot;</span>  <br><span class="hljs-attr">link-hover-color:</span> <span class="hljs-string">&quot;#6596e5&quot;</span>  <br><span class="hljs-attr">info-text-color:</span> <span class="hljs-string">&quot;#909faf&quot;</span>  <br><span class="hljs-attr">widget-background-color:</span> <span class="hljs-string">&quot;#fff&quot;</span>  <br><span class="hljs-attr">body-background-color:</span> <span class="hljs-string">&quot;#f2f5f8&quot;</span>  <br><span class="hljs-attr">border-color:</span> <span class="hljs-string">&quot;#e1e4e9&quot;</span>  <br><span class="hljs-attr">pre-color:</span> <span class="hljs-string">&quot;#2d2d2d&quot;</span>  <br><span class="hljs-attr">code-color:</span> <span class="hljs-string">&quot;#50687c&quot;</span>  <br><span class="hljs-attr">code-background-color:</span> <span class="hljs-string">&quot;#e9eaf0&quot;</span><br></code></pre></td></tr></table></figure><h2 id="字号与字体">字号与字体</h2><p>在 <strong>font</strong> 中进行配置，以下是默认值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">font:</span>  <br><span class="hljs-attr">font-size:</span> <span class="hljs-string">16px</span> <span class="hljs-comment"># global font-size  </span><br><span class="hljs-attr">font-family:</span> <span class="hljs-string">&#x27;-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,sans-serif&#x27;</span> <span class="hljs-comment"># global font-family</span><br></code></pre></td></tr></table></figure><h2 id="站点访问量统计">站点访问量统计</h2><p>访问量统计目前仅支持不蒜子，默认关闭，可统计站点总访问量和总访客数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span>  <span class="hljs-comment">#------------------------  # pv / uv statistics config  #------------------------  </span><br><span class="hljs-attr">statistics:</span>    <br><span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span>    <br><span class="hljs-attr">type:</span> <span class="hljs-string">busuanzi</span> <span class="hljs-comment"># now version only supports busuanzi    </span><br><span class="hljs-attr">pv:</span>     <br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>      <br>  <span class="hljs-attr">style:</span> <span class="hljs-string">本站总访问量&#123;&#125;次</span> <span class="hljs-comment"># the style will be shown as $1&#123;pv&#125;$2    </span><br>  <span class="hljs-attr">uv:</span>      <br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>      <br>  <span class="hljs-attr">style:</span> <span class="hljs-string">本站总访客数&#123;&#125;次</span> <span class="hljs-comment"># the style will be shown as $1&#123;uv&#125;$2</span><br></code></pre></td></tr></table></figure><h2 id="数据分析">数据分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">analytics:  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">false</span>  <span class="hljs-built_in">type</span>: google <span class="hljs-comment"># google  google:    id:</span><br></code></pre></td></tr></table></figure><p><code>enable</code> 开启分析支持(默认关闭)</p><p>type 目前仅支持 google</p><p><code>google.id</code> 有关谷歌分析的具体使用说明和 <code>id</code> 使用可以参考谷歌文档[22]</p><h2 id="首页">首页</h2><h3 id="文章头图">文章头图</h3><p>在文章 <code>Front-matter</code> 中 <code>banner_img</code> 可以设置首页头图</p><h3 id="小组件">小组件</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">widgets:</span>  showWidgetsMobiles: <span class="hljs-string">&quot;none&quot;</span><br></code></pre></td></tr></table></figure><p><code>showWidgetsMobiles</code> : 在窄屏幕上是否显示小组件，<code>none</code> 关闭(默认)，<code>flex</code> 开启</p><h2 id="关于">关于</h2><p>关于页面需要自行创建，在站点 <code>source</code> 中新建 <code>about</code> 文件夹并在文件夹内创建 <code>index.md</code>，该文件至少需要包含</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># at $&#123;yoursite&#125;/about/index.md---title: 关于layout: about---</span><br></code></pre></td></tr></table></figure><h3 id="社交链接">社交链接</h3><p>在 about 下的 <code>social_links</code>中进行配置，主题图标依赖于 iconfont[23]，Hexo 内置了一部分社交图标，你可以自定义其他 icon 文件或者解决方案来添加自定义图标。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">about:</span>  <br><span class="hljs-attr">description:</span> <span class="hljs-string">description</span>  <br><span class="hljs-attr">social_links:</span>    <span class="hljs-bullet">-</span> &#123; <span class="hljs-attr">icon:</span> <span class="hljs-string">icon-github</span>, <span class="hljs-attr">link:</span>  <span class="hljs-string">https://xxx</span>&#125;    <span class="hljs-comment"># - &#123; icon: icon, link: your link &#125;</span><br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/2e658deb369ea09af6d548e81e0bfaf7.png" alt="2e658deb369ea09af6d548e81e0bfaf7.png" /><figcaption aria-hidden="true">2e658deb369ea09af6d548e81e0bfaf7.png</figcaption></figure><h3 id="友链">友链</h3><p>友链格式按如下填写即可生成友链页面</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">links:  example-name-1:</span>    <br><span class="hljs-attr">url:</span> <span class="hljs-string">https://example.com</span>    <br><span class="hljs-attr">avatar:</span> <span class="hljs-string">https://example.com/avatar.jpg</span>  <br><span class="hljs-attr">example-name-2:</span>    <br><span class="hljs-attr">url:</span> <span class="hljs-string">https://example.com</span>    <br><span class="hljs-attr">avatar:</span> <span class="hljs-string">https://example.com/avatar.jpg</span><br></code></pre></td></tr></table></figure><h2 id="文章页">文章页</h2><h3 id="搜索功能">搜索功能</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">search</span>:  enable: <span class="hljs-literal">true</span>  path: search.json  field: posts  searchContent: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li><p><code>enable</code> 开启搜索功能(默认开启)</p></li><li><p><code>path</code> 文件名称(暂无用处)</p></li><li><p><code>field</code> 需要搜索的范围，支持 posts | pages | all</p></li><li><p><code>searchContent</code> 搜索文件是否包含正文内容(不建议开启，包含所有文章内容这样会使得搜索文件异常巨大)替代方案是搜索分类标签或使用 algolia 等第三方搜索服务(Todo)</p></li></ul><h3 id="目录-1">目录</h3><p>主题目录通过 Hexo 原生函数生成，具体可参见 文档[24]</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">toc:</span>  showListNumber: <span class="hljs-literal">false</span>  maxDepth: <span class="hljs-number">6</span>  minDepth: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>showListNumber</code> 是否生成编号</p><p><code>maxDepth</code> TOC 最大深度</p><p><code>minDepth</code> TOC 最小深度</p><h3 id="代码高亮">代码高亮</h3><p>参见代码 高亮文档[25]</p><h3 id="数学公式">数学公式</h3><p>主题支持 <code>mathjax</code> 和 <code>katex</code> 两种渲染引擎，具体参见 相关文档[26]</p><h2 id="copyright">copyright</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">copyright:</span>  <br><span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <br><span class="hljs-attr">writer:</span> <span class="hljs-comment"># if writer is empty we will use config.author as writer  </span><br><span class="hljs-attr">declare:</span> <span class="hljs-string">本博客所有文章除特别声明外，均采用&quot;_blank&quot;</span> <span class="hljs-string">rel=&quot;noopener&quot;</span> <span class="hljs-string">href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot;&gt;CC</span> <span class="hljs-string">BY-NC-SA</span> <span class="hljs-number">4.0</span> <span class="hljs-string">协议。转载请注明出处！</span>  <br><span class="hljs-attr">style:</span> <span class="hljs-string">warning</span><br></code></pre></td></tr></table></figure><p><code>enable</code> 开起版权说明(默认开启)</p><p><code>writer</code> 作者id，如果不填则会使用主题配置 author 或站点配置 author</p><p><code>declare</code> 版权声明具体内容，支持 html 语句</p><p><code>style</code> 声明内容样式，与 note 样式相同</p><p>版权内容有三部分：作者、文章链接、版权声明</p><p>作者使用 writer 参数，文章链接基于站点配置文件中<code>url</code>参数生成，版权声明使用 declare 参数</p><h2 id="front-matter">Front-matter</h2><h3 id="banner_img">banner_img</h3><p>设置文章与首页头图</p><h3 id="banner_img_set">banner_img_set</h3><p>在图片加载时预先加载的图片，可以设置为 loading 图或缩略图等</p><h3 id="excerpt">excerpt</h3><p>为文章设置在首页显示的简介，还可以通过 ``来控制显示</p><h2 id="评论">评论</h2><p>支持 <code>valine</code>，<code>gitalk</code> 和 <code>livere</code></p><p>具体设置可参考主题配置文档说明和相关评论插件文档</p><h2 id="字数统计">字数统计</h2><p>主题集成 hexo-wordcount[27] 插件，在主题配置文件中设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wordcount:  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>开启(默认开启)</p><h2 id="图片画廊">图片画廊</h2><p>图片画廊功能基于 fslightbox[28]，在主题配置文件中设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">fslightbox:  <span class="hljs-built_in">enable</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>开启(默认开启)</p><h2 id="标签插件">标签插件</h2><p>主题集成了一些标签方便书写</p><h3 id="note">note</h3><p>在 <code>markdown</code> 文件中如下书写即可</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-template-variable">&#123;% note style %&#125;</span>...markdown content<span class="hljs-template-variable">&#123;% endnote %&#125;</span><br></code></pre></td></tr></table></figure><p>有五种样式可以选择，<code>primary</code>，<code>success</code>，<code>info</code>，<code>warning</code>，<code>danger</code></p><figure><img src="https://img-blog.csdnimg.cn/img_convert/5c542237bd770348639042e52cf53839.png" alt="5c542237bd770348639042e52cf53839.png" /><figcaption aria-hidden="true">5c542237bd770348639042e52cf53839.png</figcaption></figure><h2 id="备案信息">备案信息</h2><p>你可以在主题配置文件内增加备案信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">footer:</span>  <span class="hljs-comment">#------------------------  # 备案配置  # 请将公安备案的缩略图置于 $&#123;yoursite&#125;/img/beian.png  </span><br><span class="hljs-attr">RecordInfo:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># &#x27;某ICP备xxx号&#x27;  </span><br><span class="hljs-attr">govRecordInfo:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># &#x27;某公网安备xxx号&#x27;  </span><br><span class="hljs-attr">govRecordUrl:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 公网安备案信息地址  #------------------------</span><br></code></pre></td></tr></table></figure><h1 id="站点托管">站点托管</h1><h2 id="为什么选择-gitee-pages">为什么选择 Gitee Pages</h2><p>GitHub 和 Gitee 都提供免费的静态网页托管服务。我们可以使用 GitHub Pages 或 Gitee Pages 托管博客、项目官网等静态网页，这样就省去了购买服务器的钱，也不需要耗费太多精力维护。</p><p>GitHub Pages 使用很广泛，我之前也用过，不过访问不够稳定，会影响页面加载速度。Gitee 是国内版的 GitHub，访问速度优秀，并且国内发展势头不错，因此我选取 Gitee Pages 来托管我的网站。</p><h2 id="建立仓库">建立仓库</h2><p>申请一个 Gitee 账号，创建一个新的仓库，仓库名尽量和账号名一致，这样可以避免一些因为路径引发的问题。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/9595394417228d86e93a5ce6fde5de4a.png" alt="9595394417228d86e93a5ce6fde5de4a.png" /><figcaption aria-hidden="true">9595394417228d86e93a5ce6fde5de4a.png</figcaption></figure><p>然后在仓库首页服务一栏开启 Gitee Pages 服务。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/59923d4821997bb12cc44c9dbb35f7a9.png" alt="59923d4821997bb12cc44c9dbb35f7a9.png" /><figcaption aria-hidden="true">59923d4821997bb12cc44c9dbb35f7a9.png</figcaption></figure><p>开启后，你就拥有了专属的二级域名网址。</p><p><strong>注意：仓库内容有变化，需要手动触发更新，页面才能真正生效。</strong></p><h2 id="连接仓库">连接仓库</h2><p>一、安装 hexo-deployer-git [29]。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">npm install hexo-deployer-git <span class="hljs-attr">--save</span><br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/095c6e30d4719302062e52b459861c97.png" alt="095c6e30d4719302062e52b459861c97.png" /><figcaption aria-hidden="true">095c6e30d4719302062e52b459861c97.png</figcaption></figure><p>二、修改配置。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">deploy:  <span class="hljs-class"><span class="hljs-keyword">type</span></span>: git  repo: git<span class="hljs-meta">@gitee</span>.com:java4u/java4u.git<br></code></pre></td></tr></table></figure><p>注意上面的 repo 地址并不是仓库的地址，而是你下载/克隆项目时弹出的那个地址，type 如果是 git 就选择 SSH。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/c7c88f74cb218d639bd6c27adf10fb87.png" alt="c7c88f74cb218d639bd6c27adf10fb87.png" /><figcaption aria-hidden="true">c7c88f74cb218d639bd6c27adf10fb87.png</figcaption></figure><p>三、生成/添加 SSH 公钥</p><p>Gitee 、GitHub 提供了基于 SSH 协议的 Git 服务，在使用 SSH 协议访问仓库仓库之前，需要先配置好账户/仓库的 SSH 公钥。</p><p>先看下自己有没有配置过用户名和邮箱：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.namegit</span> config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span><br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/30e3abe4b021a3af90c7d30f51467e3f.png" alt="30e3abe4b021a3af90c7d30f51467e3f.png" /><figcaption aria-hidden="true">30e3abe4b021a3af90c7d30f51467e3f.png</figcaption></figure><p>如果没有就做下配置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"># 设置邮箱git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> *********<span class="hljs-keyword">@qq</span>.com# 设置用户名git config --global user.name <span class="hljs-string">&#x27;****&#x27;</span><br></code></pre></td></tr></table></figure><p>然后本地生成 SSH 公钥，邮箱为刚配置好的账户：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">ssh-keygen -t rsa -C yong__1994<span class="hljs-variable">@163</span>.com<br></code></pre></td></tr></table></figure><p>生成后可查看 SSH 公钥：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript">cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.<span class="hljs-property">pub</span><br></code></pre></td></tr></table></figure><p>复制公钥去 Gitee 粘贴，添加。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/69c118d18ad50558168a02ee80270d11.png" alt="69c118d18ad50558168a02ee80270d11.png" /><figcaption aria-hidden="true">69c118d18ad50558168a02ee80270d11.png</figcaption></figure><p>测试是否连接成功：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">ssh -T git<span class="hljs-variable">@gitee</span>.com<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/cd3be0a2772429c5fe9c5ff075fbbdc4.png" alt="cd3be0a2772429c5fe9c5ff075fbbdc4.png" /><figcaption aria-hidden="true">cd3be0a2772429c5fe9c5ff075fbbdc4.png</figcaption></figure><h2 id="上传仓库">上传仓库</h2><p>执行部署命令，即可将本地资源上传远程仓库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo d<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/img_convert/5c29ed57feeaad818b12bbe6bc221735.png" alt="5c29ed57feeaad818b12bbe6bc221735.png" /><figcaption aria-hidden="true">5c29ed57feeaad818b12bbe6bc221735.png</figcaption></figure><h2 id="手动更新">手动更新</h2><p>远程仓库虽然可以看到提交记录，但静态网站不会感知到实时变更，需要去 Gitee Pages 服务页面做下更新。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/391409895d9185cec0e434eb74fd67f7.png" alt="391409895d9185cec0e434eb74fd67f7.png" /><figcaption aria-hidden="true">391409895d9185cec0e434eb74fd67f7.png</figcaption></figure><p>稍等片刻，访问 https://java4u.gitee.io/ 即可看到 Hexo 结合 kaze 主题搭建的静态网站。点击文章底部「阅读原文」也可以直接访问。</p><figure><img src="https://img-blog.csdnimg.cn/img_convert/40914673c79669ba07d17b49c4626c89.png" alt="40914673c79669ba07d17b49c4626c89.png" /><figcaption aria-hidden="true">40914673c79669ba07d17b49c4626c89.png</figcaption></figure><h1 id="参考资料"><strong>参考资料</strong></h1><p>[1]Hexo: https://hexo.io/docs/</p><p>[2]git: https://git-scm.com/download/win</p><p>[3]Homebrew: https://brew.sh/</p><p>[4]官方安装程序: https://nodejs.org/en/download/</p><p>[5]nvs: https://github.com/jasongin/nvs/</p><p>[6]Homebrew: https://brew.sh/</p><p>[7]NodeSource: https://github.com/nodesource/distributions</p><p>[8]指南: https://nodejs.org/en/download/package-manager/</p><p>[9]EJS: https://ejs.co/</p><p>[10]Stylus: http://learnboost.github.io/stylus/</p><p>[11]Markdown: http://daringfireball.net/projects/markdown/</p><p>[12]时区列表: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</p><p>[13]永久链接: https://hexo.io/zh-cn/docs/permalinks</p><p>[14]permalink: https://hexo.io/zh-cn/docs/variables</p><p>[15]Asset 文件夹: https://hexo.io/zh-cn/docs/asset-folders</p><p>[16]Highlight.js: https://hexo.io/docs/syntax-highlight#Highlight-js</p><p>[17]PrismJS: https://hexo.io/docs/syntax-highlight#PrismJS</p><p>[18]Moment.js: http://momentjs.com/</p><p>[19]updated: https://hexo.io/zh-cn/docs/variables#页面变量</p><p>[20]Meta generator: https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#属性</p><p>[21]kaze: https://demo.theme-kaze.top/</p><p>[22]谷歌文档: https://analytics.google.com/</p><p>[23]iconfont: https://www.iconfont.cn/</p><p>[24]文档: https://hexo.io/docs/helpers#toc</p><p>[25]高亮文档: https://demo.theme-kaze.top/highlight/</p><p>[26]相关文档: https://demo.theme-kaze.top/latex/</p><p>[27]hexo-wordcount: https://github.com/willin/hexo-wordcount</p><p>[28]fslightbox: https://fslightbox.com/</p><p>[29]hexo-deployer-git: https://github.com/hexojs/hexo-deployer-git</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>静态博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Github Pages + Hexo搭建博客详细教程</title>
    <link href="/2022/08/30/hexo-tutorial/"/>
    <url>/2022/08/30/hexo-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="github-pages">Github Pages</h1><p>github pages 是github提供给用户用来展示个人或者项目主页的静态网页系统。每个用户都可以使用自己的github项目创建，上传静态页面的html文件，github会帮你自动更新你的页面。</p><p>操作如下：</p><ol type="1"><li>注册 Github 账号，然后在 Github 中创建一个以 .github.io 结尾的 Repository。<ul><li>Repository name: 自定义名字.github.io</li><li>勾选 Initialize this repository with a README</li><li>Create repository</li></ul></li><li>简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog… 保存(Commit changes)。</li><li>打开网页：你自定义的名字.github.io 这里就可以看到 README.md 里的内容了。 如果没有太多的要求，其实直接用README.md 来写博客也是不错的。</li></ol><p>这个生成好的 Repository 就是用来存放静态网页的地方，也只有这个仓库里的内容，才会被 <strong>simonhans.github.io</strong> 这个网页显示出来。</p><h1 id="hexo安装">Hexo安装</h1><p>Hexo 是一个博客框架。它把本地文件里的信息生成一个网页。如果不需要放在网上给别人看，就没 Github Pages 什么事了。</p><p>使用 Hexo 之前，需要先安装 Node.js 和 Git。</p><h2 id="安装-node.js">安装 Node.js</h2><ol type="1"><li><p>前往 https://nodejs.org/en/，点击 8.9.1 LTS 下载。安装(MacOS可以使用 <code>brew install node</code>)</p></li><li><p>打开 命令行终端， 输入 <code>node -v</code></p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ node -v<br>v12.16.1<br></code></pre></td></tr></table></figure><h2 id="安装-git">安装 Git</h2><p>略</p><h2 id="安装-hexo">安装 Hexo</h2><ol type="1"><li>打开 Command Prompt</li><li>输入 <code>npm install -g hexo-cli</code>回车开始安装</li><li>输入 <code>hexo -v</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo -v<br>hexo-cli: 4.2.0<br>os: Windows_NT 10.0.17134 win32 x64<br>node: 12.16.1<br>v8: 7.8.279.23-node.31<br>uv: 1.34.0<br>zlib: 1.2.11<br>brotli: 1.0.7<br>ares: 1.15.0<br>modules: 72<br>nghttp2: 1.40.0<br>napi: 5<br>llhttp: 2.0.4<br>http_parser: 2.9.3<br>openssl: 1.1.1d<br>cldr: 35.1<br>icu: 64.2<br>tz: 2019c<br>unicode: 12.1<br></code></pre></td></tr></table></figure><h2 id="创建本地博客">创建本地博客</h2><ol type="1"><li>在D盘下创建文件夹 blog</li><li>鼠标右键 blog，选择 Git Bash Here。 如果没有安装 Git，就不会有这个选项。</li><li>Git Bash 打开之后，所在的位置就是 blog 这个文件夹的位置。（/d/blog）</li><li>输入 <code>hexo init</code> 将 blog 文件夹初始化成一个博客文件夹，可能时间会有点长。</li><li>输入 <code>npm install</code> 安装依赖包。</li><li>输入 <code>hexo g</code> 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。</li><li>输入 <code>hexo s</code> 将生成的网页放在了本地服务器（server）。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br>INFO  Validating config<br>INFO  Start processing<br>INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li><p>http://localhost:4000/ 。 就可以看到刚才的成果了。</p></li><li><p>回到 Git Bash，按 Ctrl+C 结束，此时再看 http://localhost:4000/ 就是无法访问了。</p></li></ol><h1 id="hexo使用">Hexo使用</h1><p>Welcome to <a href="https://hexo.io/">Hexo</a>! （中文官网：<a href="https://hexo.io/zh-cn/">Hexo</a> ）Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><ol type="1"><li>Create a new post</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><ol start="2" type="1"><li>Run server</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><ol start="3" type="1"><li>Generate static files</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><ol start="4" type="1"><li>Deploy to remote sites</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>每次修改之后，使用下面命令重新部署：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure><p>推送过程中可能因为数据量大而失败，使用下面命令解决：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--global http.postBuffer 524288000</span><br></code></pre></td></tr></table></figure><p>（将 buffer 增加到 500MB）</p><h2 id="发布一篇博客">发布一篇博客</h2><ol type="1"><li>在 Git Bash 里，所在路径还是 /d/blog。输入 <code>hexo new “My First Post”</code></li><li>在 D:_posts 路径下，会有一个 My-First-Post.md 的文件。 编辑这个文件，然后保存。</li><li>回到 Git Bash，输入 <code>hexo g</code></li><li>输入 <code>hexo s</code></li><li>前往 http://localhost:4000/ 查看成果。 <img src="https://cdn.spphoto.top/img/20250710232040.png" alt="在这里插入图片描述" /></li></ol><h2 id="更换主题">更换主题</h2><p>嫌弃自带的主题，可以用官网的一些<a href="https://hexo.io/themes/">优秀主题模板</a>，当然有能力也可以按官网文档来自定义</p><p>以<a href="https://github.com/fluid-dev/hexo-theme-fluid">hexo-theme-fluid</a>主题为例</p><ol type="1"><li>下载主题，在git bash中博客根目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>修改_config.yml中的theme: landscape改为theme: fluid，然后重新执行<code>hexo g</code>来重新生成</p></li><li><p>输入 <code>hexo clean &amp;&amp; hexo s</code> (或者<code>hexo cl</code>—清除缓存 )启动项目</p></li></ol><p>详细参考主题README.md文档：<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p><h2 id="将本地-hexo-博客部署在-github-上">将本地 Hexo 博客部署在 Github 上</h2><p>前面两个部分，我们已经有了本地博客，和一个能托管这些资料的线上仓库。只要把本地博客部署（deploy）在我们的 Github 对应的 Repository 就可以了。</p><p>操作如下：</p><ol type="1"><li><p>获取 Github 对应的 Repository 的链接。</p></li><li><p>登陆 Github，进入到 ryanluoxu.github.io</p></li><li><p>点击 Clone or download</p></li><li><p>复制 URL,我的是 https://github.com/Simonhans/simonhans.github.io.git</p></li><li><p>修改博客的配置文件</p><p>打开本地博客路径下blog/_config.yml （使用 bash 里的 vi 或者 notepad++）找到 <code>#Deployment</code>，填入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repository: https://github.com/Simonhans/simonhans.github.io.git<br>  branch: master<br></code></pre></td></tr></table></figure></li><li><p>部署，回到 Git Bash，需要先安装<code>hexo-deployer-git</code>插件</p></li><li><p>回到 Git Bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>输入 <code>hexo d</code></p></li><li><p>得到 INFO Deploy done: git 即为部署成功</p></li><li><p>查看成果，https://simonhans.github.io</p></li></ol><h1 id="域名绑定js.org">域名绑定js.org</h1><p>可以申请自己域名来绑定自己的博客地址https://simonhans.github.io，博主这里用的js.org免费二级域名</p><p>很多知名项目会把自己的文档托管在 .js.org 域名下面，作为开发者，拥有一个是一件很酷的事。官网：<a href="https://js.org/">jsorg</a></p><figure><img src="https://cdn.spphoto.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxMzEwNQ==,size_16,color_FFFFFF,t_70-20250710234243907.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ol type="1"><li>在你的github pages里的博客项目下新建CNAME文件，内容为你需要申请的js.org域名，例如：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">simonhans.js.org<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><p>此时你再访问之前你的XXX.github.io已经无法访问并跳转到了CNAME文件里面的网址。使用过域名解析的都知道，目前只是单方面绑定了，js.org那边还没绑定你的地址</p></li><li><p>进入js.org官方仓库：https://github.com/js-org/js.org 点击右上角的fork，你会发现这个仓库被fork到自己名下了。</p><figure><img src="https://cdn.spphoto.top/img/20201028120351288.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure></li><li><p>修改fork过来的仓库中<code>cnames_active.js</code>文件，注意他是按照字母排序的，请找到相应位置写入。例如：</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-string">&quot;simonhans&quot;</span>: <span class="hljs-string">&quot;simonhans.github.io&quot;</span>,<br></code></pre></td></tr></table></figure><p>前部分表示你要申请的二级域名，也就是之前说的XXX，后部分表示你的GitHub仓库名</p><ol start="5" type="1"><li>回到你fork的仓库，点击Pull Request，并提交它。然后就是等待审核</li><li>审核通过你会收到下图所示邮件： <img src="https://cdn.spphoto.top/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxMzEwNQ==,size_16,color_FFFFFF,t_70-20250710234320465.png" alt="在这里插入图片描述" /></li><li>通过后不要着急，人家只是通过了你的申请，但是还没给你解析呢，解析后会收到下图所示邮件： <img src="https://cdn.spphoto.top/img/20201028122330166-20250711000203893.png" alt="在这里插入图片描述" /></li><li>现在就可以用你申请的域名访问你的博客了，我的博客: <img src="https://cdn.spphoto.top/img/watermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzcxMzEwNQ%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70-20250710234350104.png" alt="在这里插入图片描述" /></li></ol><p>但是现在js.org已经不支持个人博客了。我们可以自己购买一个域名进行绑定。</p><h1 id="配置个人域名">配置个人域名</h1><h2 id="申请域名">申请域名</h2><p>这里就不介绍了，详情百度，建议阿里云购买，腾讯云也可以</p><p>如果有域名了就不多说了。这里就直接去购买域名的地方去解析域名</p><h2 id="解析域名">解析域名</h2><p>如果没有实名记得实名</p><p>打开购买域名的网址，这里我就使用阿里云做演示。</p><p>我是在阿里云购买的域名，这里以阿里云的操作为例，登陆阿里云，依次进入<code>控制台-万网-域名</code> 找到已购买的域名点击解析按钮，添加三项解析</p><figure><img src="https://cdn.spphoto.top/img/5615781-03cc818f75427083.webp" alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>前两项是Github Pages绑定域名教程里提示添加的；</p><blockquote><p>Custom domain</p><p>Custom domains allow you to serve your site from a domain other than <code>hswsp.github.io</code>. <a href="https://docs.github.com/articles/using-a-custom-domain-with-github-pages/">Learn more</a>.</p></blockquote><p>点击 Learn more:</p><blockquote><p>Navigate to your DNS provider and create either an <code>ALIAS</code>, <code>ANAME</code>, or <code>A</code> record. You can also create <code>AAAA</code> records for IPv6 support. For more information about how to create the correct record, see your DNS provider's documentation.</p><ul><li><p>To create an <code>ALIAS</code> or <code>ANAME</code> record, point your apex domain to the default domain for your site. For more information about the default domain for your site, see "<a href="https://docs.github.com/en/articles/about-github-pages#types-of-github-pages-sites">About GitHub Pages</a>."</p></li><li><p>To create<code>A</code>records, point your apex domain to the IP addresses for GitHub Pages.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">185.199.108.153<br>185.199.109.153<br>185.199.110.153<br>185.199.111.153<br></code></pre></td></tr></table></figure></li></ul></blockquote><p>就把这几项配到A record里面。</p><p>后一项是为了绑定www,注意添加的时候不要忘了最后面的那个"点" 即 hswsp.github.io.</p><h2 id="cname配置">CNAME配置</h2><p>进入设置，找到 Custom domain添加域名后保存即可，它会自动在你的repository相应的branch里生成一个CNAME的文件。</p><figure><img src="https://cdn.spphoto.top/img/webp" alt="image" /><figcaption aria-hidden="true">image</figcaption></figure><p>但是由于是静态博客，每次Hexo都会重新把之前的所有内容删除重写。所以我们需要把这个CNAME写到我们的Hexo源文件里。</p><p>桌面新建CNAME文件，不要后缀。在该文件里写入你的域名。例如我的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yuxiaoshao.top<br></code></pre></td></tr></table></figure><p>把cname放入博客根目录的source文件夹下，然后hexo cl，hexo g,hexo deploy</p><p>之后就可以通过域名访问了</p><h2 id="https支持配置">https支持配置</h2><p>下面进行GitHub的设置，打开GitHub仓库的settings，在custom domain 中填上刚申请的域名（如果是用namecheap的域名，GitHub Pages会自动填充域名），勾选enforce https，使能https支持，如下图所示。</p><figure><img src="https://cdn.spphoto.top/img/2787497-03fa5a9ab8194014.webp" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>最后，别忘记修<code>_config.yml</code>里配置的<code>url</code>！！！！</strong></p><h1 id="配置七牛云图床">配置七牛云图床</h1><ol type="1"><li><p>创建七牛云存储空间</p><figure><img src="https://cdn.spphoto.top/img/6c4fcf368c805a142c67076eef32a3e1.png" alt="image-20220330002946984" /><figcaption aria-hidden="true">image-20220330002946984</figcaption></figure></li><li><p>给自己的域名添加二级域名</p><blockquote><p>这里用阿里云的举例</p></blockquote></li></ol><p>进入<a href="https://dc.console.aliyun.com/next/index?#/domain-list/all">阿里云域名列表</a></p><p>选择解析</p><figure><img src="https://cdn.spphoto.top/img/0747689e1cdc2205b238140aa93e8416.png" alt="image-20220330003123314" /><figcaption aria-hidden="true">image-20220330003123314</figcaption></figure><p>然后添加一个二级域名，这个完了先不要关，等下还要改</p><figure><img src="https://cdn.spphoto.top/img/8de4e1820d58da359b6b48fada2b63ce.png" alt="image-20220330003356467" /><figcaption aria-hidden="true">image-20220330003356467</figcaption></figure><ol start="3" type="1"><li>绑定二级域名</li></ol><p>进入<a href="https://portal.qiniu.com/cdn/domain">七牛云域名绑定页面</a>，点击添加域名，然后下图只需要把刚刚配置的域名写上，然后其余默认就行，点击创建</p><figure><img src="https://cdn.spphoto.top/img/66cd88be1aa780a8fda147c1faea7b51.png" alt="image-20220330003544871" /><figcaption aria-hidden="true">image-20220330003544871</figcaption></figure><p>这里由于是github.io，没有进行备案，只能申请海外服务器。同时在绑定域名后会让你进行TXT记录验证。输入它给的主机名和主机值新增一条域名解析即可。</p><p>然后回到上一个页面，跟着下图操作</p><figure><img src="https://cdn.spphoto.top/img/61f324a844768635a01bb06b50866447.png" alt="image-20220330003733736" /><figcaption aria-hidden="true">image-20220330003733736</figcaption></figure><figure><img src="https://cdn.spphoto.top/img/4699773498babd6a54a6016f80e908e1.png" alt="image-20220330003847097" /><figcaption aria-hidden="true">image-20220330003847097</figcaption></figure><figure><img src="https://cdn.spphoto.top/img/4699773498babd6a54a6016f80e908e1-20250711002202305.png" alt="image-20220330003847097" /><figcaption aria-hidden="true">image-20220330003847097</figcaption></figure><p>然后回到刚刚添加域名的页面，点击刚刚添加的域名，把www.baidu.com改成刚刚复制的东西</p><p>配置完了之后等一会，系统审核完成后会发邮件，等状态变成成功说明配置完成了</p><ol start="4" type="1"><li>配置PicGO</li></ol><p>进入七牛云页面，右上角头像-&gt;密钥管理-&gt;复制 AccessKey和SecretKey到PicGo中，</p><ul><li>存储空间名是你第二步建立的空间的名字</li><li>网址是刚刚绑定的那个二级域名。注意加上http。</li><li>存储区域：七牛云的存储区域（华东 z0，华北 z1，华南 z2，北美 na0，东南亚 as0 ），根据你空间所在的区域，填对应的代码</li></ul><figure><img src="https://cdn.spphoto.top/img/842bafe5e6389bee18752ec69c1a7930.png" alt="image-20220330004201058" /><figcaption aria-hidden="true">image-20220330004201058</figcaption></figure><h1 id="ssl免费证书申请">ssl免费证书申请</h1><p>但是，hexo使用七牛图床 放到github pages上无法显示。问题的根源在于 谷歌浏览器 ， 在https的网站里面放http格式的图片，那么http的链接会被自动转为https，从而导致找不到链接，会显示叉叉。</p><p>故而在七牛云申请一个免费的SSL证书。<strong>在ssl证书服务中选择购买证书，选择免费的TrustAsia证书</strong>。</p><figure><img src="https://cdn.spphoto.top/img/8b5962587655cdfbe59cb805083481abb2e.jpg" alt="8b5962587655cdfbe59cb805083481abb2e.jpg" /><figcaption aria-hidden="true">8b5962587655cdfbe59cb805083481abb2e.jpg</figcaption></figure><p><strong>核对信息，确认支付即可</strong></p><figure><img src="https://cdn.spphoto.top/img/ba24df3b5b7785726ee3a084c73ebfb7929.jpg" alt="ba24df3b5b7785726ee3a084c73ebfb7929.jpg" /><figcaption aria-hidden="true">ba24df3b5b7785726ee3a084c73ebfb7929.jpg</figcaption></figure><p><strong>补全相关信息</strong></p><figure><img src="https://cdn.spphoto.top/img/4f66317234eb658ca59865dbdb9e5fc2258-20250711002954633.jpg" alt="4f66317234eb658ca59865dbdb9e5fc2258.jpg" /><figcaption aria-hidden="true">4f66317234eb658ca59865dbdb9e5fc2258.jpg</figcaption></figure><p>具体参见<a href="https://developer.qiniu.com/ssl/3667/ssl-certificate-of-free-dns-validation-guide">证书申请指南</a></p><h1 id="创建相册页面">创建相册页面</h1><p>新建相册页 <code>hexo new page photos</code>,编辑 <code>/source/photos/index.md</code>，输入以下内容：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: photos<br>date: 2020-12-30 19:04:03<br><span class="hljs-section">layout: photo</span><br><span class="hljs-section">---</span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span></span><br>.ImageGrid &#123;<br>  width: 100%;<br>  max-width: 1040px;<br>  margin: 0 auto;<br>  text-align: center;<br>&#125;<br>.card &#123;<br>  overflow: hidden;<br>  transition: .3s ease-in-out;<br>  border-radius: 8px;<br>  background-color: #efefef;<br>  padding: 1.4px;<br>&#125;<br>.ImageInCard img &#123;<br>  padding: 0;<br>  border-radius: 8px;<br>  width:100%;<br>  height:100%;<br>&#125;<br>@media (prefers-color-scheme: dark) &#123;<br>  .card &#123;background-color: #333;&#125;<br>&#125;<br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;imageTab&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ImageGrid&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><br><br>HTML<br></code></pre></td></tr></table></figure><h2 id="处理图片信息">处理图片信息</h2><p>为了加快图片的加载速度,我使用<code>GitHub</code> +<code>jsDelivr</code>的方式，<strong>网上有许多的教程，此处不再演示。</strong></p><p>这里在Github上创建了一个Repository用来做图床。文件夹结构如图:</p><figure><img src="https://cdn.spphoto.top/img/Screenshot%202025-07-10%20at%2011.57.12%E2%80%AFPM.png" alt="Screenshot 2025-07-10 at 11.57.12 PM" /><figcaption aria-hidden="true">Screenshot 2025-07-10 at 11.57.12 PM</figcaption></figure><p>这样<code>jsDelivr</code>这种CDN生成的图片链接就是按<code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code>格式给出的。</p><p>我们需要列出这些图片链接的基本信息，这里主要是使用<code>image-size</code>访问照片文件夹，获取每张照片的大小和文件名，并生成对应的 <code>json</code> 文件.</p><p>creata.js文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs-extra&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> imageSize = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;image-size&#x27;</span>);<br><br><span class="hljs-keyword">const</span> rootPath=<span class="hljs-string">&quot;./&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhotoExtension</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = <span class="hljs-number">64</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">offset</span> = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Photo</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">dirName</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fileName</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">iconID</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">extension</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhotoExtension</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhotoGroup</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">children</span> = [];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createPlotIconsData</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> allPlots = [];<br>    <span class="hljs-keyword">let</span> allPlotGroups = [];<br><br>    <span class="hljs-keyword">const</span> plotJsonFile = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./photosInfo.json&#x27;</span>);<br>    <span class="hljs-keyword">const</span> plotGroupJsonFile = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;./photos.json&#x27;</span>);<br><br>    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(plotJsonFile)) &#123;<br>        allPlots = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(plotJsonFile));<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fs.<span class="hljs-title function_">existsSync</span>(plotGroupJsonFile)) &#123;<br>        allPlotGroups = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(fs.<span class="hljs-title function_">readFileSync</span>(plotGroupJsonFile));<br>    &#125;<br><br>    fs.<span class="hljs-title function_">readdirSync</span>(__dirname).<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">dirName</span>) &#123;<br>        <span class="hljs-keyword">const</span> stats = fs.<span class="hljs-title function_">statSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, dirName));<br>        <span class="hljs-keyword">const</span> isDir = stats.<span class="hljs-title function_">isDirectory</span>();<br>        <span class="hljs-keyword">if</span> (isDir) &#123;<br>            <span class="hljs-keyword">const</span> subfiles = fs.<span class="hljs-title function_">readdirSync</span>(path.<span class="hljs-title function_">join</span>(__dirname, dirName));<br>            subfiles.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">subfileName</span>) &#123;<br>                <span class="hljs-comment">// 如果已经存在 则不再处理</span><br>                <span class="hljs-comment">// if (allPlots.find(o =&gt; o.fileName === subfileName &amp;&amp; o.dirName === dirName)) &#123;</span><br>                <span class="hljs-comment">//     return;</span><br>                <span class="hljs-comment">// &#125;</span><br><br>                <span class="hljs-comment">// 新增标</span><br>                <span class="hljs-keyword">const</span> plot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Photo</span>();<br>                plot.<span class="hljs-property">dirName</span> = dirName;<br>                plot.<span class="hljs-property">fileName</span> = subfileName;<br>                <span class="hljs-keyword">const</span> imageInfo = <span class="hljs-title function_">imageSize</span>(rootPath+dirName + <span class="hljs-string">&quot;/&quot;</span> + subfileName);<br>                plot.<span class="hljs-property">iconID</span> = imageInfo.<span class="hljs-property">width</span> + <span class="hljs-string">&#x27;.&#x27;</span> + imageInfo.<span class="hljs-property">height</span> + <span class="hljs-string">&#x27; &#x27;</span> + subfileName;<br>                allPlots.<span class="hljs-title function_">push</span>(plot);<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`RD: createPlotIconsData -&gt; new plot`</span>, plot);<br><br>                <span class="hljs-comment">// 为新增标添加分组 暂时以它所处的文件夹为分组</span><br>                <span class="hljs-keyword">let</span> group = allPlotGroups.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">o</span> =&gt;</span> o.<span class="hljs-property">name</span> === dirName);<br>                <span class="hljs-keyword">if</span> (!group) &#123;<br>                    group = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhotoGroup</span>();<br>                    group.<span class="hljs-property">name</span> = dirName;<br>                    allPlotGroups.<span class="hljs-title function_">push</span>(group);<br>                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`RD: createPlotIconsData -&gt; new group`</span>, group);<br>                &#125;<br>                group.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(plot.<span class="hljs-property">iconID</span>);<br>            &#125;);<br>        &#125;<br>    &#125;);<br><br>    fs.<span class="hljs-title function_">writeJSONSync</span>(plotJsonFile, allPlots);<br>    fs.<span class="hljs-title function_">writeJSONSync</span>(plotGroupJsonFile, allPlotGroups);<br>&#125;<br><br><span class="hljs-title function_">createPlotIconsData</span>();<br></code></pre></td></tr></table></figure><p><code>npm i -S image-size</code>安装之后,把照片放在目录后，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node gallery/create.js<br></code></pre></td></tr></table></figure><p>如果报错，请注意检查保存本地照片的文件夹里有没有非图片类文件，特别是要删除如 <code>.DS_Store</code> 这样的隐藏文件。注意每次添加照片重新生成文件信息的时候需要把之前的删除再运行脚本，因为这个脚本写文件是往后续写的，不是删除之前的photos.json再重写的！！</p><p><code>json</code> 文件样例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;广州一游&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;1080.1440 圣心大教堂.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1080.1440 广州塔顶夜晚景色.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1080.1440 广州塔顶夜晚景色2.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1080.1440 晚上广州塔.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1080.1443 白天广州塔.jpg&quot;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;澳门游玩&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;children&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>      <span class="hljs-string">&quot;1080.1443 夜晚澳门巴黎铁塔.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1443.1080 微信图片_20210108213615.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1443.1080 微信图片_20210108213635.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1443.1080 微信图片_20210108213645.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1443.1080 微信图片_20210108213707.jpg&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-string">&quot;1080.1443 白天澳门巴黎铁塔.jpg&quot;</span><br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p>将<code>photos.json</code>拷贝到博客目录下的<code>photos</code></p><figure><img src="https://cdn.spphoto.top/img/Screenshot%202025-07-11%20at%2012.05.13%E2%80%AFAM.png" alt="Screenshot 2025-07-11 at 12.05.13 AM" /><figcaption aria-hidden="true">Screenshot 2025-07-11 at 12.05.13 AM</figcaption></figure><h2 id="加载-js和css文件">加载 js和css文件</h2><p>在 <code>/source/js/</code> 目录下创建 <code>photoWall.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> imgDataPath = <span class="hljs-string">&quot;/photos/photos.json&quot;</span>; <span class="hljs-comment">//图片名称高宽信息json文件路径，就是访问你博客图片页的路径</span><br><span class="hljs-keyword">var</span> imgPath = <span class="hljs-string">&quot;https://cdn.jsdelivr.net/gh/Cenergy/images/gallery/&quot;</span>; <span class="hljs-comment">//图片访问路径</span><br><span class="hljs-keyword">var</span> imgMaxNum = <span class="hljs-number">50</span>; <span class="hljs-comment">//图片显示数量</span><br><br><span class="hljs-keyword">var</span> windowWidth =<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> ||<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span> ||<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">clientWidth</span>;<br><span class="hljs-keyword">if</span> (windowWidth &lt; <span class="hljs-number">768</span>) &#123;<br>  <span class="hljs-keyword">var</span> imageWidth = <span class="hljs-number">145</span>; <span class="hljs-comment">//图片显示宽度(手机端)</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">var</span> imageWidth = <span class="hljs-number">250</span>; <span class="hljs-comment">//图片显示宽度</span><br>&#125;<br><br><span class="hljs-keyword">const</span> photo = &#123;<br>  <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">offset</span>: imgMaxNum,<br>  <span class="hljs-attr">init</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-variable language_">this</span>;<br>    $.<span class="hljs-title function_">getJSON</span>(imgDataPath, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>      that.<span class="hljs-title function_">render</span>(that.<span class="hljs-property">page</span>, data);<br>      <span class="hljs-comment">//that.scroll(data);</span><br>      that.<span class="hljs-title function_">eventListen</span>(data);<br>    &#125;);<br>  &#125;,<br>  <span class="hljs-title function_">constructHtml</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>      imageWidth,<br>      imageX,<br>      imageY,<br>      name,<br>      imgPath,<br>      imgName,<br>      imgNameWithPattern,<br>    &#125; = options;<br>    <span class="hljs-keyword">const</span> htmlEle = <span class="hljs-string">`&lt;div class=&quot;card lozad&quot; style=&quot;width:<span class="hljs-subst">$&#123;imageWidth&#125;</span>px&quot;&gt;</span><br><span class="hljs-string">                  &lt;div class=&quot;ImageInCard&quot; style=&quot;height:<span class="hljs-subst">$&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">                    (imageWidth * imageY) / imageX</span></span><br><span class="hljs-subst"><span class="hljs-string">                  &#125;</span>px&quot;&gt;</span><br><span class="hljs-string">                    &lt;a data-fancybox=&quot;gallery&quot; href=&quot;<span class="hljs-subst">$&#123;imgPath&#125;</span><span class="hljs-subst">$&#123;name&#125;</span>/<span class="hljs-subst">$&#123;imgNameWithPattern&#125;</span>&quot;</span><br><span class="hljs-string">                          data-caption=&quot;<span class="hljs-subst">$&#123;imgName&#125;</span>&quot; title=&quot;<span class="hljs-subst">$&#123;imgName&#125;</span>&quot;&gt;</span><br><span class="hljs-string">                            &lt;img  class=&quot;lazyload&quot; data-src=&quot;<span class="hljs-subst">$&#123;imgPath&#125;</span><span class="hljs-subst">$&#123;name&#125;</span>/<span class="hljs-subst">$&#123;imgNameWithPattern&#125;</span>&quot;</span><br><span class="hljs-string">                            src=&quot;data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==&quot;</span><br><span class="hljs-string">                            onload=&quot;lzld(this)&quot;</span><br><span class="hljs-string">                            lazyload=&quot;auto&quot;&gt;</span><br><span class="hljs-string">                        &lt;/a&gt;</span><br><span class="hljs-string">                  &lt;/div&gt;</span><br><span class="hljs-string">                &lt;/div&gt;`</span>;<br>    <span class="hljs-keyword">return</span> htmlEle;<br>  &#125;,<br>  <span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">page, data = []</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">data</span> = data;<br>    <span class="hljs-keyword">if</span> (!data.<span class="hljs-property">length</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">var</span> html,<br>      imgNameWithPattern,<br>      imgName,<br>      imageSize,<br>      imageX,<br>      imageY,<br>      li = <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-keyword">let</span> liHtml = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">let</span> contentHtml = <span class="hljs-string">&quot;&quot;</span>;<br><br>    data.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> activeClass = index === <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;active&quot;</span> : <span class="hljs-string">&quot;&quot;</span>;<br>      liHtml += <span class="hljs-string">`&lt;li class=&quot;nav-item&quot; role=&quot;presentation&quot;&gt;</span><br><span class="hljs-string">          &lt;a class=&quot;nav-link <span class="hljs-subst">$&#123;activeClass&#125;</span> photo-tab&quot; id=&quot;home-tab&quot; photo-uuid=&quot;<span class="hljs-subst">$&#123;item.name&#125;</span>&quot; data-toggle=&quot;tab&quot; href=&quot;#<span class="hljs-subst">$&#123;item.name&#125;</span>&quot;  role=&quot;tab&quot; aria-controls=&quot;<span class="hljs-subst">$&#123;item.name&#125;</span>&quot; aria-selected=&quot;true&quot;&gt;<span class="hljs-subst">$&#123;item.name&#125;</span>&lt;/a&gt;</span><br><span class="hljs-string">        &lt;/li&gt;`</span>;<br>    &#125;);<br>    <span class="hljs-keyword">const</span> [initData = &#123;&#125;] = data;<br>    <span class="hljs-keyword">const</span> &#123; children = [],name &#125; = initData;<br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>      imgNameWithPattern = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>];<br>      imgName = imgNameWithPattern.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>      imageSize = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>];<br>      imageX = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>      imageY = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>];<br>      <span class="hljs-keyword">let</span> imgOptions = &#123;<br>        imageWidth,<br>        imageX,<br>        imageY,<br>        name,<br>        imgName,<br>        imgPath,<br>        imgNameWithPattern,<br>      &#125;;<br>      li += <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">constructHtml</span>(imgOptions);<br>    &#125;);<br>    contentHtml += <span class="hljs-string">` &lt;div class=&quot;tab-pane fade show active&quot;  role=&quot;tabpanel&quot; aria-labelledby=&quot;home-tab&quot;&gt;<span class="hljs-subst">$&#123;li&#125;</span>&lt;/div&gt;`</span>;<br><br>    <span class="hljs-keyword">const</span> ulHtml = <span class="hljs-string">`&lt;ul class=&quot;nav nav-tabs&quot; id=&quot;myTab&quot; role=&quot;tablist&quot;&gt;<span class="hljs-subst">$&#123;liHtml&#125;</span>&lt;/ul&gt;`</span>;<br>    <span class="hljs-keyword">const</span> tabContent = <span class="hljs-string">`&lt;div class=&quot;tab-content&quot; id=&quot;myTabContent&quot;&gt;<span class="hljs-subst">$&#123;contentHtml&#125;</span>&lt;/div&gt;`</span>;<br><br>    $(<span class="hljs-string">&quot;#imageTab&quot;</span>).<span class="hljs-title function_">append</span>(ulHtml);<br>    $(<span class="hljs-string">&quot;.ImageGrid&quot;</span>).<span class="hljs-title function_">append</span>(tabContent);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">minigrid</span>();<br>  &#125;,<br>  <span class="hljs-attr">eventListen</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-keyword">let</span> self = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">var</span> html,<br>      imgNameWithPattern,<br>      imgName,<br>      imageSize,<br>      imageX,<br>      imageY,<br>      li = <span class="hljs-string">&quot;&quot;</span>;<br>    $(<span class="hljs-string">&#x27;a[data-toggle=&quot;tab&quot;]&#x27;</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;shown.bs.tab&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>      $(<span class="hljs-string">&quot;.ImageGrid&quot;</span>).<span class="hljs-title function_">empty</span>();<br>      <span class="hljs-keyword">const</span> selectId = $(e.<span class="hljs-property">target</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;photo-uuid&quot;</span>);<br>      <span class="hljs-keyword">const</span> selectedData = data.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> data.<span class="hljs-property">name</span> === selectId) || &#123;&#125;;<br>      <span class="hljs-keyword">const</span> &#123; children,name &#125; = selectedData;<br>      <span class="hljs-keyword">let</span> li = <span class="hljs-string">&quot;&quot;</span>;<br>      children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>        imgNameWithPattern = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>];<br>        imgName = imgNameWithPattern.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>        imageSize = item.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">0</span>];<br>        imageX = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>];<br>        imageY = imageSize.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> imgOptions = &#123;<br>          imageWidth,<br>          imageX,<br>          imageY,<br>          name,<br>          imgName,<br>          imgPath,<br>          imgNameWithPattern,<br>        &#125;;<br>        li += self.<span class="hljs-title function_">constructHtml</span>(imgOptions);<br>      &#125;);<br>      $(<span class="hljs-string">&quot;.ImageGrid&quot;</span>).<span class="hljs-title function_">append</span>(li);<br>      self.<span class="hljs-title function_">minigrid</span>();<br>    &#125;);<br>  &#125;,<br>  <span class="hljs-attr">minigrid</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Minigrid</span>(&#123;<br>      <span class="hljs-attr">container</span>: <span class="hljs-string">&quot;.ImageGrid&quot;</span>,<br>      <span class="hljs-attr">item</span>: <span class="hljs-string">&quot;.card&quot;</span>,<br>      <span class="hljs-attr">gutter</span>: <span class="hljs-number">12</span>,<br>    &#125;);<br>    grid.<span class="hljs-title function_">mount</span>();<br>    $(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">resize</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      grid.<span class="hljs-title function_">mount</span>();<br>    &#125;);<br>  &#125;,<br>&#125;;<br>photo.<span class="hljs-title function_">init</span>();<br></code></pre></td></tr></table></figure><p>然后使用注册器将需要的<code>js</code>,<code>css</code>注入,在<code>scripts/injector.js</code>(如没有,则创建)中输入以下内容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">root</span>: siteRoot = <span class="hljs-string">&quot;/&quot;</span> &#125; = hexo.<span class="hljs-property">config</span>;<br><span class="hljs-comment">// layout为photo的时候导入这些js与css</span><br>hexo.<span class="hljs-property">extend</span>.<span class="hljs-property">injector</span>.<span class="hljs-title function_">register</span>(<br>  <span class="hljs-string">&quot;body_end&quot;</span>,<br>  <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css&quot;&gt;</span><br><span class="hljs-string">  &lt;script src=&quot;//cdn.jsdelivr.net/npm/minigrid@3.1.1/dist/minigrid.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">  &lt;script src=&quot;https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/lazyloadjs/3.2.2/lazyload.js&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-string">    &lt;script defer src=&quot;<span class="hljs-subst">$&#123;siteRoot&#125;</span>js/photoWall.js&quot;&gt;&lt;/script&gt;`</span>,<br>  <span class="hljs-string">&quot;photo&quot;</span><br>);<br></code></pre></td></tr></table></figure><p>至此,已经能看到加载出图片了,但是假如不使用cdn或者其他懒加载策略的话会感觉很慢!!</p><h1 id="参考">参考</h1><blockquote><ol type="1"><li>https://hexo.io/themes/</li><li>https://github.com/blinkfox/hexo-theme-matery</li><li>https://oujun.work/2021/08/01/Hexo-Theme-Fluid-Add-Gallery.html</li><li>https://juejin.cn/post/6891086750484004877</li><li><a href="https://daocaisheng.github.io/2021/10/08/guan-yu-gei-hexo-bo-ke-zeng-jia-xiang-ce-ye-mian-shi-xian-pu-bu-liu-xiang-ce-shi-xian-jia-mi-xiang-ce/">关于给hexo博客增加相册页面（实现瀑布流相册，实现加密相册）</a></li><li>https://blog.dlzhang.com/posts/31/</li><li><a href="https://pinlyu.com/post/31/">Hexo NexT 博客增加瀑布流相册页面</a></li><li><a href="https://emoryhuang.cn/blog/1729600336.html">Hexo + Fluid 美化</a></li><li><a href="https://renzibei.com/2020/07/12/%E4%BD%BF%E7%94%A8jsdelivr-CDN-%E5%8A%A0%E9%80%9Fhexo%E7%9A%84%E5%9B%BE%E7%89%87%E7%AD%89%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/">自动使用jsdelivr CDN 加速hexo的图片等静态资源加载</a></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>静态博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker上使用nginx</title>
    <link href="/2022/03/07/docker%E4%B8%8A%E4%BD%BF%E7%94%A8nginx-docker-shang-shi-yong-nginx/"/>
    <url>/2022/03/07/docker%E4%B8%8A%E4%BD%BF%E7%94%A8nginx-docker-shang-shi-yong-nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="docker上启动nginx">docker上启动nginx</h1><h2 id="查看可用的-nginx-版本">1、查看可用的 Nginx 版本</h2><p>访问 Nginx 镜像库地址： https://hub.docker.com/_/nginx?tab=tags。</p><p>可以通过 Sort by 查看其他版本的 Nginx，默认是最新版本 <strong>nginx:latest</strong>。</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx1.png"><img src="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx1.png" alt="img" /></a></p><p>你也可以在下拉列表中找到其他你想要的版本：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx2.png"><img src="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx2.png" alt="img" /></a></p><p>此外，我们还可以用 <strong>docker search nginx</strong> 命令来查看可用版本：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">$ docker search nginx<br>NAME                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>nginx                     Official build <span class="hljs-keyword">of</span> Nginx.                        3260      <span class="hljs-comment">[OK]</span>       <br>jwilder/nginx-proxy       Automated Nginx reverse proxy for docker c...   674                  <span class="hljs-comment">[OK]</span><br>richarvey/nginx-php-fpm   <span class="hljs-keyword">Container</span> running Nginx + PHP-FPM capable ...   207                  <span class="hljs-comment">[OK]</span><br>million12/nginx-php       Nginx + PHP-FPM 5.5, 5.6, 7.0 (NG), CentOS...   67                   <span class="hljs-comment">[OK]</span><br>maxexcloo/nginx-php       Docker framework <span class="hljs-keyword">container</span> with Nginx and ...   57                   <span class="hljs-comment">[OK]</span><br>...<br></code></pre></td></tr></table></figure><h2 id="取最新版的-nginx-镜像">2、取最新版的 Nginx 镜像</h2><p>这里我们拉取官方的最新版本的镜像：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>docker pull <span class="hljs-symbol">nginx:</span>latest<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx3.png"><img src="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx3.png" alt="img" /></a></p><h2 id="查看本地镜像">3、查看本地镜像</h2><p>使用以下命令来查看是否已安装了 nginx：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>docker images<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx4.png"><img src="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx4.png" alt="img" /></a></p><p>在上图中可以看到我们已经安装了最新版本（latest）的 nginx 镜像。</p><h2 id="运行容器">4、运行容器</h2><p>安装完成后，我们可以使用以下命令来运行 nginx 容器：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ docker <span class="hljs-built_in">run</span> <span class="hljs-comment">--name nginx-test -p 8080:80 -d nginx</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>--name nginx-test</strong>：容器名称。</li><li><strong>-p 8080:80</strong>： 端口进行映射，将本地 8080 端口映射到容器内部的 80 端口。</li><li><strong>-d nginx</strong>： 设置容器在在后台一直运行。</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx5.png"><img src="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx5.png" alt="img" /></a></p><h2 id="安装成功">5、安装成功</h2><p>最后我们可以通过浏览器可以直接访问 8080 端口的 nginx 服务：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx6.png"><img src="https://www.runoob.com/wp-content/uploads/2016/06/docker-nginx6.png" alt="img" /></a></p><h1 id="配置修改nginx的配置文件">配置修改nginx的配置文件</h1><h2 id="容器中直接修改">容器中直接修改</h2><p>我们想要改变配置文件nginx.conf ，进入容器,命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it nginx bash<br></code></pre></td></tr></table></figure><p>nginx.conf配置文件在 <code>/etc/nginx/</code> 下面，但是你使用<code>vim nginx.conf</code> 或者<code>vi nginx.conf</code></p><p>会发现vi或者vim命令没有用，解决办法：<code>apt-get update</code> 完成之后 <code>apt-get install vim</code></p><p>此时你就可以自己定制nginx.conf文件了，改好配置文件之后重启容器，步骤，先把容器停了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stop nginx <br></code></pre></td></tr></table></figure><p>然后重启</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker <span class="hljs-literal">start</span> nginx<br></code></pre></td></tr></table></figure><p>这样不是很方便，</p><h2 id="挂载配置文件">挂载配置文件</h2><p>就是把装有docker宿主机上面的nginx.conf配置文件映射到启动的nginx容器里面，这需要你首先准备好nginx.con配置文件,如果你应经准备好了，下一步是启动nginx</p><p>命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name nginx -p 80:80 -v /home/docker-nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/docker-nginx/log:/var/log/nginx -v /home/docker-nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf -d nginx<br></code></pre></td></tr></table></figure><p>解释下上面的命令：</p><p><code>--name</code> 给你启动的容器起个名字，以后可以使用这个名字启动或者停止容器</p><p><code>-p</code> 映射端口，将docker宿主机的80端口和容器的80端口进行绑定</p><p><code>-v</code> 挂载文件用的，第一个-v 表示将你本地的nginx.conf覆盖你要起启动的容器的nginx.conf文件，第二个表示将日志文件进行挂载，就是把nginx服务器的日志写到你docker宿主机的/home/docker-nginx/log/下面</p><p>第三个-v 表示的和第一个-v意思一样的。</p><p><code>-d</code> 表示启动的是哪个镜像</p><p>我个人更喜欢第二种映射的方式，麻烦的是需要自己准备好nginx.conf 和default.conf文件，我是直接从容器里面复制的，然后根据自己的需要改的</p><p>nginx.conf:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">user  nginx;<br>worker_processes  auto;<br><br>error_log  /var/log/nginx/error.log notice;<br>pid        /var/run/nginx.pid;<br><br><br>events &#123;<br>    worker_connections  1024;<br>&#125;<br><br><br>http &#123;<br>    include       /etc/nginx/mime.types;<br>    default_type  application/octet-stream;<br><br>    log_format  main  <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>                      <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;<br><br>    access_log  /var/log/nginx/access.log  main;<br><br>    sendfile        on;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    keepalive_timeout  65;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    upstream halo &#123;<br>        server 127.0.0.1:8090;<br>    &#125;<br><br>    include /etc/nginx/conf.d/*.conf;<br>&#125;<br></code></pre></td></tr></table></figure><p>default.conf：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">server &#123;<br>    listen       80;<br>    listen  [::]:80;<br>    server_name  halo;<br><br>    client_max_body_size 1024m;<br><br>    <span class="hljs-comment">#access_log  /var/log/nginx/host.access.log  main;</span><br><br>    location / &#123;<br>        proxy_pass http://halo;<br>        proxy_set_header HOST <span class="hljs-variable">$host</span>;<br>        proxy_set_header X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>        proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>        proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    &#125;<br><br>    <span class="hljs-comment">#error_page  404              /404.html;</span><br><br>    <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>    <span class="hljs-comment">#</span><br>    error_page   500 502 503 504  /50x.html;<br>    location = /50x.html &#123;<br>        root   /usr/share/nginx/html;<br>    &#125;<br><br>    <span class="hljs-comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment">#location ~ \.php$ &#123;</span><br>    <span class="hljs-comment">#    proxy_pass   http://127.0.0.1;</span><br>    <span class="hljs-comment">#&#125;</span><br><br>    <span class="hljs-comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment">#location ~ \.php$ &#123;</span><br>    <span class="hljs-comment">#    root           html;</span><br>    <span class="hljs-comment">#    fastcgi_pass   127.0.0.1:9000;</span><br>    <span class="hljs-comment">#    fastcgi_index  index.php;</span><br>    <span class="hljs-comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>    <span class="hljs-comment">#    include        fastcgi_params;</span><br>    <span class="hljs-comment">#&#125;</span><br><br>    <span class="hljs-comment"># deny access to .htaccess files, if Apache&#x27;s document root</span><br>    <span class="hljs-comment"># concurs with nginx&#x27;s one</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment">#location ~ /\.ht &#123;</span><br>    <span class="hljs-comment">#    deny  all;</span><br>    <span class="hljs-comment">#&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="附录一些可能用上的docker命令">附录一些可能用上的docker命令</h1><ol type="1"><li>查看容器IP地址</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker inspect 容器名称或 <span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Infrastructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络设施</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 查看端口占用情况</title>
    <link href="/2022/03/07/Linux%20%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5-linuxcha-kan-duan-kou-zhan-yong-qing-kuang/"/>
    <url>/2022/03/07/Linux%20%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5-linuxcha-kan-duan-kou-zhan-yong-qing-kuang/</url>
    
    <content type="html"><![CDATA[<p>Linux 查看端口占用情况可以使用 <strong>lsof</strong> 和 <strong>netstat</strong> 命令。</p><hr /><h1 id="lsof">lsof</h1><p><code>lsof(list open files)</code>是一个列出当前系统打开文件的工具。</p><p>lsof 查看端口占用语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i:端口号<br></code></pre></td></tr></table></figure><h2 id="实例">实例</h2><p>查看服务器 8000 端口的占用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># lsof -i:8000</span><br>COMMAND   PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME<br>nodejs  26993 root   10u  IPv4 37999514      0t0  TCP *:8000 (LISTEN)<br></code></pre></td></tr></table></figure><p>可以看到 8000 端口已经被轻 nodejs 服务占用。</p><p>lsof -i 需要 root 用户的权限来执行，如下图：</p><figure><img src="https://www.runoob.com/wp-content/uploads/2018/09/lsof.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>更多 lsof 的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsof -i:8080：查看8080端口占用<br>lsof abc.txt：显示开启文件abc.txt的进程<br>lsof -c abc：显示abc进程现在打开的文件<br>lsof -c -p 1234：列出进程号为1234的进程所打开的文件<br>lsof -g gid：显示归属gid的进程情况<br>lsof +d /usr/local/：显示目录下被进程开启的文件<br>lsof +D /usr/local/：同上，但是会搜索目录下的目录，时间较长<br>lsof -d 4：显示使用fd为4的进程<br>lsof -i -U：显示所有打开的端口和UNIX domain文件<br></code></pre></td></tr></table></figure><hr /><h1 id="netstat">netstat</h1><p><code>netstat -tunlp</code> 用于显示 tcp，udp 的端口和进程等相关情况。</p><p>netstat 查看端口占用语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -tunlp | grep 端口号<br></code></pre></td></tr></table></figure><ul><li>-t (tcp) 仅显示tcp相关选项</li><li>-u (udp)仅显示udp相关选项</li><li>-n 拒绝显示别名，能显示数字的全部转化为数字</li><li>-l 仅列出在Listen(监听)的服务状态</li><li>-p 显示建立相关链接的程序名</li></ul><p>例如查看 8000 端口的情况，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># netstat -tunlp | grep 8000</span><br>tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      26993/nodejs   <br></code></pre></td></tr></table></figure><p>更多命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">netstat -ntlp   //查看当前所有tcp端口<br>netstat -ntulp | grep 80   //查看所有80端口使用情况<br>netstat -ntulp | grep 3306   //查看所有3306端口使用情况<br></code></pre></td></tr></table></figure><hr /><h1 id="kill">kill</h1><p>在查到端口占用的进程后，如果你要杀掉对应的进程可以使用 kill 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 PID<br></code></pre></td></tr></table></figure><p>如上实例，我们看到 8000 端口对应的 PID 为 26993，使用以下命令杀死进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">kill</span> -9 26993<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linnux修改文件基本权限</title>
    <link href="/2022/03/07/Linnux%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90-linnux-xiu-gai-wen-jian-ji-ben-quan-xian/"/>
    <url>/2022/03/07/Linnux%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%9D%83%E9%99%90-linnux-xiu-gai-wen-jian-ji-ben-quan-xian/</url>
    
    <content type="html"><![CDATA[<h1 id="命令格式">命令格式</h1><p>Linux既然每个文件或目录都有自己的权限属性，那么如何来修改他们的权限属性呢，在学命令之前先了解一下Linux命令的格式：</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/1.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>[-选项]：就是用来调整命令功能的。</p><p>[参数]：命令操作的对象。</p><h1 id="修改文件基本权限的命令">修改文件基本权限的命令</h1><p>想要改文件的权限，只有管理员root和所有者才能修改</p><h2 id="chmod更改文件9个属性">chmod：更改文件9个属性</h2><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/2.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><h3 id="数字改变文件权限常用">数字改变文件权限（常用）</h3><p>我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><ul><li>r:4</li><li>w:2</li><li>x:1</li></ul><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx---] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= --- = 0+0+0 = 0</li></ul><p>所以等我们设定权限的变更时，该文件的权限数字就是770啦！变更权限的指令chmod的语法是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> [-R] xyz 文件或目录<br></code></pre></td></tr></table></figure><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li><li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li></ul><h3 id="符号类型改变文件权限">符号类型改变文件权限</h3><p>我们就可以藉由u, g, o来代表三种身份的权限！</p><p>此外， a 则代表 all 亦即全部的身份！那么读写的权限就可以写成r, w, x！也就是可以使用底下的方式来看：</p><table><thead><tr class="header"><th></th><th>u</th><th>+(加入)</th><th>r</th><th></th></tr></thead><tbody><tr class="odd"><td></td><td>g</td><td>-(除去)</td><td>w</td><td></td></tr><tr class="even"><td>chmod</td><td>o</td><td>=(设定)</td><td>x</td><td>文件或目录</td></tr><tr class="odd"><td></td><td>a</td><td></td><td></td><td></td></tr></tbody></table><p>如果我们需要将文件权限设置为<code>-rwxr-xr--</code> ，可以使用 <code>chmod u=rwx,g=rx,o=r</code>文件名 来设定。</p><p>例：</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/3.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/4.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>注意：如果一个目录有写的权限，其他用户对于这个目录下的文件也可以删除。</p><h2 id="chown更改文件属主也可以同时更改文件属组">chown：更改文件属主，也可以同时更改文件属组</h2><p>注意：这个命令只有管理员root才可以操作。而且系统里是必须存在这个用户。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/5.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>语法：</p><p>chown [–R] 属主名： 文件名</p><p>chown [-R] 属主名：属组名 文件名</p><h2 id="chgrp更改文件属组">chgrp：更改文件属组。</h2><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/6.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chgrp</span> [-R] 属组名 文件名<br></code></pre></td></tr></table></figure><p>参数选项</p><ul><li>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</li></ul><h2 id="umask设置预设的权限掩码"><strong>umask设置预设的权限掩码</strong></h2><p>Linux umask命令指定在建立文件时预设的权限掩码，在学习这个命令之前，先了解一下默认的所有者和所属组是哪来的？</p><p>一个文件创建的时候所有者和所属组是哪来的？</p><p>所有者：谁创建的文件谁就是这个文件的所有者。</p><p>所属组：就是这个文件创建者的缺省组，每个用户只能有一个缺省组。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/7.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/8.png?raw=true" alt="img" />显示新建文件的缺省权限。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/9.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/10.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>创建一个目录的时候查看发现 权限跟缺省权限是一致的，但是在test目录里创建一个文件后，查看文件缺省权限跟默认缺省权限不一致，这个是为什么呢？</p><p><code>rwxr-xr-x</code></p><p>rw-r--r-- 对比发现都少了一个x可执行权限，这是因为在Linux里缺省权限创建的文件是不可具有可执行权限的。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/11.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>单独执行 <strong>umask</strong> 发现现实出 <strong>0022</strong> ，这是什么意思呢？</p><p>022是权限掩码意思，真正的权限是777-022=755 写出来就是rwxr-xr-x.</p><p>如果我们自己要是想修改这个缺省权限，该怎么修改的。</p><p>先把想修改的权限格式表示出来，算出对应的数字，再用777-对应的数字就可以，例如：</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/linux-aut/12.png?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装nginx</title>
    <link href="/2022/03/07/ubuntu%E5%AE%89%E8%A3%85nginx-ubuntu-an-zhuang-nginx/"/>
    <url>/2022/03/07/ubuntu%E5%AE%89%E8%A3%85nginx-ubuntu-an-zhuang-nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="apt-get安装nginx">apt-get安装nginx</h1><ol type="1"><li>切换至root用户</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo su root<br>apt-<span class="hljs-built_in">get</span> install nginx<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>查看nginx是否安装成功</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -v</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>启动nginx</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service nginx <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><p>启动后，在网页重输入ip地址，即可看到nginx的欢迎页面。至此nginx安装成功</p><figure><img src="https://img-blog.csdnimg.cn/20181031203230618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzODMyMzEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>nginx文件安装完成之后的文件位置：</p><p><code>/usr/sbin/nginx</code>：主程序 <code>/etc/nginx</code>：存放配置文件 <code>/usr/share/nginx</code>：存放静态文件 <code>/var/log/nginx</code>：存放日志</p><h1 id="下载nginx包安装">下载nginx包安装</h1><p>由于上面已经安装了nginx，所以我们先卸载nginx。再重新上传nginx包，解压下载。有输入提示时，输入Y即可</p><ol type="1"><li>卸载apt-get安装的nginx</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 彻底卸载nginx</span><br>apt-<span class="hljs-keyword">get</span> <span class="hljs-comment">--purge autoremove nginx</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>查看nginx的版本号 <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -v</span><br></code></pre></td></tr></table></figure></li></ol><figure><img src="https://img-blog.csdnimg.cn/20181031203843950.png" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ol start="3" type="1"><li>安装依赖包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get install gcc<br>apt-get install libpcre3 libpcre3-dev<br>apt-get install zlib1g zlib1g-dev<br></code></pre></td></tr></table></figure><p>Ubuntu14.04的仓库中没有发现openssl-dev，由下面openssl和libssl-dev替代</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#apt-get install openssl openssl-dev</span><br>sudo apt-get install openssl <br>sudo apt-get install libssl-dev<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>安装nginx</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local<br><span class="hljs-built_in">mkdir</span> nginx<br><span class="hljs-built_in">cd</span> nginx<br>wget http://nginx.org/download/nginx-1.13.7.tar.gz<br>tar -xvf nginx-1.13.7.tar.gz <br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20181031205721673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzODMyMzEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ol start="5" type="1"><li>编译nginx</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入nginx目录</span><br><br>/usr/local/nginx/nginx-1.13.7<br><br><span class="hljs-comment"># 执行命令</span><br><br>./configure<br><br><span class="hljs-comment"># 执行make命令</span><br><br>make<br><br><span class="hljs-comment"># 执行make install命令</span><br><br>make install<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>启动nginx</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入nginx启动目录</span><br><span class="hljs-built_in">cd</span> /usr/local/nginx/sbin<br><br><span class="hljs-comment"># 启动nginx</span><br><br>./nginx<br></code></pre></td></tr></table></figure><figure><img src="https://img-blog.csdnimg.cn/20181031210133487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzODMyMzEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ol start="7" type="1"><li>访问nginx</li></ol><p>网页输入ip地址，访问成功，到此，nginx安装完毕</p><figure><img src="https://img-blog.csdnimg.cn/2018103121025275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzODMyMzEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h1 id="使用-oneinstack安装">使用 OneinStack安装</h1><p>参考下面命令，一步步自定义安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install wget screen <span class="hljs-comment">#for CentOS/Redhat</span><br><span class="hljs-comment"># apt-get -y install wget screen #for Debian/Ubuntu</span><br>wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz <span class="hljs-comment">#包含源码，国内外均可下载</span><br>tar xzf oneinstack-full.tar.gz<br><span class="hljs-built_in">cd</span> oneinstack <span class="hljs-comment">#如果需要修改目录(安装、数据存储、Nginx日志)，请修改options.conf文件</span><br>screen -S oneinstack <span class="hljs-comment">#如果网路出现中断，可以执行命令`screen -R oneinstack`重新连接安装窗口</span><br>./install.sh<br></code></pre></td></tr></table></figure><figure><img src="https://static.oneinstack.com/images/install.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="如何添加附加组件">如何添加附加组件？</h2><blockquote><p>注意</p><p>如果之前没有安装组件，后续补充安装，统一入口为<code>./install.sh</code>，addons.sh脚本不在提供，如之前没有安装php redis扩展，补充安装命令：<code>./install.sh --php_extensions redis</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/oneinstack/addons.sh<br></code></pre></td></tr></table></figure><figure><img src="https://static.oneinstack.com/images/addons.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="如何添加虚拟主机">如何添加虚拟主机?</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/oneinstack/vhost.sh<br></code></pre></td></tr></table></figure><figure><img src="https://static.oneinstack.com/images/vhost.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="启动nginx">启动Nginx</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">service nginx <span class="hljs-literal">start</span><br></code></pre></td></tr></table></figure><h2 id="重载-nginx-使配置生效">重载 Nginx 使配置生效</h2><p>验证 nginx 配置</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -t</span><br></code></pre></td></tr></table></figure><p>如果输出如下提示则代表配置有效： <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">nginx: the configuration <span class="hljs-keyword">file</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>conf/nginx.conf syntax is ok<br>nginx: configuration <span class="hljs-keyword">file</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/nginx/</span>conf/nginx.conf test is successful<br></code></pre></td></tr></table></figure></p><p>重载 Nginx 配置：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure><p>重启Nginx <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service nginx restart</span><br></code></pre></td></tr></table></figure></p><p><strong>可能遇到的问题：</strong></p><p>nginx使用<code>service nginx restart</code>报错</p><p>启动nginx服务时如果遇到这个错误 <code>Job for nginx.service failed because the control process exited with error code. See "systemctl status nginx.service" and "journalctl -xe" for details</code>.</p><p>可能原因:</p><p>1、配置文件语法有误，<code>执行nginx -t</code></p><p><strong>查看输出提示信息 并检查端口是否被占用<code>netstat -tnlp</code></strong></p><p>2、nginx的配置文件nginx.conf中监听了其他端口，这些端口的子进程仍然运行，导致端口占用。需要首先关闭子进程，才能使用该命令。</p><p>此时可以<code>kill -9 pid</code> 。</p><figure><img src="https://img-blog.csdnimg.cn/20210425123334652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NlZV9feW91X19hZ2Fpbg==,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="linux环境nginx命令">Linux环境Nginx命令</h1><table><thead><tr class="header"><th><strong>Linux环境Nginx命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr class="odd"><td>sudo nginx -t</td><td>查看配置文件语法</td></tr><tr class="even"><td>sudo nginx -c /usr/local/nginx/conf/nginx.conf</td><td>指定配置文件启动</td></tr><tr class="odd"><td>sudo nginx -s stop</td><td>强制停止nginx</td></tr><tr class="even"><td>sudo nginx -s reload</td><td>重新加载配置文件</td></tr><tr class="odd"><td>sudo systemctl(或者service) start nginx</td><td>启动nginx</td></tr><tr class="even"><td>sudo systemctl(或者service) enable nginx</td><td>开机自启动</td></tr><tr class="odd"><td>sudo systemctl(service) restart nginx</td><td>重启nginx</td></tr></tbody></table><blockquote><p>参考：<a href="https://oneinstack.com/install/">oneinstack安装步骤</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Infrastructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络设施</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2022/03/06/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-hello-halo/"/>
    <url>/2022/03/06/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-hello-halo/</url>
    
    <content type="html"><![CDATA[<h1 id="博客选择">博客选择</h1><p>本博客使用一款现代化的开源博客/CMS系统 <a href="https://halo.run">Halo</a> 进行创作。</p><h1 id="使用-docker-部署-halo">使用 Docker 部署 Halo</h1><p>Halo 在 Docker Hub 上发布的镜像为 <a href="https://hub.docker.com/r/halohub/halo">halohub/halo</a></p><ol type="1"><li>创建<a href="https://docs.halo.run/getting-started/prepare#工作目录">工作目录</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> ~/.halo &amp;&amp; <span class="hljs-built_in">cd</span> ~/.halo<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>下载示例配置文件到<a href="https://docs.halo.run/getting-started/prepare#工作目录">工作目录</a></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dl.halo.run/config/application-template.yaml -O ./application.yaml<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编辑配置文件，配置数据库或者端口等，如需配置请参考<a href="https://docs.halo.run/getting-started/config">参考配置</a>。这里使用默认配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim application.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">erver:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8090</span><br><br>  <span class="hljs-comment"># Response data gzip.</span><br>  <span class="hljs-attr">compression:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br><br>    <span class="hljs-comment"># H2 database configuration.</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">org.h2.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:h2:file:~/.halo/db/halo</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">admin</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><br>    <span class="hljs-comment"># MySQL database configuration.</span><br><span class="hljs-comment">#    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment">#    url: jdbc:mysql://127.0.0.1:3306/halodb?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&amp;allowPublicKeyRetrieval=true</span><br><span class="hljs-comment">#    username: root</span><br><span class="hljs-comment">#    password: 123456</span><br><br>  <span class="hljs-comment"># H2 database console configuration.</span><br>  <span class="hljs-attr">h2:</span><br>    <span class="hljs-attr">console:</span><br>      <span class="hljs-attr">settings:</span><br>        <span class="hljs-attr">web-allow-others:</span> <span class="hljs-literal">false</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/h2-console</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">halo:</span><br><br>  <span class="hljs-comment"># Your admin client path is https://your-domain/&#123;admin-path&#125;</span><br>  <span class="hljs-attr">admin-path:</span> <span class="hljs-string">admin</span><br>  <br>  <span class="hljs-comment"># memory or level</span><br>  <span class="hljs-attr">cache:</span> <span class="hljs-string">memory</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>拉取最新的 Halo 镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull halohub/halo:latest<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>创建容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo --restart=unless-stopped halohub/halo:latest<br></code></pre></td></tr></table></figure><ul><li><strong>-it：</strong> 开启输入功能并连接伪终端</li><li><strong>-d：</strong> 后台运行容器</li><li><strong>--name：</strong> 为容器指定一个名称</li><li><strong>-p：</strong> 端口映射，格式为 <code>主机(宿主)端口:容器端口</code> ，可在 <code>application.yaml</code> 配置。</li><li><strong>-v：</strong> 工作目录映射。形式为：-v 宿主机路径:<code>/root/.halo</code>，后者不能修改。</li><li><strong>--restart：</strong> 建议设置为 <code>unless-stopped</code>，在 Docker 启动的时候自动启动 Halo 容器。</li></ul><ol start="6" type="1"><li>打开 <code>http://ip:端口号</code> 即可看到安装引导界面。</li></ol><blockquote><p>TIP</p><p>如果需要配置域名访问，建议先配置好反向代理以及域名解析再进行初始化。</p><p>如果通过 http://ip:端口号 的形式无法访问，请到服务器厂商后台将运行的端口号添加到安全组，如果服务器使用了 Linux 面板，请检查此 Linux 面板是否有还有安全组配置，需要同样将端口号添加到安全组。</p></blockquote><h1 id="反向代理">反向代理</h1><p>这里使用了Nginx作为反向代理。</p><h2 id="修改apache2服务端口号">修改apache2服务端口号</h2><p>本人使用的阿里云作为服务器主机。在配置Nginx时候有个问题，就是默认的情况，会有apache2占用80端口，导致nginx无法完成代理。</p><p>1.由于apache2占用的80端口的ipv6，不知道什么原因无法通过<code>kiil -9 PID</code>杀掉apache进程；</p><p>2.尝试过卸载apache2，无效。。</p><p>解决办法：</p><ol type="1"><li>首先关闭apache2，<code>sudo service apache2 stop</code>；</li><li>然后马上启动nginx反向代理。</li></ol><p>也可以不停止原先的apache2进程，在ubuntu修改apache端口号</p><h3 id="第一步">第一步</h3><p><code>sudo vi /etc/apache2/ports.conf</code> 修改监听端口以及主机端口为8080</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">NameVirtualHost *:8080<br>Listen 8080<br></code></pre></td></tr></table></figure><h3 id="第二步">第二步</h3><p><code>sudo vi /etc/apache2/sites-available/default</code> 只要修改virtualHost的端口即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;VirtualHost *:8080&gt;<br></code></pre></td></tr></table></figure><h3 id="第三步">第三步</h3><p>重启apache2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service apache2 stop<br>sudo service apache2 start<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service apache2 restart<br></code></pre></td></tr></table></figure><h2 id="切换默认sh为bash">切换默认sh为bash</h2><p>这里使用OneinStack 管理Nginx，但是OneinStack安装脚本使用的是bash，Ubuntu默认采用的是 dash，所以要先切换。</p><h3 id="查看与使用">查看与使用</h3><hr /><p>先用命令<code>ls -l /bin/sh</code>看看</p><blockquote><p>/bin/sh -&gt; dash</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">lrwxrwxrwx 1 root root 4 Jul 17 22:49 /bin/sh -&gt; dash<br></code></pre></td></tr></table></figure><p>我们会发现Ubuntu默认采用的是 dash</p><h3 id="切换sh为bash">切换sh为bash</h3><hr /><p>如果要修改默认的sh，可以采用命令</p><blockquote><p>sudo dpkg-reconfigure dash</p></blockquote><figure><img src="http://cdn.spphoto.top/img/dedd7b161aae0864b7e3e945d83bbb50.png" alt="选择 NO" /><figcaption aria-hidden="true">选择 NO</figcaption></figure><p>然后选择<strong>否</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo dpkg-reconfigure dash<br>Removing <span class="hljs-string">&#x27;diversion of /bin/sh to /bin/sh.distrib by dash&#x27;</span><br>Adding <span class="hljs-string">&#x27;diversion of /bin/sh to /bin/sh.distrib by bash&#x27;</span><br>Removing <span class="hljs-string">&#x27;diversion of /usr/share/man/man1/sh.1.gz to /usr/share/man/man1/sh.distrib.1.gz by dash&#x27;</span><br>Adding <span class="hljs-string">&#x27;diversion of /usr/share/man/man1/sh.1.gz to /usr/share/man/man1/sh.distrib.1.gz by bash&#x27;</span><br></code></pre></td></tr></table></figure><p>成功后再执行</p><blockquote><p>ll /bin/sh</p></blockquote><p>结果是： <code>/bin/sh -&gt; bash</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> -al /bin/sh<br>lrwxrwxrwx 1 root root 4 Aug 16 23:00 /bin/sh -&gt; bash<br></code></pre></td></tr></table></figure><p>修改成功！</p><h3 id="切换sh为dash">切换sh为dash</h3><hr /><p>当然我们也可以使用</p><blockquote><p>sudo dpkg-reconfigure dash</p></blockquote><p>把sh修改回去</p><h3 id="链接">链接</h3><hr /><p><a href="http://www.2cto.com/os/201305/210033.html">Dash与Bash的语法区别</a></p><h2 id="安装nginx">安装Nginx</h2><p>点击下方链接进入 OneinStack 官网，仅选择 <code>安装 Nginx</code>，其他的都可以取消选择。</p><p>https://oneinstack.com/auto</p><p>最后点击 <code>复制安装命令</code> 到服务器执行即可。如果你仅安装 Nginx，你的链接应该是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget -c http://mirrors.linuxeye.com/oneinstack-full.tar.gz &amp;&amp; tar xzf oneinstack-full.tar.gz &amp;&amp; ./oneinstack/install.sh --nginx_option 1<br></code></pre></td></tr></table></figure><blockquote><p>INFO</p><p>这一步会经过编译安装，可能会导致安装时间很漫长，这主要取决于你服务器的性能。</p></blockquote><p>出现下面的信息即代表安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Nginx installed successfully!<br>Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.<br>Redirecting to /bin/systemctl start nginx.service<br><span class="hljs-comment">####################Congratulations########################</span><br>Total OneinStack Install Time: 5 minutes<br><br>Nginx install <span class="hljs-built_in">dir</span>:              /usr/local/nginx<br></code></pre></td></tr></table></figure><h2 id="创建-vhost">创建 vhost</h2><blockquote><p>即创建一个站点，你可以通过这样的方式在你的服务器创建无限个站点。</p></blockquote><blockquote><p>接下来的目的就是创建一个站点，并反向代理到 Halo。这一步在此教程使用 <code>demo.halo.run</code> 这个域名做演示，实际情况请修改此域名。</p></blockquote><ol type="1"><li>进入到 oneinstack 目录，执行 vhost 创建命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> oneinstack<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh vhost.sh<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>按照提示选择或输入相关信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">What Are You Doing?<br>    1. Use HTTP Only<br>    2. Use your own SSL Certificate and Key<br>    3. Use Let<span class="hljs-string">&#x27;s Encrypt to Create SSL Certificate and Key</span><br><span class="hljs-string">    q. Exit</span><br><span class="hljs-string">Please input the correct option:</span><br></code></pre></td></tr></table></figure><p>这一步是选择证书配置方式，如果你有自己的证书，输入 2 即可。如果需要使用 <code>Let's Encrypt</code> 申请证书，选择 3 即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Please input domain(example: www.example.com):<br></code></pre></td></tr></table></figure><p>输入自己的域名即可，前提是已经提前解析好了域名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Please input the directory <span class="hljs-keyword">for</span> the domain:demo.halo.run :<br>(Default directory: /data/wwwroot/demo.halo.run):<br></code></pre></td></tr></table></figure><p>没有事先准备好域名的话，直接填入主机ip地址。</p><p>提示输入站点根目录，因为我们是使用 Nginx 的反向代理，所以这个目录是没有必要配置的，我们直接使用默认的即可（直接回车）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Do you want to add more domain name? [y/n]:<br></code></pre></td></tr></table></figure><p>是否需要添加其他域名，按照需要选择即可，如果不需要，输入 n 并回车确认。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Do you want to add hotlink protection? [y/n]:<br></code></pre></td></tr></table></figure><p>是否需要做防盗链处理，按照需要选择即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Allow Rewrite rule? [y/n]:<br></code></pre></td></tr></table></figure><p>路径重写配置，我们不需要，选择 n 回车确定即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Allow Nginx/Tengine/OpenResty access_log? [y/n]:<br></code></pre></td></tr></table></figure><p>Nginx 的请求日志，建议选择 y。</p><p>这样就完成了 vhost 站点的创建，最终会输出站点的相关信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Your domain:                  demo.halo.run<br>Virtualhost conf:             /usr/local/nginx/conf/vhost/demo.halo.run.conf<br>Directory of:                 /data/wwwroot/demo.halo.run<br></code></pre></td></tr></table></figure><p>Nginx 的配置文件即 <code>/usr/local/nginx/conf/vhost/demo.halo.run.conf</code>。</p><h2 id="修改-nginx-配置文件">修改 Nginx 配置文件</h2><p>上方创建 vhost 的过程并没有创建反向代理的配置，所以需要我们自己修改一下配置文件。</p><ol type="1"><li>使用你熟悉的工具打开配置文件，此教程使用 vim。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /usr/local/nginx/conf/vhost/demo.halo.run.conf<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>删除一些不必要的配置</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~ [^/]\.php(/|$)</span> &#123;<br>  <span class="hljs-comment">#fastcgi_pass remote_php_ip:9000;</span><br>  <span class="hljs-attribute">fastcgi_pass</span> unix:/dev/shm/php-cgi.sock;<br>  <span class="hljs-attribute">fastcgi_index</span> index.php;<br>  <span class="hljs-attribute">include</span> fastcgi.conf;<br>&#125;<br></code></pre></td></tr></table></figure><p>此段配置是针对 php 应用的，所以可以删掉。</p><ol start="3" type="1"><li>添加 <code>upstream</code> 配置</li></ol><p>在 <code>server</code> 的同级节点添加如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> halo &#123;<br>  <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8090</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可能出现的错误：</strong></p><p>nginx集群报错“upstream”directive is not allow here 错误</p><p>是upstream backend 位置放错了, upstream位置应该放在http模块里面 但必须是在server模块的外面. 应该是下面这样的结构:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">http&#123;</span><br><span class="hljs-string">upstream</span> <span class="hljs-string">backend</span> &#123; <br><span class="hljs-string">server</span> <span class="hljs-string">backend1.example.com</span> <span class="hljs-string">weight=5;</span> <br><span class="hljs-string">server</span> <span class="hljs-string">backend2.example.com:8080;</span> <br><span class="hljs-string">server</span> <span class="hljs-string">unix:/tmp/backend3;</span><br>&#125; <br><span class="hljs-string">server</span> &#123; <br><span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123; <br><span class="hljs-string">proxy_pass</span> <span class="hljs-string">http://backend;</span> <br>&#125;<br>&#125;<br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>在 <code>server</code> 节点添加如下配置</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>  <span class="hljs-attribute">proxy_set_header</span> HOST <span class="hljs-variable">$host</span>;<br>  <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>  <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>  <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>  <span class="hljs-attribute">proxy_pass</span> http://halo;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>修改 <code>location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$</code> 节点</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$</span> &#123;<br>  <span class="hljs-attribute">proxy_pass</span> http://halo;<br>  <span class="hljs-attribute">expires</span> <span class="hljs-number">30d</span>;<br>  <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>修改 <code>location ~ .*\.(js|css)?$</code> 节点</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> <span class="hljs-regexp">~ .*\.(js|css)?$</span> &#123;<br>  <span class="hljs-attribute">proxy_pass</span> http://halo;<br>  <span class="hljs-attribute">expires</span> <span class="hljs-number">7d</span>;<br>  <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不按照第 5，6 步操作，请求一些图片或者样式文件不会经过 Halo，所以请不要忽略此配置。</p><ol start="7" type="1"><li>添加 acme.sh 续签验证路由</li></ol><p>OneinStack 使用的 acme.sh 管理证书，如果你在创建 vhost 的时候选择了使用 <code>Let's Encrypt</code> 申请证书，那么 OneinStack 会在系统内添加一个定时任务去自动续签证书，acme.sh 默认验证站点所有权的方式为在站点根目录生成一个文件（.well-known）来做验证，由于配置了反向代理，所以在验证的时候是无法直接访问到站点目录下的 .well-known 文件夹下的验证文件的。需要添加如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /.well-known/acme-challenge/ &#123;<br>  <span class="hljs-attribute">default_type</span> <span class="hljs-string">&quot;text/plain&quot;</span>;<br>  <span class="hljs-attribute">allow</span> all;<br>  <span class="hljs-attribute">root</span> /data/wwwroot/demo.halo.run/;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，配置修改完毕，保存即可。最终你的配置文件可能如下面配置一样：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> halo &#123;<br>  <span class="hljs-attribute">server</span> <span class="hljs-number">127.0.0.1:8090</span>;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;<br>  <span class="hljs-attribute">listen</span> [::]:<span class="hljs-number">443</span> ssl http2;<br>  <span class="hljs-attribute">ssl_certificate</span> /usr/local/nginx/conf/ssl/demo.halo.run.crt;<br>  <span class="hljs-attribute">ssl_certificate_key</span> /usr/local/nginx/conf/ssl/demo.halo.run.key;<br>  <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span> TLSv1.<span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">ssl_ciphers</span> TLS13-AES-<span class="hljs-number">256</span>-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-<span class="hljs-number">128</span>-GCM-SHA256:TLS13-AES-<span class="hljs-number">128</span>-CCM-<span class="hljs-number">8</span>-SHA256:TLS13-AES-<span class="hljs-number">128</span>-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;<br>  <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;<br>  <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">10m</span>;<br>  <span class="hljs-attribute">ssl_session_cache</span> builtin:<span class="hljs-number">1000</span> shared:SSL:<span class="hljs-number">10m</span>;<br>  <span class="hljs-attribute">ssl_buffer_size</span> <span class="hljs-number">1400</span>;<br>  <span class="hljs-attribute">add_header</span> Strict-Transport-Security max-age=<span class="hljs-number">15768000</span>;<br>  <span class="hljs-attribute">ssl_stapling</span> <span class="hljs-literal">on</span>;<br>  <span class="hljs-attribute">ssl_stapling_verify</span> <span class="hljs-literal">on</span>;<br>  <span class="hljs-attribute">server_name</span> demo.halo.run;<br>  <span class="hljs-attribute">access_log</span> /data/wwwlogs/demo.halo.run_nginx.log combined;<br>  <span class="hljs-attribute">index</span> index.html index.htm index.php;<br>  <span class="hljs-attribute">root</span> /data/wwwroot/demo.halo.run;<br>  <span class="hljs-attribute">if</span> (<span class="hljs-variable">$ssl_protocol</span> = <span class="hljs-string">&quot;&quot;</span>) &#123; <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>; &#125;<br>  <span class="hljs-attribute">include</span> /usr/local/nginx/conf/rewrite/<span class="hljs-literal">none</span>.conf;<br>  <span class="hljs-comment">#error_page 404 /404.html;</span><br>  <span class="hljs-comment">#error_page 502 /502.html;</span><br>  <span class="hljs-section">location</span> <span class="hljs-regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$</span> &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://halo;<br>    <span class="hljs-attribute">expires</span> <span class="hljs-number">30d</span>;<br>    <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;<br>  &#125;<br>  <span class="hljs-section">location</span> <span class="hljs-regexp">~ .*\.(js|css)?$</span> &#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://halo;<br>    <span class="hljs-attribute">expires</span> <span class="hljs-number">7d</span>;<br>    <span class="hljs-attribute">access_log</span> <span class="hljs-literal">off</span>;<br>  &#125;<br>  <span class="hljs-section">location</span> <span class="hljs-regexp">~ /(\.user\.ini|\.ht|\.git|\.svn|\.project|LICENSE|README\.md)</span> &#123;<br>    <span class="hljs-attribute">deny</span> all;<br>  &#125;<br>  <span class="hljs-section">location</span> / &#123;<br>    <span class="hljs-attribute">proxy_set_header</span> HOST <span class="hljs-variable">$host</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    <span class="hljs-attribute">proxy_pass</span> http://halo;<br>  &#125;<br>  <span class="hljs-section">location</span><span class="hljs-regexp"> ^~</span> /.well-known/acme-challenge/ &#123;<br>    <span class="hljs-attribute">default_type</span> <span class="hljs-string">&quot;text/plain&quot;</span>;<br>    <span class="hljs-attribute">allow</span> all;<br>    <span class="hljs-attribute">root</span> /data/wwwroot/demo.halo.run/;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重载-nginx-使配置生效">重载 Nginx 使配置生效</h2><p>验证 nginx 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -t<br></code></pre></td></tr></table></figure><p>如果输出如下提示则代表配置有效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/nginx/conf/nginx.conf <span class="hljs-built_in">test</span> is successful<br></code></pre></td></tr></table></figure><p>重载 Nginx 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nginx -s reload<br></code></pre></td></tr></table></figure><p>至此，整个教程完毕，现在你可以访问域名检查是否已经配置成功。</p><h1 id="相关链接">相关链接</h1><ul><li>官网：<a href="https://halo.run">https://halo.run</a></li><li>文档：<a href="https://docs.halo.run">https://docs.halo.run</a></li><li>社区：<a href="https://bbs.halo.run">https://bbs.halo.run</a></li><li>主题仓库：<a href="https://halo.run/themes.html">https://halo.run/themes.html</a></li><li>开源地址：<a href="https://github.com/halo-dev/halo">https://github.com/halo-dev/halo</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java SPI (Service Provider Interface) 机制详解</title>
    <link href="/2022/01/25/Java-SPI/"/>
    <url>/2022/01/25/Java-SPI/</url>
    
    <content type="html"><![CDATA[<p>本质：Java SPI 实际上是“基于接口的编程＋策略模式＋约定配置文件” 组合实现的动态加载机制，在JDK中提供了工具类：“<code>java.util.ServiceLoader</code>”来实现服务查找。</p><h1 id="什么是spi">什么是SPI ？</h1><p>SPI 全称：Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的接口，<strong>它可以用来启用框架扩展和替换组件。</strong></p><p>面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。</p><p>为了实现在模块装配的时候不用在程序里动态指明，这就需要一种服务发现机制。java spi就是提供这样的一个机制：<strong>为某个接口寻找服务实现的机制。这有点类似IOC的思想，将装配的控制权移到了程序之外。</strong></p><p>SPI的作用就是为被扩展的API寻找服务实现。</p><p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 解耦。</p><p>SPI整体机制图如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/spi1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：<code>java.util.ServiceLoader</code>。</p><h1 id="spi-的不足">SPI 的不足</h1><p>1.不能按需加载，需要遍历所有的实现，并实例化，然后在循环中才能找到我们需要的实现。如果不想用某些实现类，或者某些类实例化很耗时，它也被载入并实例化了，这就造成了浪费。</p><p>2.获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，不能根据某个参数来获取对应的实现类。（Spring 的BeanFactory，ApplicationContext 就要高级一些了。）</p><p>3.多个并发多线程使用 ServiceLoader 类的实例是不安全的。</p><h1 id="api-与-spi">API 与 SPI</h1><h2 id="spi与api区别">SPI与API区别：</h2><p>API是调用并用于实现目标的类、接口、方法等的描述；</p><p>SPI是扩展和实现以实现目标的类、接口、方法等的描述；</p><p>换句话说，API 为操作提供特定的类、方法，SPI 通过操作来符合特定的类、方法。</p><blockquote><p>参考： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F2954372%2Fdifference-between-spi-and-api%3Fanswertab%3Dvotes%23tab-top">https://stackoverflow.com/questions/2954372/difference-between-spi-and-api?answertab=votes#tab-top</a></p></blockquote><h2 id="spi和api的使用场景解析">SPI和API的使用场景解析：</h2><ul><li>API （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。</li><li>SPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。 从使用人员上来说，SPI 被框架扩展人员使用。</li></ul><h1 id="spi-应用场景">SPI 应用场景</h1><p>SPI扩展机制应用场景有很多，比如Common-Logging，JDBC，Dubbo等等。</p><h3 id="spi流程">SPI流程：</h3><p>有关组织和公式定义接口标准</p><p>第三方提供具体实现: 实现具体方法, 配置 META-INF/services/${interface_name} 文件</p><h3 id="开发者使用">开发者使用</h3><p>比如JDBC场景下：</p><p>首先在Java中定义了接口java.sql.Driver，并没有具体的实现，具体的实现都是由不同厂商提供。</p><p>在MySQL的jar包mysql-connector-java-6.0.6.jar中，可以找到META-INF/services目录，该目录下会有一个名字为java.sql.Driver的文件，文件内容是com.mysql.cj.jdbc.Driver，这里面的内容就是针对Java中定义的接口的实现。</p><p>同样在PostgreSQL的jar包PostgreSQL-42.0.0.jar中，也可以找到同样的配置文件，文件内容是org.postgresql.Driver，这是PostgreSQL对Java的java.sql.Driver的实现。</p><h1 id="项目案例">项目案例</h1><p>Java 工程目录：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/spi2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>下面我们来简单实现一个 JDK 的SPI的简单实现。</p><h2 id="java代码开发">Java代码开发</h2><p>首先第一步，定义一个接口：</p><p>Phone.java</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package com.<span class="hljs-property">light</span>.<span class="hljs-property">sword</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Jack</span><br><span class="hljs-comment"> * 2021/1/31 上午1:44</span><br><span class="hljs-comment"> */</span><br>public interface <span class="hljs-title class_">Phone</span> &#123;<br>    <span class="hljs-title class_">String</span> <span class="hljs-title function_">getSystemInfo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个接口分别有两个实现：</p><p>Huawei.java</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package com.<span class="hljs-property">light</span>.<span class="hljs-property">sword</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Jack</span><br><span class="hljs-comment"> * 2021/1/31 上午1:48</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Huawei</span> implements <span class="hljs-title class_">Phone</span> &#123;<br>    @<span class="hljs-title class_">Override</span><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getSystemInfo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hong Meng&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>IPhone.java</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package com.<span class="hljs-property">light</span>.<span class="hljs-property">sword</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: Jack</span><br><span class="hljs-comment"> * 2021/1/31 上午1:48</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">IPhone</span> implements <span class="hljs-title class_">Phone</span> &#123;<br>    @<span class="hljs-title class_">Override</span><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">getSystemInfo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;iOS&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="约定配置">约定配置</h2><p>新建 META-INF/services 目录</p><blockquote><p>注意：这个META-INF/services 目录是写死的约定，在 <code>java.util.ServiceLoader</code> 源码实现中, java.util.ServiceLoader#PREFIX 可以看到这个目录的硬编码。</p></blockquote><p>然后需要在resources目录下新建 <code>META-INF/services</code> 目录，并且在这个目录下新建一个与上述接口的全限定名一致的文件:</p><p>com.light.sword.Phone (这是一个文件，是的，一切皆是文件。)</p><p>在这个文件中写入接口的实现类的全限定名（文件 com.light.sword.Phone 中写死的内容）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">com.<span class="hljs-property">light</span>.<span class="hljs-property">sword</span>.<span class="hljs-property">Huawei</span><br>com.<span class="hljs-property">light</span>.<span class="hljs-property">sword</span>.<span class="hljs-property">IPhone</span><br></code></pre></td></tr></table></figure><p>如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/spi3.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="加载实现类并调用服务">加载实现类并调用服务</h2><p>这时，通过ServiceLoader 加载实现类并调用服务：</p><p>Main.java</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package com.<span class="hljs-property">light</span>.<span class="hljs-property">sword</span>;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ServiceLoader</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ServiceLoader</span>&lt;<span class="hljs-title class_">Phone</span>&gt; phoneServiceLoader = <span class="hljs-title class_">ServiceLoader</span>.<span class="hljs-title function_">load</span>(<span class="hljs-title class_">Phone</span>.<span class="hljs-property">class</span>);<br>        phoneServiceLoader.<span class="hljs-title function_">forEach</span>(provider -&gt; &#123;<br>            <span class="hljs-title class_">String</span> systemInfo = provider.<span class="hljs-title function_">getSystemInfo</span>();<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(systemInfo);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Hong</span> <span class="hljs-title class_">Meng</span><br>iOS<br></code></pre></td></tr></table></figure><p>工程源代码：<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgitee.com%2Funiverssky%2Fjava-spi-demo">https://gitee.com/universsky/java-spi-demo</a></p><p>这样一个简单的 Java SPI 的demo就完成了。可以看到其中最为核心的就是通过一系列的约定（其实，就是按照人家 <code>java.util.ServiceLoader</code> 的规范标准来）， 然后，通过ServiceLoader 这个类来加载具体的实现类，进而调用实现类的服务。</p><hr /><blockquote><p>知识拓展： 其实，我们在Spring框架中，可以通过 <code>component-scan</code> 标签来对指定包路径进行扫描，只要扫到 Spring 制定的 <code>@Service</code>、<code>@Controller</code> 等注解，spring自动会把它注入<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>。</p><p>这就相当于spring制定了注解规范，我们按照这个注解规范开发相应的实现类或controller，spring并不需要感知我们是怎么实现的，他只需要根据注解规范和scan标签注入相应的bean，这正是 spi 理念的体现。</p></blockquote><h1 id="spi-实现原理解析">SPI 实现原理解析</h1><p>首先，ServiceLoader实现了Iterable接口，所以它有迭代器的属性，这里主要都是实现了迭代器的hasNext和next方法。这里主要都是调用的lookupIterator的相应hasNext和next方法，lookupIterator是懒加载迭代器。</p><p>其次，LazyIterator中的hasNext方法，静态变量PREFIX就是”META-INF/services/”目录，这也就是为什么需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件。</p><p>最后，通过反射方法<code>Class.forName()</code>加载类对象，并用newInstance方法将类实例化，并把实例化后的类缓存到providers对象中，(<code>LinkedHashMap&lt;String,S&gt;</code>类型） 然后返回实例对象。</p><hr /><p><code>java.util.ServiceLoader.java</code> 源代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br></pre></td><td class="code"><pre><code class="hljs javascript">package java.<span class="hljs-property">util</span>;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">BufferedReader</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">IOException</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">InputStream</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">io</span>.<span class="hljs-property">InputStreamReader</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">net</span>.<span class="hljs-property">URL</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">security</span>.<span class="hljs-property">AccessController</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">security</span>.<span class="hljs-property">AccessControlContext</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">security</span>.<span class="hljs-property">PrivilegedAction</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">ArrayList</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Enumeration</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Iterator</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">List</span>;<br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">NoSuchElementException</span>;<br><br><span class="hljs-comment">// ServiceLoader实现了Iterable接口，可以遍历所有的服务实现者</span><br>public final <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceLoader</span>&lt;S&gt; implements <span class="hljs-title class_">Iterable</span>&lt;S&gt;<br>&#123;<br><br>    <span class="hljs-comment">// 约定的配置文件的存放目录</span><br>    private <span class="hljs-keyword">static</span> final <span class="hljs-title class_">String</span> <span class="hljs-variable constant_">PREFIX</span> = <span class="hljs-string">&quot;META-INF/services/&quot;</span>;<br><br>    <span class="hljs-comment">// The class or interface representing the service being loaded</span><br>    private final <span class="hljs-title class_">Class</span>&lt;S&gt; service;<br><br>    <span class="hljs-comment">// The class loader used to locate, load, and instantiate providers</span><br>    private final <span class="hljs-title class_">ClassLoader</span> loader;<br><br>    <span class="hljs-comment">// The access control context taken when the ServiceLoader is created</span><br>    private final <span class="hljs-title class_">AccessControlContext</span> acc;<br><br>    <span class="hljs-comment">// Cached providers, in instantiation order</span><br>    private <span class="hljs-title class_">LinkedHashMap</span>&lt;<span class="hljs-title class_">String</span>,S&gt; providers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// The current lazy-lookup iterator</span><br>    private <span class="hljs-title class_">LazyIterator</span> lookupIterator;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Clear this loader&#x27;s provider cache so that all providers will be</span><br><span class="hljs-comment">     * reloaded.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; After invoking this method, subsequent invocations of the &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">     * #iterator() iterator&#125; method will lazily look up and instantiate</span><br><span class="hljs-comment">     * providers from scratch, just as is done by a newly-created loader.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; This method is intended for use in situations in which new providers</span><br><span class="hljs-comment">     * can be installed into a running Java virtual machine.</span><br><span class="hljs-comment">     */</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">reload</span>(<span class="hljs-params"></span>) &#123;<br>        providers.<span class="hljs-title function_">clear</span>();<br>        lookupIterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyIterator</span>(service, loader);<br>    &#125;<br><br>    private <span class="hljs-title class_">ServiceLoader</span>(<span class="hljs-title class_">Class</span>&lt;S&gt; svc, <span class="hljs-title class_">ClassLoader</span> cl) &#123;<br>        service = <span class="hljs-title class_">Objects</span>.requireNonNull(svc, <span class="hljs-string">&quot;Service interface cannot be null&quot;</span>);<br>        loader = (cl == <span class="hljs-literal">null</span>) ? <span class="hljs-title class_">ClassLoader</span>.<span class="hljs-title function_">getSystemClassLoader</span>() : cl;<br>        acc = (<span class="hljs-title class_">System</span>.<span class="hljs-title function_">getSecurityManager</span>() != <span class="hljs-literal">null</span>) ? <span class="hljs-title class_">AccessController</span>.<span class="hljs-title function_">getContext</span>() : <span class="hljs-literal">null</span>;<br>        <span class="hljs-title function_">reload</span>();<br>    &#125;<br><br>    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fail</span>(<span class="hljs-title class_">Class</span>&lt;?&gt; service, <span class="hljs-title class_">String</span> msg, <span class="hljs-title class_">Throwable</span> cause)<br>        throws <span class="hljs-title class_">ServiceConfigurationError</span><br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConfigurationError</span>(service.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot;: &quot;</span> + msg,<br>                                            cause);<br>    &#125;<br><br>    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fail</span>(<span class="hljs-title class_">Class</span>&lt;?&gt; service, <span class="hljs-title class_">String</span> msg)<br>        throws <span class="hljs-title class_">ServiceConfigurationError</span><br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceConfigurationError</span>(service.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot;: &quot;</span> + msg);<br>    &#125;<br><br>    private <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fail</span>(<span class="hljs-title class_">Class</span>&lt;?&gt; service, <span class="hljs-variable constant_">URL</span> u, int line, <span class="hljs-title class_">String</span> msg)<br>        throws <span class="hljs-title class_">ServiceConfigurationError</span><br>    &#123;<br>        <span class="hljs-title function_">fail</span>(service, u + <span class="hljs-string">&quot;:&quot;</span> + line + <span class="hljs-string">&quot;: &quot;</span> + msg);<br>    &#125;<br><br>    <span class="hljs-comment">// Parse a single line from the given configuration file, adding the name</span><br>    <span class="hljs-comment">// on the line to the names list.</span><br>    <span class="hljs-comment">//</span><br>    private int <span class="hljs-title function_">parseLine</span>(<span class="hljs-title class_">Class</span>&lt;?&gt; service, <span class="hljs-variable constant_">URL</span> u, <span class="hljs-title class_">BufferedReader</span> r, int lc,<br>                          <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; names)<br>        throws <span class="hljs-title class_">IOException</span>, <span class="hljs-title class_">ServiceConfigurationError</span><br>    &#123;<br>        <span class="hljs-title class_">String</span> ln = r.<span class="hljs-title function_">readLine</span>();<br>        <span class="hljs-keyword">if</span> (ln == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        int ci = ln.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;#&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (ci &gt;= <span class="hljs-number">0</span>) ln = ln.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, ci);<br>        ln = ln.<span class="hljs-title function_">trim</span>();<br>        int n = ln.<span class="hljs-title function_">length</span>();<br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((ln.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27; &#x27;</span>) &gt;= <span class="hljs-number">0</span>) || (ln.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;\t&#x27;</span>) &gt;= <span class="hljs-number">0</span>))<br>                <span class="hljs-title function_">fail</span>(service, u, lc, <span class="hljs-string">&quot;Illegal configuration-file syntax&quot;</span>);<br>            int cp = ln.<span class="hljs-title function_">codePointAt</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Character</span>.<span class="hljs-title function_">isJavaIdentifierStart</span>(cp))<br>                <span class="hljs-title function_">fail</span>(service, u, lc, <span class="hljs-string">&quot;Illegal provider-class name: &quot;</span> + ln);<br>            <span class="hljs-keyword">for</span> (int i = <span class="hljs-title class_">Character</span>.<span class="hljs-title function_">charCount</span>(cp); i &lt; n; i += <span class="hljs-title class_">Character</span>.<span class="hljs-title function_">charCount</span>(cp)) &#123;<br>                cp = ln.<span class="hljs-title function_">codePointAt</span>(i);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Character</span>.<span class="hljs-title function_">isJavaIdentifierPart</span>(cp) &amp;&amp; (cp != <span class="hljs-string">&#x27;.&#x27;</span>))<br>                    <span class="hljs-title function_">fail</span>(service, u, lc, <span class="hljs-string">&quot;Illegal provider-class name: &quot;</span> + ln);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!providers.<span class="hljs-title function_">containsKey</span>(ln) &amp;&amp; !names.<span class="hljs-title function_">contains</span>(ln))<br>                names.<span class="hljs-title function_">add</span>(ln);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lc + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Parse the content of the given URL as a provider-configuration file.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// @param  service</span><br>    <span class="hljs-comment">//         The service type for which providers are being sought;</span><br>    <span class="hljs-comment">//         used to construct error detail strings</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// @param  u</span><br>    <span class="hljs-comment">//         The URL naming the configuration file to be parsed</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// @return A (possibly empty) iterator that will yield the provider-class</span><br>    <span class="hljs-comment">//         names in the given configuration file that are not yet members</span><br>    <span class="hljs-comment">//         of the returned set</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// @throws ServiceConfigurationError</span><br>    <span class="hljs-comment">//         If an I/O error occurs while reading from the given URL, or</span><br>    <span class="hljs-comment">//         if a configuration-file format error is detected</span><br>    <span class="hljs-comment">//</span><br>    private <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">parse</span>(<span class="hljs-title class_">Class</span>&lt;?&gt; service, <span class="hljs-variable constant_">URL</span> u)<br>        throws <span class="hljs-title class_">ServiceConfigurationError</span><br>    &#123;<br>        <span class="hljs-title class_">InputStream</span> <span class="hljs-keyword">in</span> = <span class="hljs-literal">null</span>;<br>        <span class="hljs-title class_">BufferedReader</span> r = <span class="hljs-literal">null</span>;<br>        <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">String</span>&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">in</span> = u.<span class="hljs-title function_">openStream</span>();<br>            r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">in</span>, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>            int lc = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> ((lc = <span class="hljs-title function_">parseLine</span>(service, u, r, lc, names)) &gt;= <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> x) &#123;<br>            <span class="hljs-title function_">fail</span>(service, <span class="hljs-string">&quot;Error reading configuration file&quot;</span>, x);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) r.<span class="hljs-title function_">close</span>();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">in</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">in</span>.<span class="hljs-title function_">close</span>();<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> y) &#123;<br>                <span class="hljs-title function_">fail</span>(service, <span class="hljs-string">&quot;Error closing configuration file&quot;</span>, y);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> names.<span class="hljs-title function_">iterator</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// Private inner class implementing fully-lazy provider lookup</span><br>    <span class="hljs-comment">//</span><br>    private <span class="hljs-keyword">class</span> <span class="hljs-title class_">LazyIterator</span><br>        implements <span class="hljs-title class_">Iterator</span>&lt;S&gt;<br>    &#123;<br><br>        <span class="hljs-title class_">Class</span>&lt;S&gt; service;<br>        <span class="hljs-title class_">ClassLoader</span> loader;<br>        <span class="hljs-title class_">Enumeration</span>&lt;<span class="hljs-variable constant_">URL</span>&gt; configs = <span class="hljs-literal">null</span>;<br>        <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-title class_">String</span>&gt; pending = <span class="hljs-literal">null</span>;<br>        <span class="hljs-title class_">String</span> nextName = <span class="hljs-literal">null</span>;<br><br>        private <span class="hljs-title class_">LazyIterator</span>(<span class="hljs-title class_">Class</span>&lt;S&gt; service, <span class="hljs-title class_">ClassLoader</span> loader) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">service</span> = service;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">loader</span> = loader;<br>        &#125;<br><br>        private boolean <span class="hljs-title function_">hasNextService</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (nextName != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (configs == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-title class_">String</span> fullName = <span class="hljs-variable constant_">PREFIX</span> + service.<span class="hljs-title function_">getName</span>();<br>                    <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>                        configs = <span class="hljs-title class_">ClassLoader</span>.<span class="hljs-title function_">getSystemResources</span>(fullName);<br>                    <span class="hljs-keyword">else</span><br>                        configs = loader.<span class="hljs-title function_">getResources</span>(fullName);<br>                &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> x) &#123;<br>                    <span class="hljs-title function_">fail</span>(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> ((pending == <span class="hljs-literal">null</span>) || !pending.<span class="hljs-title function_">hasNext</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (!configs.<span class="hljs-title function_">hasMoreElements</span>()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                pending = <span class="hljs-title function_">parse</span>(service, configs.<span class="hljs-title function_">nextElement</span>());<br>            &#125;<br>            nextName = pending.<span class="hljs-title function_">next</span>();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        private S <span class="hljs-title function_">nextService</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">hasNextService</span>())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            <span class="hljs-title class_">String</span> cn = nextName;<br>            nextName = <span class="hljs-literal">null</span>;<br>            <span class="hljs-title class_">Class</span>&lt;?&gt; c = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c = <span class="hljs-title class_">Class</span>.<span class="hljs-title function_">forName</span>(cn, <span class="hljs-literal">false</span>, loader);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">ClassNotFoundException</span> x) &#123;<br>                <span class="hljs-title function_">fail</span>(service,<br>                     <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not found&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!service.<span class="hljs-title function_">isAssignableFrom</span>(c)) &#123;<br>                <span class="hljs-title function_">fail</span>(service,<br>                     <span class="hljs-string">&quot;Provider &quot;</span> + cn  + <span class="hljs-string">&quot; not a subtype&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 用反射机制，创建接口实现对象</span><br>                S p = service.<span class="hljs-title function_">cast</span>(c.<span class="hljs-title function_">newInstance</span>());<br>               <span class="hljs-comment">// 放进 ServiceLoader的providers容器里面</span><br>                providers.<span class="hljs-title function_">put</span>(cn, p);<br>                <span class="hljs-keyword">return</span> p;<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Throwable</span> x) &#123;<br>                <span class="hljs-title function_">fail</span>(service,<br>                     <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; could not be instantiated&quot;</span>,<br>                     x);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();          <span class="hljs-comment">// This cannot happen</span><br>        &#125;<br><br>        public boolean <span class="hljs-title function_">hasNext</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (acc == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">hasNextService</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title class_">PrivilegedAction</span>&lt;<span class="hljs-title class_">Boolean</span>&gt; action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;<span class="hljs-title class_">Boolean</span>&gt;() &#123;<br>                    public <span class="hljs-title class_">Boolean</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title function_">hasNextService</span>(); &#125;<br>                &#125;;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title class_">AccessController</span>.<span class="hljs-title function_">doPrivileged</span>(action, acc);<br>            &#125;<br>        &#125;<br><br>        public S <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">if</span> (acc == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title function_">nextService</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-title class_">PrivilegedAction</span>&lt;S&gt; action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;S&gt;() &#123;<br>                    public S <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-title function_">nextService</span>(); &#125;<br>                &#125;;<br>                <span class="hljs-keyword">return</span> <span class="hljs-title class_">AccessController</span>.<span class="hljs-title function_">doPrivileged</span>(action, acc);<br>            &#125;<br>        &#125;<br><br>        public <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Lazily loads the available providers of this loader&#x27;s service.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; The iterator returned by this method first yields all of the</span><br><span class="hljs-comment">     * elements of the provider cache, in instantiation order.  It then lazily</span><br><span class="hljs-comment">     * loads and instantiates any remaining providers, adding each one to the</span><br><span class="hljs-comment">     * cache in turn.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; To achieve laziness the actual work of parsing the available</span><br><span class="hljs-comment">     * provider-configuration files and instantiating providers must be done by</span><br><span class="hljs-comment">     * the iterator itself.  Its &#123;<span class="hljs-doctag">@link</span> java.util.Iterator#hasNext hasNext&#125; and</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> java.util.Iterator#next next&#125; methods can therefore throw a</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@link</span> ServiceConfigurationError&#125; if a provider-configuration file</span><br><span class="hljs-comment">     * violates the specified format, or if it names a provider class that</span><br><span class="hljs-comment">     * cannot be found and instantiated, or if the result of instantiating the</span><br><span class="hljs-comment">     * class is not assignable to the service type, or if any other kind of</span><br><span class="hljs-comment">     * exception or error is thrown as the next provider is located and</span><br><span class="hljs-comment">     * instantiated.  To write robust code it is only necessary to catch &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">     * ServiceConfigurationError&#125; when using a service iterator.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; If such an error is thrown then subsequent invocations of the</span><br><span class="hljs-comment">     * iterator will make a best effort to locate and instantiate the next</span><br><span class="hljs-comment">     * available provider, but in general such recovery cannot be guaranteed.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;blockquote style=&quot;font-size: smaller; line-height: 1.2&quot;&gt;&lt;span</span><br><span class="hljs-comment">     * style=&quot;padding-right: 1em; font-weight: bold&quot;&gt;Design Note&lt;/span&gt;</span><br><span class="hljs-comment">     * Throwing an error in these cases may seem extreme.  The rationale for</span><br><span class="hljs-comment">     * this behavior is that a malformed provider-configuration file, like a</span><br><span class="hljs-comment">     * malformed class file, indicates a serious problem with the way the Java</span><br><span class="hljs-comment">     * virtual machine is configured or is being used.  As such it is</span><br><span class="hljs-comment">     * preferable to throw an error rather than try to recover or, even worse,</span><br><span class="hljs-comment">     * fail silently.&lt;/blockquote&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; The iterator returned by this method does not support removal.</span><br><span class="hljs-comment">     * Invoking its &#123;<span class="hljs-doctag">@link</span> java.util.Iterator#remove() remove&#125; method will</span><br><span class="hljs-comment">     * cause an &#123;<span class="hljs-doctag">@link</span> UnsupportedOperationException&#125; to be thrown.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@implNote</span> When adding providers to the cache, the &#123;<span class="hljs-doctag">@link</span> #iterator</span><br><span class="hljs-comment">     * Iterator&#125; processes resources in the order that the &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment">     * java.lang.ClassLoader#getResources(java.lang.String)</span><br><span class="hljs-comment">     * ClassLoader.getResources(String)&#125; method finds the service configuration</span><br><span class="hljs-comment">     * files.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  An iterator that lazily loads providers for this loader&#x27;s</span><br><span class="hljs-comment">     *          service</span><br><span class="hljs-comment">     */</span><br>    public <span class="hljs-title class_">Iterator</span>&lt;S&gt; <span class="hljs-title function_">iterator</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;S&gt;() &#123;<br><br>            <span class="hljs-title class_">Iterator</span>&lt;<span class="hljs-title class_">Map</span>.<span class="hljs-property">Entry</span>&lt;<span class="hljs-title class_">String</span>,S&gt;&gt; knownProviders<br>                = providers.<span class="hljs-title function_">entrySet</span>().<span class="hljs-title function_">iterator</span>();<br><br>            public boolean <span class="hljs-title function_">hasNext</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">if</span> (knownProviders.<span class="hljs-title function_">hasNext</span>())<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> lookupIterator.<span class="hljs-title function_">hasNext</span>();<br>            &#125;<br><br>            public S <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">if</span> (knownProviders.<span class="hljs-title function_">hasNext</span>())<br>                    <span class="hljs-keyword">return</span> knownProviders.<span class="hljs-title function_">next</span>().<span class="hljs-title function_">getValue</span>();<br>                <span class="hljs-keyword">return</span> lookupIterator.<span class="hljs-title function_">next</span>();<br>            &#125;<br><br>            public <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>            &#125;<br><br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a new service loader for the given service type and class</span><br><span class="hljs-comment">     * loader.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  &lt;S&gt; the class of the service type</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  <span class="hljs-variable">service</span></span><br><span class="hljs-comment">     *         The interface or abstract class representing the service</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  <span class="hljs-variable">loader</span></span><br><span class="hljs-comment">     *         The class loader to be used to load provider-configuration files</span><br><span class="hljs-comment">     *         and provider classes, or &lt;tt&gt;null&lt;/tt&gt; if the system class</span><br><span class="hljs-comment">     *         loader (or, failing that, the bootstrap class loader) is to be</span><br><span class="hljs-comment">     *         used</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> A new service loader</span><br><span class="hljs-comment">     */</span><br>    public <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-title class_">ServiceLoader</span>&lt;S&gt; <span class="hljs-title function_">load</span>(<span class="hljs-params">Class&lt;S&gt; service,</span><br><span class="hljs-params">                                            ClassLoader loader</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a new service loader for the given service type, using the</span><br><span class="hljs-comment">     * current thread&#x27;s &#123;<span class="hljs-doctag">@linkplain</span> java.lang.Thread#getContextClassLoader</span><br><span class="hljs-comment">     * context class loader&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; An invocation of this convenience method of the form</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment">     * ServiceLoader.load(&lt;i&gt;service&lt;/i&gt;)&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * is equivalent to</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment">     * ServiceLoader.load(&lt;i&gt;service&lt;/i&gt;,</span><br><span class="hljs-comment">     *                    Thread.currentThread().getContextClassLoader())&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  &lt;S&gt; the class of the service type</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  <span class="hljs-variable">service</span></span><br><span class="hljs-comment">     *         The interface or abstract class representing the service</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> A new service loader</span><br><span class="hljs-comment">     */</span><br>    public <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-title class_">ServiceLoader</span>&lt;S&gt; <span class="hljs-title function_">load</span>(<span class="hljs-params">Class&lt;S&gt; service</span>) &#123;<br>        <span class="hljs-title class_">ClassLoader</span> cl = <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">getContextClassLoader</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ServiceLoader</span>.<span class="hljs-title function_">load</span>(service, cl);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates a new service loader for the given service type, using the</span><br><span class="hljs-comment">     * extension class loader.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; This convenience method simply locates the extension class loader,</span><br><span class="hljs-comment">     * call it &lt;tt&gt;&lt;i&gt;extClassLoader&lt;/i&gt;&lt;/tt&gt;, and then returns</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;blockquote&gt;&lt;pre&gt;</span><br><span class="hljs-comment">     * ServiceLoader.load(&lt;i&gt;service&lt;/i&gt;, &lt;i&gt;extClassLoader&lt;/i&gt;)&lt;/pre&gt;&lt;/blockquote&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; If the extension class loader cannot be found then the system class</span><br><span class="hljs-comment">     * loader is used; if there is no system class loader then the bootstrap</span><br><span class="hljs-comment">     * class loader is used.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt; This method is intended for use when only installed providers are</span><br><span class="hljs-comment">     * desired.  The resulting service will only find and load providers that</span><br><span class="hljs-comment">     * have been installed into the current Java virtual machine; providers on</span><br><span class="hljs-comment">     * the application&#x27;s class path will be ignored.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  &lt;S&gt; the class of the service type</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span>  <span class="hljs-variable">service</span></span><br><span class="hljs-comment">     *         The interface or abstract class representing the service</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> A new service loader</span><br><span class="hljs-comment">     */</span><br>    public <span class="hljs-keyword">static</span> &lt;S&gt; <span class="hljs-title class_">ServiceLoader</span>&lt;S&gt; <span class="hljs-title function_">loadInstalled</span>(<span class="hljs-params">Class&lt;S&gt; service</span>) &#123;<br>        <span class="hljs-title class_">ClassLoader</span> cl = <span class="hljs-title class_">ClassLoader</span>.<span class="hljs-title function_">getSystemClassLoader</span>();<br>        <span class="hljs-title class_">ClassLoader</span> prev = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">while</span> (cl != <span class="hljs-literal">null</span>) &#123;<br>            prev = cl;<br>            cl = cl.<span class="hljs-title function_">getParent</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">ServiceLoader</span>.<span class="hljs-title function_">load</span>(service, prev);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a string describing this service.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  A descriptive string</span><br><span class="hljs-comment">     */</span><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;java.util.ServiceLoader[&quot;</span> + service.<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ol type="1"><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fjy107600%2Fp%2F11464985.html">https://www.cnblogs.com/jy107600/p/11464985.html</a> <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fblog.itpub.net%2F69912579%2Fviewspace-2656555%2F">http://blog.itpub.net/69912579/viewspace-2656555/</a></li><li><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000020422160">https://segmentfault.com/a/1190000020422160</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZK常用命令</title>
    <link href="/2021/11/09/ZK%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/09/ZK%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="常用命令">常用命令</h1><table><thead><tr class="header"><th>启动ZK服务</th><th>bin/zkServer.sh start</th></tr></thead><tbody><tr class="odd"><td>查看ZK服务状态</td><td>bin/zkServer.sh status</td></tr><tr class="even"><td>停止ZK服务</td><td>bin/zkServer.sh stop</td></tr><tr class="odd"><td>重启ZK服务</td><td>bin/zkServer.sh restart</td></tr><tr class="even"><td>连接服务器</td><td>zkCli.sh -server 127.0.0.1:2181</td></tr></tbody></table><h1 id="客户端连接">客户端连接</h1><p>运行 <code>zkCli.sh –server &lt;ip&gt;</code>进入命令行工具</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/Center.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在192.168.106.82服务器上连接到192.168.106.81服务器下的zk</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@hadoop3bin]<span class="hljs-comment"># zkCli.sh -server 192.168.106.81:2181</span><br></code></pre></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/Center1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="查看znode路径">查看znode路径</h1><p>查看根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: 192.168.106.81:2181(CONNECTED) 0] <span class="hljs-built_in">ls</span> /<br>[zookeeper, mygirls]<br></code></pre></td></tr></table></figure><p>查看其它节点中的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: 192.168.106.81:2181(CONNECTED) 1] <span class="hljs-built_in">ls</span> /mygirls<br>[liuyifei, angelababy]<br>[zk: 192.168.106.81:2181(CONNECTED) 2] <span class="hljs-built_in">ls</span> /zookeeper<br>[quota]<br></code></pre></td></tr></table></figure><h1 id="创建节点">创建节点</h1><p>创建testnode节点，关联字符串”zz”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: 192.168.106.81:2181(CONNECTED) 3] create /zookeeper/testnode <span class="hljs-string">&quot;zzzzzzz&quot;</span><br>Created /zookeeper/testnode<br></code></pre></td></tr></table></figure><h1 id="获取znode数据查看节点内容设置节点内容删除节点">获取znode数据，查看节点内容，设置节点内容，删除节点</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: 192.168.106.81:2181(CONNECTED) 4] get /mygirls<br><br>lsadasdasd<br><br>cZxid = 0x800000002<br><br>ctime = Wed Jan 04 23:26:09 CST 2017<br><br>mZxid = 0x80000000c<br><br>mtime = Wed Jan 04 23:38:06 CST 2017<br><br>pZxid = 0x800000004<br><br>cversion = 2<br><br>dataVersion = 6<br><br>aclVersion = 0<br><br>ephemeralOwner = 0x0<br><br>dataLength = 10<br><br>numChildren = 2<br><br>[zk: 192.168.106.81:2181(CONNECTED) 5]<br></code></pre></td></tr></table></figure><p>设置节点内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: 192.168.106.81:2181(CONNECTED) 6] <span class="hljs-built_in">ls</span> /mygirls<br><br>[liuyifei, angelababy]<br><br>[zk: 192.168.106.81:2181(CONNECTED) 7] <span class="hljs-built_in">set</span> /mygirls/liuyifei aaaaaaa<br><br>cZxid = 0x800000003<br><br>ctime = Wed Jan 04 23:27:56 CST 2017<br><br>mZxid = 0x800000010<br><br>mtime = Thu Jan 05 00:50:37 CST 2017<br><br>pZxid = 0x800000003<br><br>cversion = 0<br><br>dataVersion = 1<br><br>aclVersion = 0<br><br>ephemeralOwner = 0x0<br><br>dataLength = 7<br><br>numChildren = 0<br><br>[zk: 192.168.106.81:2181(CONNECTED) 8] get /mygirls/liuyifei<br><br>aaaaaaa<br><br>cZxid = 0x800000003<br><br>ctime = Wed Jan 04 23:27:56 CST 2017<br><br>mZxid = 0x800000010<br><br>mtime = Thu Jan 05 00:50:37 CST 2017<br><br>pZxid = 0x800000003<br><br>cversion = 0<br><br>dataVersion = 1<br><br>aclVersion = 0<br><br>ephemeralOwner = 0x0<br><br>dataLength = 7<br><br>numChildren = 0<br><br>[zk: 192.168.106.81:2181(CONNECTED) 9]<br></code></pre></td></tr></table></figure><p>删除节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: 192.168.106.81:2181(CONNECTED) 15] <span class="hljs-built_in">ls</span> /zookeeper<br><br>[testnode, quota]<br><br>[zk: 192.168.106.81:2181(CONNECTED) 16] delete /zookeeper/testnode<br><br>[zk: 192.168.106.81:2181(CONNECTED) 17] <span class="hljs-built_in">ls</span> /zookeeper<br><br>[quota]<br><br>[zk: 192.168.106.81:2181(CONNECTED) 18]<br></code></pre></td></tr></table></figure><p>退出客户端的命令：quit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[zk: 192.168.106.81:2181(CONNECTED) 18] quit<br><br>Quitting...<br><br>2017-01-05 00:58:21,076 [myid:] - INFO  [main:ZooKeeper@684] - Session: 0x25969e0732e0001 closed<br><br>2017-01-05 00:58:21,076 [myid:] - INFO  [main-EventThread:ClientCnxn<span class="hljs-variable">$EventThread</span>@509] - EventThread shut down<br><br>[root@hadoop3 bin]<span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure><h1 id="监听znode事件">监听znode事件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /mygirls watch   <span class="hljs-comment">## 就对一个节点的子节点变化事件注册了监听</span><br></code></pre></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/Center2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当在82服务器上写<code>ls /mygirls watch</code>的时候，在81上创建一个znode,发现80上的上图出现提醒。</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">get /mygirls watch   <span class="hljs-comment">## 就对一个节点的数据内容变化事件注册了监听</span><br></code></pre></td></tr></table></figure></p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/Center3.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/Center4.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>开始的时候在80上执行<code>get /mygirls watch</code>，接着在81上执行<code>set /mygirls bbbbbb</code>，执行完成之后，发现在80上的右上角有消息提醒。</p><p>注意：监听器只生效一次</p><p>监听器的工作机制，其实是在客户端会专门创建一个监听线程，在本机的一个端口上等待zk集群发送过来事件</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST/img/Center5.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="telnet连接zookeeper">telnet连接zookeeper</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">telnet 192.168.106.82 2181<br></code></pre></td></tr></table></figure><p>成功之后，输入conf，会出现一下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">clientPort=2181<br><br>dataDir=/home/tuzq/software/zookeeper/zkdata/version-2<br><br>dataLogDir=/home/tuzq/software/zookeeper/log/version-2<br><br>tickTime=2000                                     <br><br>maxClientCnxns=60                                                                                                                                                   <br><br>minSessionTimeout=4000                                                                           <br><br>maxSessionTimeout=40000                                                                                                                                <br><br>serverId=3                                                                                                                                                                                                                   <br><br>initLimit=10<br><br>syncLimit=5<br><br>electionAlg=3<br><br>electionPort=3888<br><br>quorumPort=2888<br><br>peerType=0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Infrastructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake简单入门</title>
    <link href="/2021/10/30/CMake-Link/"/>
    <url>/2021/10/30/CMake-Link/</url>
    
    <content type="html"><![CDATA[<h1 id="新建项目">新建项目</h1><p>新建项目t4，目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">-src<br>-main.c<br>-CmakeLists.txt<br>-include<br>-hello<br>-hello.h<br>-thirdPatch<br>-libhello.a<br>-libhello.so<br>-libhello.so.1<br>-libhello.so.1.2<br>-CmakeLists.txt<br></code></pre></td></tr></table></figure><p>该程序引入了自建的hello.h程序库包含了函数<code>func()</code>。main.c的内容如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//main.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hello.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    func();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="cmake变量">CMake变量</h1><h2 id="一般变量">一般变量</h2><h3 id="cmake变量引用的方式">CMake变量引用的方式</h3><p>使用<code>$&#123;&#125;</code>进行变量的引用。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-comment">#返回项目名称</span><br></code></pre></td></tr></table></figure><p>在 IF 等语句中,是直接使用变量名而不通过<code>$&#123;&#125;</code>取值。</p><h3 id="cmake自定义变量的方式">cmake自定义变量的方式</h3><p>cmake变量定义的方式有两种：隐式定义和显式定义。</p><p><em>隐式定义</em></p><p>前面举了一个隐式定义的例子，就是<code>PROJECT</code>指令，他会隐式的定义<code>_BINARY_DIR</code>和<code>_SOURCE_DIR</code>两个变量。</p><p><em>显示定义</em></p><p>显式定义的例子我们前面也提到了,使用 <code>SET</code> 指令,就可以构建一个自定义变量了。比如:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SET</span>(HELLO_SRC main.c)<br></code></pre></td></tr></table></figure><p>就可以通过<code>$&#123;HELLO_SRC&#125;</code>来引用这个自定义变量(main.c)了.</p><h2 id="环境变量">环境变量</h2><h3 id="调用环境变量的方式">调用环境变量的方式</h3><p>使用 <code>$ENV&#123;NAME&#125;</code>指令就可以调用系统的环境变量了。比如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">MESSAGE(STATUS “HOME <span class="hljs-built_in">dir</span>: <span class="hljs-variable">$ENV</span>&#123;HOME&#125;”)<br></code></pre></td></tr></table></figure><h3 id="设置环境变量的方式">设置环境变量的方式</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">SET</span>(ENV&#123; 变量名 &#125; 值 )<br></code></pre></td></tr></table></figure><h2 id="cmake常用变量">CMake常用变量</h2><p>使用<code>cmake --help-variable-list</code>可以查看cmake中默认变量。</p><table><thead><tr class="header"><th>变量名</th><th style="text-align: center;">变量说明</th></tr></thead><tbody><tr class="odd"><td>PROJECT_NAME</td><td style="text-align: center;">返回通过PROJECT指令定义的项目名称</td></tr><tr class="even"><td>PROJECT_SOURCE_DIR</td><td style="text-align: center;">CMake源码地址，即cmake命令后指定的地址</td></tr><tr class="odd"><td>PROJECT_BINARY_DIR</td><td style="text-align: center;">运行cmake命令的目录,通常是PROJECT_SOURCE_DIR下的build目录</td></tr><tr class="even"><td>CMAKE_MODULE_PATH</td><td style="text-align: center;">定义自己的cmake模块所在的路径</td></tr><tr class="odd"><td>CMAKE_CURRENT_SOURCE_DIR</td><td style="text-align: center;">当前处理的CMakeLists.txt所在的路径</td></tr><tr class="even"><td>CMAKE_CURRENT_LIST_DIR</td><td style="text-align: center;">当前文件夹路径</td></tr><tr class="odd"><td>CMAKE_CURRENT_LIST_FILE</td><td style="text-align: center;">输出调用这个变量的CMakeLists.txt的完整路径</td></tr><tr class="even"><td>CMAKE_CURRENT_LIST_LINE</td><td style="text-align: center;">输出这个变量所在的行</td></tr><tr class="odd"><td>CMAKE_RUNTIME_OUTPUT_DIRECTORY</td><td style="text-align: center;">生成可执行文件路径</td></tr><tr class="even"><td>CMAKE_LIBRARY_OUTPUT_DIRECTORY</td><td style="text-align: center;">生成库的文件夹路径</td></tr><tr class="odd"><td>CMAKE_BUILD_TYPE</td><td style="text-align: center;">指定基于make的产生器的构建类型（Release，Debug）</td></tr><tr class="even"><td>CMAKE_C_FLAGS</td><td style="text-align: center;"><em>.C文件编译选项，如 </em>-std=c99 -O3 -march=native*</td></tr><tr class="odd"><td>CMAKE_CXX_FLAGS</td><td style="text-align: center;"><em>.CPP文件编译选项，如 </em>-std=c++11 -O3 -march=native*</td></tr><tr class="even"><td>CMAKE_CURRENT_BINARY_DIR</td><td style="text-align: center;">target编译目录</td></tr><tr class="odd"><td>CMAKE_INCLUDE_PATH</td><td style="text-align: center;">环境变量,非cmake变量</td></tr><tr class="even"><td>CMAKE_LIBRARY_PATH</td><td style="text-align: center;">环境变量</td></tr><tr class="odd"><td>CMAKE_STATIC_LIBRARY_PREFIX</td><td style="text-align: center;">静态库前缀, Linux下默认为lib</td></tr><tr class="even"><td>CMAKE_STATIC_LIBRARY_SUFFIX</td><td style="text-align: center;">静态库后缀，Linux下默认为.a</td></tr><tr class="odd"><td>CMAKE_SHARED_LIBRARY_PREFIX</td><td style="text-align: center;">动态库前缀，Linux下默认为lib</td></tr><tr class="even"><td>CMAKE_SHARED_LIBRARY_SUFFIX</td><td style="text-align: center;">动态库后缀，Linux下默认为.so</td></tr><tr class="odd"><td>BUILD_SHARED_LIBS</td><td style="text-align: center;">如果为ON，则add_library默认创建共享库</td></tr><tr class="even"><td>CMAKE_INSTALL_PREFIX</td><td style="text-align: center;">配置安装路径，默认为/usr/local</td></tr><tr class="odd"><td>CMAKE_ABSOLUTE_DESTINATION_FILES</td><td style="text-align: center;">安装文件列表时使用ABSOLUTE DESTINATION 路径</td></tr><tr class="even"><td>CMAKE_AUTOMOC_RELAXED_MODE</td><td style="text-align: center;">在严格和宽松的automoc模式间切换</td></tr><tr class="odd"><td>CMAKE_BACKWARDS_COMPATIBILITY</td><td style="text-align: center;">构建工程所需要的CMake版本</td></tr><tr class="even"><td>CMAKE_COLOR_MAKEFILE</td><td style="text-align: center;">开启时，使用Makefile产生器会产生彩色输出</td></tr><tr class="odd"><td>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</td><td style="text-align: center;">用来控制IF ELSE语句的书写方式</td></tr></tbody></table><p>使用<code>cmake --help-variable &lt;cmake变量名&gt;</code> 可以查看该变量的默认值和使用场景，简单使用就可以不用再去查cmake手册了。</p><ul><li>运行CMake，并使用<code>cmake</code> GUI工具查看缓存。然后，您将获得所有变量。</li><li>或者使用<code>-LH</code>.运行CMake，然后将在配置后打印所有变量。</li></ul><h3 id="主要的开关选项">主要的开关选项:</h3><ol type="1"><li><p><code>CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS</code>，用来控制 IF ELSE 语句的书写方式,在下一节语法部分会讲到。</p></li><li><p><code>BUILD_SHARED_LIBS</code>这个开关用来控制默认的库编译方式,如果不进行设置,使用 ADD_LIBRARY 并没有指定库类型的情况下,默认编译生成的库都是静态库。如果 <code>SET(BUILD_SHARED_LIBS ON)</code> 后,默认生成的为动态库。</p></li><li><p><code>CMAKE_C_FLAGS</code> 设置 C 编译选项,也可以通过指令 <code>ADD_DEFINITIONS()</code> 添加。</p></li><li><p><strong><code>CMAKE_CXX_FLAGS</code> 设置 C++ 编译选项,也可以通过指令 <code>ADD_DEFINITIONS()</code> 添加</strong>。</p></li></ol><h3 id="系统信息">系统信息</h3><ol type="1"><li><code>CMAKE_MAJOR_VERSION</code> , CMAKE 主版本号,比如 2.4.6 中的 2</li><li><code>CMAKE_MINOR_VERSION</code> , CMAKE 次版本号,比如 2.4.6 中的 4</li><li><code>CMAKE_PATCH_VERSION</code> , CMAKE 补丁等级,比如 2.4.6 中的 6</li><li><code>CMAKE_SYSTEM</code>,系统名称,比如 Linux-2.6.22</li><li><code>CMAKE_SYSTEM_NAME</code> ,不包含版本的系统名,比如 Linux</li><li><code>CMAKE_SYSTEM_VERSION</code> ,系统版本,比如 2.6.22</li><li><code>CMAKE_SYSTEM_PROCESSOR</code> ,处理器名称,比如 i686.</li><li><code>UNIX</code> ,在所有的类 UNIX 平台为 TRUE ,包括 OS X 和 cygwin</li><li><code>WIN32</code> ,在所有的 win32 平台为 TRUE ,包括 cygwin</li></ol><h1 id="指定c标准">指定C++标准</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># https://cmake.org/cmake/help/latest/prop_tgt/CXX_STANDARD.html</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">17</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">ON</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-comment"># expected behaviour</span><br><span class="hljs-comment">#set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17&quot;)</span><br></code></pre></td></tr></table></figure><p>Modern CMake propose an interface for this purpose <code>target_compile_features</code>. Documentation is here: <a href="https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#requiring-language-standards">Requiring Language Standards</a>. Use it like this:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">target_compile_features</span><span class="hljs-params">($&#123;PROJECT_NAME&#125; PRIVATE cxx_std_17)</span></span><br></code></pre></td></tr></table></figure><p>In CMake, <code>PUBLIC</code> (for everyone) = <code>INTERFACE</code> (for the other) + <code>PRIVATE</code> (for me)</p><h1 id="引入第三方头文件">引入第三方头文件</h1><p>hello.h 位于<code>/root/cpp_test/backup/cmake_test/t4/include/hello</code>目录中，并没有位于系统标准的头文件路径，为了让我们的工程能够找到 hello.h 头文件，我们需要引入一个新的指令<code>INCLUDE_DIRECTORIES</code>，其完整语法为: <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)<br></code></pre></td></tr></table></figure></p><p>这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，<strong>如果路径中包含了空格，可以使用双引号将它括起来</strong>，<strong>默认的行为是追加到当前的头文件搜索路径的后面</strong>，你可以通过两种方式来进行控制搜索路径添加的方式:</p><p>现在我们在 src/CMakeLists.txt 中添加一个头文件搜索路径，方式很简单，加入: <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(/root/cpp_test/backup/cmake_test/t4/<span class="hljs-keyword">include</span>/hello)<br></code></pre></td></tr></table></figure></p><p>进入 build 目录，重新进行构建，这是找不到 hello.h 的错误已经消失，但是出现了一个新的错误:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">main.c:(.<span class="hljs-built_in">text</span>+<span class="hljs-number">0x12</span>): undefined <span class="hljs-keyword">reference</span> <span class="hljs-keyword">to</span> `func&#x27; <br></code></pre></td></tr></table></figure><p>因为我们并没有 link 到共享库 libhello 上。</p><h1 id="为-target-添加共享库">为 target 添加共享库</h1><p>我们现在需要完成的任务是将目标文件链接到 libhello，这里我们需要引入两个新的指令 <code>LINK_DIRECTORIES</code> 和 <code>TARGET_LINK_LIBRARIES</code></p><h2 id="add_library">add_library</h2><p>该指令的主要作用就是将指定的源文件生成链接文件，然后添加到工程中去。该指令常用的语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]<br>            [EXCLUDE_FROM_ALL]<br>            [source1] [source2] [...])<br></code></pre></td></tr></table></figure><p>其中<code>&lt;name&gt;</code>表示库文件的名字，该库文件会根据命令里列出的源文件来创建。而<code>STATIC</code>、<code>SHARED</code>和<code>MODULE</code>的作用是指定生成的库文件的类型:</p><ul><li><p><code>STATIC</code>库是目标文件的归档文件，在链接其它目标的时候使用。</p></li><li><p><strong><code>SHARED</code>库会被动态链接（动态链接库）</strong>，在运行时会被加载。</p></li><li><p>MODULE库是一种不会被链接到其它目标中的插件，但是可能会在运行时使用dlopen-系列的函数。</p></li></ul><p><strong>默认状态下，库文件将会在于源文件目录树的构建目录树的位置被创建</strong>，该命令也会在这里被调用。</p><p>而语法中的source1 source2分别表示各个源文件。</p><h2 id="link_directories">link_directories</h2><p>该指令的作用主要是指定要链接的库文件的路径，该指令有时候不一定需要。因为<code>find_package</code>和<code>find_library</code>指令可以得到库文件的绝对路径。不过你自己写的动态库文件放在自己新建的目录下时，可以用该指令指定该目录的路径以便工程能够找到。</p><p><code>LINK_DIRECTORIES</code> 的全部语法是:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">LINK_DIRECTORIES</span>(directory1 directory2 ...) <span class="hljs-comment">#对应tasks的 &quot;-L&quot;参数  .dll等</span><br></code></pre></td></tr></table></figure><p>这个指令非常简单，<strong>添加非标准的共享库搜索路径</strong>，比如，在工程内部同时存在共享库和可 执行二进制，在编译时就需要指定一下这些共享库的路径。对应tasks的 "<code>-L</code>"参数 .dll等。</p><p>注意：<code>LINK_DIRECTORIES</code>放在<code>ADD_EXECUTABLE</code>之前</p><p>官网不推荐使用<code>LINK_DIRECTORIES</code>，原文如下：</p><blockquote><p>Note that this command <a href="#link_directories">link_directories</a> is rarely necessary. Library locations returned by find_package() and find_library() are absolute paths. Pass these absolute library file paths directly to the target_link_libraries() command. CMake will ensure the linker finds them.</p></blockquote><h2 id="target_link_libraries">target_link_libraries</h2><p>这个例子中我们没有用到这个指令而是使用<code>TARGET_LINK_LIBRARIES</code> 。 <code>TARGET_LINK_LIBRARIES</code> 的全部语法是:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">target_link_libraries</span>(&lt;<span class="hljs-keyword">target</span>&gt; [item1] [item2] [...]<br>                      [[debug|optimized|general] &lt;item&gt;] ...)<br></code></pre></td></tr></table></figure><p>上述指令中的<strong><code>&lt;target&gt;</code>是指通过<code>add_executable()</code>和<code>add_library()</code>指令生成已经创建的目标文件</strong>。而<code>[item]</code>表示库文件没有后缀的名字。默认情况下，库依赖项是传递的。当这个目标链接到另一个目标时，链接到这个目标的库也会出现在另一个目标的连接线上。这个传递的接口存储在<code>interface_link_libraries</code>的目标属性中，可以通过设置该属性直接重写传递接口。</p><p>这个指令可以用来为 target 添加需要链接的共享库，本例中是一个可执行文件，但是同样可以用于为自己编写的共享库添加共享库链接，libhello.so.1.2共享库的路径为<code>/root/cpp_test/backup/cmake_test/t4/thirdPath/libhello.so.1.2</code>。 为了解决我们前面遇到的 func 未定义错误，我们需要作的是向<code>src/CMakeLists.txt</code> 中添加如下指令:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main /root/cpp_test/backup/cmake_test/t4/thirdPath/libhello.so.<span class="hljs-number">1.2</span>)<br></code></pre></td></tr></table></figure><p>注意：</p><ol type="1"><li><p><code>target_link_libraries</code> 要在 <code>add_executable</code> 之后</p></li><li><p><code>link_libraries</code> 要在 <code>add_executable</code> 之前，对应tasks的 "<code>-l</code>"参数 .lib。目前<a href="https://cmake.org/cmake/help/v3.0/command/link_libraries.html">文档</a>中说 <code>link_libraries</code>已经被废弃了</p><blockquote><p>Deprecated. Use the target_link_libraries() command instead.</p></blockquote></li></ol><h2 id="链接库综合例子">链接库综合例子</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(<br><span class="hljs-variable">$&#123;catkin_include_dirs&#125;</span><br><span class="hljs-variable">$&#123;svo_source_dir&#125;</span>/<span class="hljs-keyword">include</span>/svo<br><span class="hljs-variable">$&#123;svo_source_dir&#125;</span>/<span class="hljs-keyword">include</span>/svo/track<br>)<br><span class="hljs-keyword">add_library</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> SHARED src/track/tracking.cpp) <br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_node src/svo_node.cpp src/system.cpp)<br><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>_node <span class="hljs-variable">$&#123;catkin_libraries&#125;</span> <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br></code></pre></td></tr></table></figure><p>如上所述，我们接下来进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br>make<br></code></pre></td></tr></table></figure><p>这是我们就得到了一个连接到 libhello 的可执行程序 main，位于 <code>build/bin</code>目录，运行 main 的结果是输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/main<br><span class="hljs-comment">#输出 hello world!</span><br></code></pre></td></tr></table></figure><h1 id="查看执行文链接库的情况">查看执行文链接库的情况</h1><p>让我们来检查一下 main 的链接情况,输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ldd bin/main<br></code></pre></td></tr></table></figure><p>得到的输出如下：</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/20210205163633237.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以清楚的看到 main 确实链接了共享库 libhello，而且链接的是动态库 libhello.so.1</p><h2 id="链接到静态库">链接到静态库</h2><p>将 <code>TARGET_LINK_LIBRRARIES</code>指令修改为:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main /root/cpp_test/backup/cmake_test/t4/thirdPath/libhello.a)<br></code></pre></td></tr></table></figure><p>重新构建后再来看一下 main 的链接情况 ldd src/main</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/2021020516514337.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>说明，main 确实链接到了静态库 libhello.a</p><h1 id="总结">总结</h1><p>CMakeLists.txt所有指令的基本操作如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#命名项目</span><br><span class="hljs-keyword">PROJECT</span> (HELLO)<br><span class="hljs-comment">#添加生成可执行二进制文件</span><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello main.c)<br> <br><span class="hljs-comment">#在主CMakeLists.txt添加子执行文件</span><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src bin)<br> <br> <br><span class="hljs-keyword">SET</span>(LIBHELLO_SRC hello.c)<br><span class="hljs-comment">#添加共享库</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(hello SHARED <span class="hljs-variable">$&#123;LIBHELLO_SRC&#125;</span>)<br><span class="hljs-comment">#添加静态库</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(hello_static STATIC <span class="hljs-variable">$&#123;LIBHELLO_SRC&#125;</span>)<br><span class="hljs-comment">#重命名静态库</span><br><span class="hljs-keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES OUTPUT_NAME <span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment">#清除功能开启</span><br><span class="hljs-keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="hljs-number">1</span>)<br><span class="hljs-keyword">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="hljs-number">1</span>)<br><span class="hljs-comment">#设置版本号</span><br><span class="hljs-keyword">SET_TARGET_PROPERTIES</span>(hello PROPERTIES VERSION <span class="hljs-number">1.2</span> SOVERSION <span class="hljs-number">1</span>)<br><span class="hljs-comment">#安装文件及可执行文件</span><br><span class="hljs-keyword">INSTALL</span>(TARGETS hello hello_static<br>        LIBRARY DESTINATION thirdPath<br>        ARCHIVE DESTINATION thirdPath)<br> <br><span class="hljs-keyword">INSTALL</span>(FILES hello.h DESTINATION <span class="hljs-keyword">include</span>/hello)<br> <br><span class="hljs-comment">#导入第三方库头文件</span><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(/root/cpp_test/backup/cmake_test/t4/<span class="hljs-keyword">include</span>/hello)<br><span class="hljs-comment">#导入第三方静态库</span><br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main /root/cpp_test/backup/cmake_test/t4/thirdPath/libhello.a)<br><span class="hljs-comment">#导入第三方动态库</span><br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(main /root/cpp_test/backup/cmake_test/t4/thirdPath/libhello.so.<span class="hljs-number">1.2</span>)<br></code></pre></td></tr></table></figure><p>举个简单的例子，项目learn-c++目录结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">-include<br>-hello.h<br>-smartptr.h<br>-src<br>-hello.cpp<br>-smartptr.cpp<br>-CmakeLists.txt<br>-main.cpp<br></code></pre></td></tr></table></figure><p>CmakeLists.txt文件如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>)<br><span class="hljs-keyword">project</span>(learn-c++ VERSION <span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>)<br><br><br><span class="hljs-comment"># 自定义变量用如下方式</span><br><span class="hljs-keyword">SET</span>(LIB_SHARED_NAME LIB_SHARED)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_FLAGS <span class="hljs-string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++17&quot;</span>)<br><br><span class="hljs-keyword">include</span>(CTest)<br><span class="hljs-keyword">enable_testing</span>()<br><br><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># 将所有cpp添加成动态库</span><br><span class="hljs-keyword">file</span>(GLOB_RECURSE CPP_SRC <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)<br><br><span class="hljs-comment"># 生成动态库</span><br><span class="hljs-keyword">add_library</span>(LIB_SHARED SHARED <span class="hljs-variable">$&#123;CPP_SRC&#125;</span>)<br><br><span class="hljs-keyword">LINK_DIRECTORIES</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-variable">$&#123;CPP_SRC&#125;</span>)<span class="hljs-comment"># 对应tasks的 &quot;-L&quot;参数  .dll等</span><br><br><br><span class="hljs-comment"># 添加可执行程序</span><br><span class="hljs-keyword">add_executable</span>(learn-c++ main.cpp)<br><span class="hljs-keyword">TARGET_LINK_LIBRARIES</span>(learn-c++ <span class="hljs-variable">$&#123;LIB_SHARED_NAME&#125;</span>)<br><br><span class="hljs-keyword">target_compile_features</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>  PRIVATE cxx_std_17)<br><br><span class="hljs-keyword">set</span>(CPACK_PROJECT_NAME <span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span>)<br><span class="hljs-keyword">set</span>(CPACK_PROJECT_VERSION <span class="hljs-variable">$&#123;PROJECT_VERSION&#125;</span>)<br><span class="hljs-keyword">include</span>(CPack)<br></code></pre></td></tr></table></figure><p>注：<code>file</code>的一个作用是生成目录列表。</p><ol type="1"><li>添加当前目录下的所有c文件列表到<code>lib_srcs</code>变量中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">file</span>(GLOB lib_srcs *.c)<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>添加当前目录<strong>及其子目录下</strong>的所有c文件列表到<code>lib_srcs</code>变量中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">file</span>(GLOB_RECURSE lib_srcs *.c)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Cmake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你会在Github上找项目吗？</title>
    <link href="/2021/10/20/search-in-git/"/>
    <url>/2021/10/20/search-in-git/</url>
    
    <content type="html"><![CDATA[<p>很多的小伙伴，经常会有这样的困惑，我看了很多技术的学习文档、书籍、甚至视频，我想动手实践，于是我打开了GitHub，想找个开源项目，进行学习，获取项目实战经验。这个时候很多小伙伴就会面临这样的问题：“我不会搜啊，我该怎么找呀？”，最终只能放弃。</p><p>这篇文章，小编教你精准地在GitHub搜索项目。</p><h1 id="开源项目的组成部分"><strong>开源项目的组成部分</strong></h1><p>在讲清楚之前呢，我们先来了解一下一个开源项目有哪些组成部分：</p><ul><li>name: 项目名</li><li>description: 项目的简要描述</li><li>项目的源码</li><li>README.md: 项目的详细情况的介绍</li></ul><p>那么除了这些要素之外，项目本身的star数和fork数，也是评判一个开源项目是否火热的标准，这同时也是一个很重要的搜索标准。另外我们也要注意观察这个项目的最近更新日期，因为项目越活跃，那么它的更新日期也更加频繁。</p><p>以上要素就是我们在进行搜索的时候要注意的一些关键点。</p><h1 id="如何搜索"><strong>如何搜索</strong></h1><p>那我们到底如何搜索呢？</p><p>假设我们现在要搜索React,相信大部分小伙伴都是直接在搜索框里输入：“React”，然后一回车，你就会发现情况像下面这样：</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZgusvEoZPJUJeBFBwCzmibD6ibdA9c9onmv0zCJ5ib2paNOdrqRWCfIENbGA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>搜索结果会显示非常多的开源项目，简直让你应接不暇，无从下手，很多小伙伴搜到这一步就放弃了，因为项目太多了，根本找不到如何找到自己感兴趣的开源项目，所以这样搜索非常的不准确。所以我们来学习一下稍微精确一点的搜索方法。</p><h2 id="按照-name-搜索"><strong>按照 name 搜索</strong></h2><p>搜索项目名里面包含React的项目:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>name React<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZguyXGXPgpbMKu4Oh7KsFRibGzgvVvhSAhXZQXbPj3icPT6KNhn7EoN7Kvw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>可以看到，这些搜索结果都是项目名里面带有“React”关键字的项目，但是项目数量依旧很多。</p><p>现在我们来约束一下</p><p>比如我再精确到项目的star数大于5000+：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:name React stars:&gt;<span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><p>结果是这样的：</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZguJibwpdtJzJdzbLmZYN6o8USDyf9dhJibia1yaEvZIbVXH7A2MCVTCibLxg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>搜索结果瞬间精确了很多，现在只有114个项目可供选择。当然我们一般不会把star数设置得这么高，一般设置个1000就差不多了。</p><p>同理，我们也可以按照fork的数量来进行搜索:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:name React stars:&gt;<span class="hljs-number">5000</span> forks:&gt;<span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZguicic1ZBZQSFcpYBF9R07QV24ib1ibOKKt8PV3N8rVkwJDQpIEdzHaYW5ZA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>你会发现，结果越来越精确！</p><h2 id="按照readme来搜索"><strong>按照README来搜索</strong></h2><p>搜索README.md里面包含React的项目:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>readme React<br></code></pre></td></tr></table></figure><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZguAMpvZagDyiaHOtCVNbI1b7YQYXNj8SFQlORJ4ylBaMdQqMg5ukicG0ww/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>结果有这么多，那么我们再限制一下它的star数和fork数：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:readme React stars:&gt;<span class="hljs-number">3000</span> forks:&gt;<span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZguMsQqmqRicOiaM4LUvvzqNvfLavKPeHOJZaTNaqONyQ9NNMp5SKY2ZEHQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>搜索结果一下子精确到了90个。这个时候你再去选择项目，就会变得容易很多。</p><h2 id="按照descriptin搜索"><strong>按照descriptin搜索</strong></h2><p>假设我们现在要学习微服务的项目，我们搜索项目描述(description)里面包含微服务的项目:</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">in:</span>description 微服务<br></code></pre></td></tr></table></figure><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZguwDumbB8X8lrnQINiaO2MUwLrscjvpvQ6cb61lZtpzLb33QxSLXV7s1A/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>结果有这么多，那我们接着增加一些筛选条件:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">in:description 微服务 <span class="hljs-keyword">language</span>:<span class="hljs-keyword">python</span> <br></code></pre></td></tr></table></figure><p>language:python的意思是我们把语言限制为python，我们来看看结果如何:</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZguE18x3q5iaNPODucm4licHuJSnbzIN2GVBrPUekj29trNfiaN6CskKg7ow/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>搜索结果精确了很多。</p><p>假如在这些项目里面，我们想要找到最近才更新的项目，意思是更新时间就在最近，我们可以这样：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:description 微服务 language:python pushed:&gt;<span class="hljs-number">2020</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><p>pushed:&gt;2020-01-01的意思是我们把项目的最后更新时间限制到2020-01-01，我们来看看结果如何:</p><figure><img src="https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzTpKC8s1FAM1adk187WZgu6NfRx2ryNuC2O0UJmAwOsicopwVPJmzh2MNyQ6nHlkELDOPCC4n4SSQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>搜索结果只有8个了，这几个项目就属于更新比较活跃的项目，这下再也不纠结了。</p><h1 id="总结"><strong>总结</strong></h1><p>好，我们来总结一下。我们想要进行精准搜索，无非就是增加筛选条件。</p><ul><li>in:name xxx // 按照项目名搜索</li><li>in:readme xxx // 按照README搜索</li><li>in:description xxx // 按照description搜索</li></ul><p>那么在这里面呢，我们又可以增加筛选条件</p><ul><li>stars:&gt;xxx // stars数大于xxx</li><li>forks:&gt;3000 // forks数大于xxx</li><li>language:xxx // 编程语言是xxx</li><li>pushed:&gt;YYYY-MM-DD // 最后更新时间大于YYYY-MM-DD</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>经典动态规划：打家劫舍系列问题</title>
    <link href="/2020/12/12/2020-12-13-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/12/2020-12-13-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自<a href="https://mp.weixin.qq.com/s/AWsL7G89RtaHyHjRPNJENA">算法目录</a></p></blockquote><p>打家劫舍系列总共有三道，难度设计非常合理，层层递进。第一道是比较标准的动态规划问题，而第二道融入了环形数组的条件，第三道更绝，让盗贼在二叉树上打劫，这就是传说中的高智商犯罪吧。。。</p><p>下面，我们从第一道开始分析。</p><h1 id="house-robber-i">House Robber I</h1><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/640.jpeg?raw=true" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span></span>;<br></code></pre></td></tr></table></figure><p>题目很容易理解，而且动态规划的特征很明显。我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484731&amp;idx=1&amp;sn=f1db6dee2c8e70c42240aead9fd224e6&amp;chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&amp;scene=21#wechat_redirect">动态规划详解</a> 做过总结，<strong>解决动态规划问题就是找「状态」和「选择」，仅此而已</strong>。</p><p>假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种<strong>选择</strong>：抢或者不抢。</p><p>如果你抢了这间房子，那么你肯定不能抢相邻的下一间房子了，只能从<strong>下下间</strong>房子开始做选择。</p><p>如果你不抢这间房子，那么你可以走到<strong>下一间</strong>房子前，继续做选择。</p><p>当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（<strong>base case</strong>）。</p><p>以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：<strong>你面前房子的索引就是状态，抢和不抢就是选择</strong>。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/640_1.jpeg?raw=true" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>在两个选择中，每次都选更大的结果，最后得到的就是最多能抢到的 money：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(nums, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 返回 nums[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = Math.<span class="hljs-built_in">max</span>(<br>            <span class="hljs-comment">// 不抢，去下家</span><br>            <span class="hljs-built_in">dp</span>(nums, start + <span class="hljs-number">1</span>), <br>            <span class="hljs-comment">// 抢，去下下家</span><br>            nums[start] + <span class="hljs-built_in">dp</span>(nums, start + <span class="hljs-number">2</span>)<br>        );<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>明确了状态转移，就可以发现对于同一<code>start</code>位置，是存在重叠子问题的，比如下图：</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/640_2.jpeg?raw=true" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>盗贼有多种选择可以走到这个位置，如果每次到这都进入递归，岂不是浪费时间？所以说存在重叠子问题，可以用备忘录进行优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] memo;<br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化备忘录</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[nums.length];<br>    Arrays.<span class="hljs-built_in">fill</span>(memo, <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 强盗从第 0 间房子开始抢劫</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(nums, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 返回 dp[start..] 能抢到的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (start &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 避免重复计算</span><br>    <span class="hljs-keyword">if</span> (memo[start] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> memo[start];<br><br>    <span class="hljs-type">int</span> res = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dp</span>(nums, start + <span class="hljs-number">1</span>), <br>                    nums[start] + <span class="hljs-built_in">dp</span>(nums, start + <span class="hljs-number">2</span>));<br>    <span class="hljs-comment">// 记入备忘录</span><br>    memo[start] = res;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这就是自顶向下的动态规划解法，我们也可以略作修改，写出<strong>自底向上</strong>的解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.length;<br>    <span class="hljs-comment">// dp[i] = x 表示：</span><br>    <span class="hljs-comment">// 从第 i 间房子开始抢劫，最多能抢到的钱为 x</span><br>    <span class="hljs-comment">// base case: dp[n] = 0</span><br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        dp[i] = Math.<span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>], nums[i] + dp[i + <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>我们又发现状态转移只和<code>dp[i]</code>最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到 O(1)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.length;<br>    <span class="hljs-comment">// 记录 dp[i+1] 和 dp[i+2]</span><br>    <span class="hljs-type">int</span> dp_i_1 = <span class="hljs-number">0</span>, dp_i_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录 dp[i]</span><br>    <span class="hljs-type">int</span> dp_i = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        dp_i = Math.<span class="hljs-built_in">max</span>(dp_i_1, nums[i] + dp_i_2);<br>        dp_i_2 = dp_i_1;<br>        dp_i_1 = dp_i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上的流程，在我们 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484731&amp;idx=1&amp;sn=f1db6dee2c8e70c42240aead9fd224e6&amp;chksm=9bd7fb33aca07225bee0b23a911c30295e0b90f393af75eca377caa4598ffb203549e1768336&amp;scene=21#wechat_redirect">动态规划详解</a> 中详细解释过，相信大家都能手到擒来了。我认为很有意思的是这个问题的 follow up，需要基于我们现在的思路做一些巧妙的应变。</p><h1 id="house-robber-ii">House Robber II</h1><p>这道题目和第一道描述基本一样，强盗依然不能抢劫相邻的房子，输入依然是一个数组，但是告诉你<strong>这些房子不是一排，而是围成了一个圈</strong>。</p><p>也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。比如说输入数组<code>nums=[2,3,2]</code>，算法返回的结果应该是 3 而不是 4，因为开头和结尾不能同时被抢。</p><p>这个约束条件看起来应该不难解决，我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484525&amp;idx=1&amp;sn=3d2e63694607fec72455a52d9b15d4e5&amp;chksm=9bd7fa65aca073734df90b45054448e09c14e6e35ad7b778bff62f9bd6c2b4f6e1ca7bc4f844&amp;scene=21#wechat_redirect">单调栈 Monotonic Stack 的使用</a> 说过一种解决环形数组的方案，那么在这个问题上怎么处理呢？</p><p>首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/640_3.jpeg?raw=true" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>那就简单了啊，这三种情况，哪种的结果最大，就是最终答案呗！不过，其实我们不需要比较三种情况，<strong>只要比较情况二和情况三就行了，</strong>因为这两种情况对于房子的选择余地比情况一大呀，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小。</p><p>所以只需对之前的解法稍作修改即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.length;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">2</span>), <br>                    <span class="hljs-built_in">robRange</span>(nums, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>));<br>&#125;<br><br><span class="hljs-comment">// 仅计算闭区间 [start,end] 的最优结果</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">robRange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.length;<br>    <span class="hljs-type">int</span> dp_i_1 = <span class="hljs-number">0</span>, dp_i_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dp_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = end; i &gt;= start; i--) &#123;<br>        dp_i = Math.<span class="hljs-built_in">max</span>(dp_i_1, nums[i] + dp_i_2);<br>        dp_i_2 = dp_i_1;<br>        dp_i_1 = dp_i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp_i;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，第二问也解决了。</p><h1 id="house-robber-iii">House Robber III</h1><p>第三题又想法设法地变花样了，此强盗发现现在面对的房子不是一排，不是一圈，而是一棵二叉树！房子在二叉树的节点上，相连的两个房子不能同时被抢劫：</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/640_4.jpeg?raw=true" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><p>整体的思路完全没变，还是做抢或者不抢的选择，取收益较大的选择。甚至我们可以直接按这个套路写出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">Map&lt;TreeNode, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 利用备忘录消除重叠子问题</span><br>    <span class="hljs-keyword">if</span> (memo.<span class="hljs-built_in">containsKey</span>(root)) <br>        <span class="hljs-keyword">return</span> memo.<span class="hljs-built_in">get</span>(root);<br>    <span class="hljs-comment">// 抢，然后去下下家</span><br>    <span class="hljs-type">int</span> do_it = root.val<br><br>        + (root.left == null ? <br>            <span class="hljs-number">0</span> : <span class="hljs-built_in">rob</span>(root.left.left) + <span class="hljs-built_in">rob</span>(root.left.right))<br>                + (root.right == null ? <br>                <span class="hljs-number">0</span> : <span class="hljs-built_in">rob</span>(root.right.left) + <span class="hljs-built_in">rob</span>(root.right.right));<br>            <span class="hljs-comment">// 不抢，然后去下家</span><br>            <span class="hljs-type">int</span> not_do = <span class="hljs-built_in">rob</span>(root.left) + <span class="hljs-built_in">rob</span>(root.right);<br><br>    <span class="hljs-type">int</span> res = Math.<span class="hljs-built_in">max</span>(do_it, not_do);<br>    memo.<span class="hljs-built_in">put</span>(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>这道题就解决了，时间复杂度 O(N)，<code>N</code>为数的节点数。</p><p>但是这道题让我觉得巧妙的点在于，还有更漂亮的解法。比如下面是我在评论区看到的一个解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-built_in">dp</span>(root);<br>    <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(res[<span class="hljs-number">0</span>], res[<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-comment">/* 返回一个大小为 2 的数组 arr</span><br><span class="hljs-comment">arr[0] 表示不抢 root 的话，得到的最大钱数</span><br><span class="hljs-comment">arr[1] 表示抢 root 的话，得到的最大钱数 */</span><br><span class="hljs-type">int</span>[] <span class="hljs-built_in">dp</span>(TreeNode root) &#123;<br>    <span class="hljs-keyword">if</span> (root == null)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span>[] left = <span class="hljs-built_in">dp</span>(root.left);<br>    <span class="hljs-type">int</span>[] right = <span class="hljs-built_in">dp</span>(root.right);<br>    <span class="hljs-comment">// 抢，下家就不能抢了</span><br>    <span class="hljs-type">int</span> rob = root.val + left[<span class="hljs-number">0</span>] + right[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 不抢，下家可抢可不抢，取决于收益大小</span><br>    <span class="hljs-type">int</span> not_rob = Math.<span class="hljs-built_in">max</span>(left[<span class="hljs-number">0</span>], left[<span class="hljs-number">1</span>])<br>                + Math.<span class="hljs-built_in">max</span>(right[<span class="hljs-number">0</span>], right[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[]&#123;not_rob, rob&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度 O(N)，空间复杂度只有递归函数堆栈所需的空间，不需要备忘录的额外空间。</p><p>你看他和我们的思路不一样，修改了递归函数的定义，略微修改了思路，使得逻辑自洽，依然得到了正确的答案，而且代码更漂亮。这就是我们前文 <a href="http://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484469&amp;idx=1&amp;sn=e8d321c8ad62483874a997e9dd72da8f&amp;chksm=9bd7fa3daca0732b316aa0afa58e70357e1cb7ab1fe0855d06bc4a852abb1b434c01c7dd19d6&amp;scene=21#wechat_redirect">动态规划：不同的定义产生不同的解法</a> 所说过的动态规划问题的一个特性。</p><p>实际上，这个解法比我们的解法运行时间要快得多，虽然算法分析层面时间复杂度是相同的。原因在于此解法没有使用额外的备忘录，减少了数据操作的复杂性，所以实际运行效率会快。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Dynamic Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA8之妙用Optional解决判断Null为空的问题</title>
    <link href="/2020/12/12/2020-12-16-JAVA8%E4%B9%8B%E5%A6%99%E7%94%A8Optional%E8%A7%A3%E5%86%B3%E5%88%A4%E6%96%ADNull%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/12/2020-12-16-JAVA8%E4%B9%8B%E5%A6%99%E7%94%A8Optional%E8%A7%A3%E5%86%B3%E5%88%A4%E6%96%ADNull%E4%B8%BA%E7%A9%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="引言">引言</h1><p>在文章的开头，先说下NPE问题，NPE问题就是，我们在开发中经常碰到的NullPointerException.假设我们有两个类，他们的UML类图如下图所示</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/2020_12_16.png?raw=true" alt="o_optional1.png" /><figcaption aria-hidden="true">o_optional1.png</figcaption></figure><p>在这种情况下，有如下代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">user.get<span class="hljs-constructor">Address()</span>.get<span class="hljs-constructor">Province()</span>;<br></code></pre></td></tr></table></figure><p>这种写法，在user为null时，是有可能报NullPointerException异常的。为了解决这个问题，于是采用下面的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(user!=<span class="hljs-literal">null</span>)&#123;<br>    <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> user.getAddress();<br>    <span class="hljs-keyword">if</span>(address!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">province</span> <span class="hljs-operator">=</span> address.getProvince();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法是比较丑陋的，为了避免上述丑陋的写法，让丑陋的设计变得优雅。JAVA8提供了Optional类来优化这种写法，接下来的正文部分进行详细说明</p><h1 id="api介绍">API介绍</h1><p>先介绍一下API，与其他文章不同的是，本文采取类比的方式来讲，同时结合源码。而不像其他文章一样，一个个API罗列出来，让人找不到重点。</p><h2 id="optionalt-valueemptyoft-valueofnullablet-value">1、Optional(T value),empty(),of(T value),ofNullable(T value)</h2><p>这四个函数之间具有相关性，因此放在一组进行记忆。</p><p>先说明一下，<code>Optional(T value)</code>，即构造函数，它是private权限的，不能由外部调用的。其余三个函数是public权限，供我们所调用。那么，Optional的本质，就是内部储存了一个真实的值，在构造的时候，就直接判断其值是否为空。好吧，这么说还是比较抽象。直接上<code>Optional(T value)</code>构造函数的源码，如下图所示</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/202012161.png?raw=true" alt="o_optional2.png" /><figcaption aria-hidden="true">o_optional2.png</figcaption></figure><p>那么，<strong>of(T value)</strong>的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Optional</span>&lt;&gt;(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说of(T value)函数内部调用了构造函数。根据构造函数的源码我们可以得出两个结论:</p><ul><li>通过<code>of(T value)</code>函数所构造出的Optional对象，当Value值为空时，依然会报NullPointerException。</li><li>通过<code>of(T value)</code>函数所构造出的Optional对象，当Value值不为空时，能正常构造Optional对象。</li></ul><p>除此之外呢，Optional类内部还维护一个value为null的对象，大概就是长下面这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Optional</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//省略....</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Optional</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Optional</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//省略...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么，<code>empty（）</code>的作用就是返回EMPTY对象。</p><p>好了铺垫了这么多，可以说<code>ofNullable(T value)</code>的作用了，上源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Optional&lt;T&gt; <span class="hljs-title function_">ofNullable</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> value == <span class="hljs-literal">null</span> ? empty() : of(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>好吧，大家应该都看得懂什么意思了。相比较<code>of(T value)</code>的区别就是，当value值为null时，of(T value)会报NullPointerException异常；<code>ofNullable(T value)</code>不会throw Exception，<code>ofNullable(T value)</code>直接返回一个<code>EMPTY</code>对象。</p><p>那是不是意味着，我们在项目中只用<code>ofNullable</code>函数而不用of函数呢?</p><p>不是的，一个东西存在那么自然有存在的价值。当我们在运行过程中，不想隐藏<code>NullPointerException</code>。而是要立即报告，这种情况下就用Of函数。但是不得不承认，这样的场景真的很少。博主也仅在写junit测试用例中用到过此函数。</p><h2 id="orelset-otherorelsegetsupplier-extends-t-other和orelsethrowsupplier-extends-x-exceptionsupplier">2、orElse(T other)，orElseGet(Supplier&lt;? extends T&gt; other)和orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</h2><p>这三个函数放一组进行记忆，都是在构造函数传入的value值为null时，进行调用的。<code>orElse</code>和<code>orElseGet</code>的用法如下所示，相当于value值为null时，给予一个默认值:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    user = Optional.ofNullable(user).orElse(createUser());<br>    user = Optional.ofNullable(user).orElseGet(() -&gt; createUser());<br>    <br>&#125;<br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">createUser</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数的区别：当user值不为null时，<code>orElse</code>函数依然会执行createUser()方法，而<code>orElseGet</code>函数并不会执行createUser()方法，大家可自行测试。</p><p>至于orElseThrow，就是value值为null时,直接抛一个异常出去，用法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>Optional.ofNullable(user).orElseThrow(()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;用户不存在&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="mapfunction-super-t-extends-u-mapper和flatmapfunction-super-t-optional-mapper">3、map(Function&lt;? super T, ? extends U&gt; mapper)和flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</h2><p>这两个函数放在一组记忆，这两个函数做的是转换值的操作。</p><p>直接上源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Optional</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//省略....</span><br>     <span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, ? extends U&gt; mapper)</span> &#123;<br>        Objects.requireNonNull(mapper);<br>        <span class="hljs-keyword">if</span> (!isPresent())<br>            <span class="hljs-keyword">return</span> empty();<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Optional.ofNullable(mapper.apply(value));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//省略...</span><br>     <span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title function_">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> &#123;<br>        Objects.requireNonNull(mapper);<br>        <span class="hljs-keyword">if</span> (!isPresent())<br>            <span class="hljs-keyword">return</span> empty();<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Objects.requireNonNull(mapper.apply(value));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数，在函数体上没什么区别。唯一区别的就是入参，map函数所接受的入参类型为<code>Function&lt;? super T, ? extends U&gt;</code>，而flapMap的入参类型为<code>Function&lt;? super T, Optional&lt;U&gt;&gt;</code>。</p><p>在具体用法上，对于map而言：</p><p>如果User结构是下面这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候取name的写法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> Optional.ofNullable(user).map(u-&gt; u.getName()).get();<br></code></pre></td></tr></table></figure><p>对于flatMap而言:</p><p>如果User结构是下面这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> Optional&lt;String&gt; <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Optional.ofNullable(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时候取name的写法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> Optional.ofNullable(user).flatMap(u-&gt; u.getName()).get();<br></code></pre></td></tr></table></figure><h2 id="ispresent和ifpresentconsumer-super-t-consumer">4、isPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)</h2><p>这两个函数放在一起记忆，<code>isPresent</code>即判断value值是否为空，而<code>ifPresent</code>就是在value值不为空时，做一些操作。这两个函数的源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Optional</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//省略....</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPresent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//省略...</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; consumer)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>)<br>            consumer.accept(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要额外说明的是，大家千万不要把</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span>)&#123;<br>   <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>给写成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> Optional.ofNullable(user);<br><span class="hljs-keyword">if</span> (Optional.isPresent())&#123;<br>   <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为这样写，代码结构依然丑陋。博主会在后面给出正确写法</p><p>至于<code>ifPresent(Consumer&lt;? super T&gt; consumer)</code>，用法也很简单，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional.ofNullable(user).ifPresent(u-&gt;&#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> do something</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="filterpredicate-super-t-predicate">5、filter(Predicate&lt;? super T&gt; predicate)</h2><p>不多说，直接上源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Optional</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">//省略....</span><br>   Objects.requireNonNull(predicate);<br>        <span class="hljs-keyword">if</span> (!isPresent())<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-built_in">this</span> : empty();<br>&#125;<br></code></pre></td></tr></table></figure><p>filter 方法接受一个 <code>Predicate</code> 来对 <code>Optional</code> 中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个 Optional；否则返回 <code>Optional.empty</code>。</p><p>用法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;User&gt; user1 = Optional.ofNullable(user).filter(u -&gt; u.getName().length()&lt;<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>如上所示，如果user的name的长度是小于6的，则返回。如果是大于6的，则返回一个EMPTY对象。</p><h1 id="实战使用">实战使用</h1><h2 id="例一">例一</h2><p>在函数方法中</p><p>以前写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">(User user)</span>  <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-keyword">if</span>(user!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(user.getAddress()!=<span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> user.getAddress();<br>                <span class="hljs-keyword">if</span>(address.getCity()!=<span class="hljs-literal">null</span>)&#123;<br>                    <span class="hljs-keyword">return</span> address.getCity();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Excpetion</span>(<span class="hljs-string">&quot;取值错误&quot;</span>); <br>    &#125;<br></code></pre></td></tr></table></figure><p>JAVA8写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getCity</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(user)<br>                   .map(u-&gt; u.getAddress())<br>                   .map(a-&gt;a.getCity())<br>                   .orElseThrow(()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;取指错误&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="例二">例二</h2><p>比如，在主程序中</p><p>以前写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(user!=<span class="hljs-literal">null</span>)&#123;<br>    dosomething(user);<br>&#125;<br></code></pre></td></tr></table></figure><p>JAVA8写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"> Optional.ofNullable(user)<br>    .ifPresent(u-&gt;&#123;<br>        dosomething(u);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="例三">例三</h2><p>以前写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-keyword">if</span>(user!=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> user.getName();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>.equals(name))&#123;<br>            <span class="hljs-keyword">return</span> user;<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>java8写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(User user)</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(user)<br>                   .filter(u-&gt;<span class="hljs-string">&quot;zhangsan&quot;</span>.equals(u.getName()))<br>                   .orElseGet(()-&gt; &#123;<br>                        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                        user1.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>                        <span class="hljs-keyword">return</span> user1;<br>                   &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>其他的例子，不一一列举了。不过，博主认为，其实采用这种链式编程，虽然代码优雅了。但是，逻辑性没那么明显，可读性有所降低，大家项目中看情况酌情使用。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何做 Code Review</title>
    <link href="/2020/12/09/2020-12-09-%E5%A6%82%E4%BD%95%E5%81%9A%20Code%20Review/"/>
    <url>/2020/12/09/2020-12-09-%E5%A6%82%E4%BD%95%E5%81%9A%20Code%20Review/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：cheaterlin，腾讯 PCG 后台开发工程师</p></blockquote><h1 id="前言">前言</h1><p>作为公司代码委员会 golang 分会的理事，我 review 了很多代码，看了很多别人的 review 评论。发现不少同学 code review 与写出好代码的水平有待提高。在这里，想分享一下我的一些理念和思路。</p><h1 id="为什么技术人员包括-leader-都要做-code-review">为什么技术人员包括 leader 都要做 code review</h1><p>谚语曰: 'Talk Is Cheap, Show Me The Code'。知易行难，知行合一难。嘴里要讲出来总是轻松，把别人讲过的话记住，组织一下语言，再讲出来，很容易。绝知此事要躬行。设计理念你可能道听途说了一些，以为自己掌握了，但是你会做么？有能力去思考、改进自己当前的实践方式和实践中的代码细节么？不客气地说，很多人仅仅是知道并且认同了某个设计理念，进而产生了一种虚假的安心感---自己的技术并不差。但是，他根本没有去实践这些设计理念，甚至根本实践不了这些设计理念，从结果来说，他懂不懂这些道理/理念，有什么差别？变成了自欺欺人。</p><p>代码，是设计理念落地的地方，是技术的呈现和根本。同学们可以在 review 过程中做到落地沟通，不再是空对空的讨论，可以在实际问题中产生思考的碰撞，互相学习，大家都掌握团队里积累出来最好的实践方式！当然，如果 leader 没时间写代码，仅仅是 review 代码，指出其他同学某些实践方式不好，要给出好的实践的意见，即使没亲手写代码，也是对最佳实践要有很多思考。</p><h1 id="为什么同学们要在-review-中思考和总结最佳实践">为什么同学们要在 review 中思考和总结最佳实践</h1><p>我这里先给一个我自己的总结：所谓架构师，就是掌握大量设计理念和原则、落地到各种语言及附带工具链（生态）下的实践方法、垂直行业模型理解，定制系统模型设计和工程实践规范细则。进而控制 30+万行代码项目的开发便利性、可维护性、可测试性、运营质量。</p><p>厉害的技术人，主要可以分为下面几个方向：</p><ul><li>奇技淫巧</li></ul><p>掌握很多技巧，以及发现技巧一系列思路，比如很多编程大赛，比的就是这个。但是，这个对工程，用处好像并不是很大。</p><ul><li>领域奠基</li></ul><p>比如约翰*卡马克，他创造出了现代计算机图形高效渲染的方法论。不论如果没有他，后面会不会有人发明，他就是第一个发明了。1999 年，卡马克登上了美国时代杂志评选出来的科技领域 50 大影响力人物榜单，并且名列第 10 位。但是，类似的殿堂级位置，没有几个，不够大家分，没我们的事儿。</p><ul><li>理论研究</li></ul><p>八十年代李开复博士坚持采用隐含马尔可夫模型的框架，成功地开发了世界上第一个大词汇量连续语音识别系统 Sphinx。我辈工程师，好像擅长这个的很少。</p><ul><li>产品成功</li></ul><p>小龙哥是标杆。</p><ul><li>最佳实践</li></ul><p>这个是大家都可以做到，按照上面架构师的定义。在这条路上走得好，就能为任何公司组建技术团队，组织建设高质量的系统。</p><p>从上面的讨论中，可以看出，我们普通工程师的进化之路，就是不断打磨最佳实践方法论、落地细节。</p><h1 id="代码变坏的根源">代码变坏的根源</h1><p>在讨论什么代码是好代码之前，我们先讨论什么是不好的。计算机是人造的学科，我们自己制造了很多问题，进而去思考解法。</p><h2 id="重复的代码">重复的代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// BatchGetQQTinyWithAdmin 获取QQ uin的tinyID, 需要主uin的tiny和登录态</span><br><span class="hljs-comment">// friendUins 可以是空列表, 只要admin uin的tiny</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BatchGetQQTinyWithAdmin</span><span class="hljs-params">(ctx context.Context, adminUin <span class="hljs-type">uint64</span>, friendUin []<span class="hljs-type">uint64</span>)</span></span> (<br> adminTiny <span class="hljs-type">uint64</span>, sig []<span class="hljs-type">byte</span>, frdTiny <span class="hljs-keyword">map</span>[<span class="hljs-type">uint64</span>]<span class="hljs-type">uint64</span>, err <span class="hljs-type">error</span>) &#123;<br> <span class="hljs-keyword">var</span> friendAccountList []*basedef.AccountInfo<br> <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> friendUin &#123;<br>  friendAccountList = <span class="hljs-built_in">append</span>(friendAccountList, &amp;basedef.AccountInfo&#123;<br>   AccountType: proto.String(def.StrQQU),<br>   Userid:      proto.String(fmt.Sprint(v)),<br>  &#125;)<br> &#125;<br><br> req := &amp;cmd0xb91.ReqBody&#123;<br>  Appid:       proto.Uint32(model.DocAppID),<br>  CheckMethod: proto.String(CheckQQ),<br>  AdminAccount: &amp;basedef.AccountInfo&#123;<br>   AccountType: proto.String(def.StrQQU),<br>   Userid:      proto.String(fmt.Sprint(adminUin)),<br>  &#125;,<br>  FriendAccountList: friendAccountList,<br> &#125;<br></code></pre></td></tr></table></figure><p>因为最开始协议设计得不好，第一个使用接口的人，没有类似上面这个函数的代码，自己实现了一个嵌入逻辑代码的填写请求结构结构体的代码，一开始，挺好的。但当有第二个人，第三个人干了类似的事情，我们将无法再重构这个协议，必须做到麻烦的向前兼容。而且每个同学，都要理解一遍上面这个协议怎么填，理解有问题，就触发 bug。或者，如果某个错误的理解，普遍存在，我们就得找到所有这些重复的片段，都修改一遍。</p><p>当你要读一个数据，发现两个地方有，不知道该选择哪个。当你要实现一个功能，发现两个 rpc 接口、两个函数能做到，你不知道选哪一个。你有面临过这样的'人生难题'么？其实怎么选并不重要了，你写的这个代码已经在走向 shit 的道路上迈出了坚实的一步。</p><p>但是，A little copying is better than a little dependency。这里提一嘴，不展开。</p><p>这里，我必须额外说一句。大家使用 trpc。感觉自己被鼓励'每个服务搞一个 git'。那，你这个服务里访问 db 的代码，rpc 的代码，各种可以复用的代码，是用的大家都复用的 git 下的代码么？每次都重复写一遍，db 字段细节改了，每个使用过 db 的 server 对应的 git 都改一遍？这个通用 git 已经写好的接口应该不知道哪些 git 下的代码因为自己不向前兼容的修改而永远放弃了向前不兼容的修改？</p><h2 id="早期有效的决策不再有效">早期有效的决策不再有效</h2><p>很多时候，我们第一版代码写出来，是没有太大的问题的。比如，下面这个代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Update 增量更新</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *FilePrivilegeStore)</span></span> Update(key def.PrivilegeKey,<br> clear, isMerge <span class="hljs-type">bool</span>, subtract []*access.AccessInfo, increment []*access.AccessInfo,<br> policy *<span class="hljs-type">uint32</span>, adv *access.AdvPolicy, shareKey <span class="hljs-type">string</span>, importQQGroupID <span class="hljs-type">uint64</span>) <span class="hljs-type">error</span> &#123;<br> <span class="hljs-comment">// 获取之前的数据</span><br> info, err := s.Get(key)<br> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> err<br> &#125;<br><br> incOnlyModify := update(info, &amp;key, clear, subtract,<br>  increment, policy, adv, shareKey, importQQGroupID)<br> stat := statAndUpdateAccessInfo(info)<br> <span class="hljs-keyword">if</span> !incOnlyModify &#123;<br>  <span class="hljs-keyword">if</span> stat.groupNumber &gt; model.FilePrivilegeGroupMax &#123;<br>   <span class="hljs-keyword">return</span> errors.Errorf(errors.PrivilegeGroupLimit,<br>    <span class="hljs-string">&quot;group num %d larger than limit %d&quot;</span>,<br>    stat.groupNumber, model.FilePrivilegeGroupMax)<br>  &#125;<br> &#125;<br><br> <span class="hljs-keyword">if</span> !isMerge &#123;<br>  <span class="hljs-keyword">if</span> key.DomainID == <span class="hljs-type">uint64</span>(access.SPECIAL_FOLDER_DOMAIN_ID) &amp;&amp;<br>   <span class="hljs-built_in">len</span>(info.AccessInfos) &gt; model.FilePrivilegeMaxFolderNum &#123;<br>   <span class="hljs-keyword">return</span> errors.Errorf(errors.PrivilegeFolderLimit,<br>    <span class="hljs-string">&quot;folder owner num %d larger than limit %d&quot;</span>,<br>    <span class="hljs-built_in">len</span>(info.AccessInfos), model.FilePrivilegeMaxFolderNum)<br>  &#125;<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(info.AccessInfos) &gt; model.FilePrivilegeMaxNum &#123;<br>   <span class="hljs-keyword">return</span> errors.Errorf(errors.PrivilegeUserLimit,<br>    <span class="hljs-string">&quot;file owner num %d larger than limit %d&quot;</span>,<br>    <span class="hljs-built_in">len</span>(info.AccessInfos), model.FilePrivilegeMaxNum)<br>  &#125;<br> &#125;<br><br> pbDataSt := infoToData(info, &amp;key)<br> <span class="hljs-keyword">var</span> updateBuf []<span class="hljs-type">byte</span><br> <span class="hljs-keyword">if</span> updateBuf, err = proto.Marshal(pbDataSt); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> errors.Wrapf(err, errors.MarshalPBError,<br>   <span class="hljs-string">&quot;FilePrivilegeStore.Update Marshal data error, key[%v]&quot;</span>, key)<br> &#125;<br> <span class="hljs-keyword">if</span> err = s.setCKV(generateKey(&amp;key), updateBuf); err != <span class="hljs-literal">nil</span> &#123;<br>  <span class="hljs-keyword">return</span> errors.Wrapf(err, errors.Code(err),<br>   <span class="hljs-string">&quot;FilePrivilegeStore.Update setCKV error, key[%v]&quot;</span>, key)<br> &#125;<br> <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在看，这个代码挺好的，长度没超过 80 行，逻辑比价清晰。但是当 isMerge 这里判断逻辑，如果加入更多的逻辑，把局部行数撑到 50 行以上，这个函数，味道就坏了。出现两个问题：</p><p>1）函数内代码不在一个逻辑层次上，阅读代码，本来在阅读着顶层逻辑，突然就掉入了长达 50 行的 isMerge 的逻辑处理细节，还没看完，读者已经忘了前面的代码讲了什么，需要来回看，挑战自己大脑的 cache 尺寸。</p><p>2）代码有问题后，再新加代码的同学，是改还是不改前人写好的代码呢？出 bug 谁来背？这是一个灵魂拷问。</p><h2 id="过早的优化">过早的优化</h2><p>这个大家听了很多了，这里不赘述。</p><h2 id="对合理性没有苛求">对合理性没有苛求</h2><p>'两种写法都 ok，你随便挑一种吧'，'我这样也没什么吧'，这是我经常听到的话。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get 获取IP</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i *IPGetter)</span></span> Get(cardName <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br> i.l.RLock()<br> ip, found := i.m[cardName]<br> i.l.RUnlock()<br><br> <span class="hljs-keyword">if</span> found &#123;<br>  <span class="hljs-keyword">return</span> ip<br> &#125;<br><br> i.l.Lock()<br> <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br> ip, err = getNetIP(cardName)<br> <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>  i.m[cardName] = ip<br> &#125;<br><br>  i.l.Unlock()<br> <span class="hljs-keyword">return</span> ip<br>&#125;<br></code></pre></td></tr></table></figure><p>i.l.Unlock()可以放在当前的位置，也可以放在 i.l.Lock()下面，做成 defer。两种在最初构造的时候，好像都行。这个时候，很多同学态度就变得不坚决。实际上，这里必须是 defer 的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"> i.l.Lock()<br><span class="hljs-keyword">defer</span> i.l.Unlock()<br><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>ip, err = getNetIP(cardName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;127.0.0.1&quot;</span><br>&#125;<br><br>i.m[cardName] = ip<br><span class="hljs-keyword">return</span> ip<br></code></pre></td></tr></table></figure><p>这样的修改，是极有可能发生的，它还是要变成 defer，那，为什么不一开始就是 defer，进入最合理的状态？不一开始就进入最合理的状态，在后续协作中，其他同学很可能犯错！</p><h2 id="总是面向对象总喜欢封装">总是面向对象/总喜欢封装</h2><p>我是软件工程科班出身。学的第一门编程语言是 c++。教材是这本 。当时自己读完教材，初入程序设计之门，对于里面讲的'封装'，惊为天人，多么美妙的设计啊，面向对象，多么智慧的设计啊。但是，这些年来，我看到了大牛'云风'对于'毕业生使用 mysql api 就喜欢搞个 class 封装再用'的嘲讽；看到了各种莫名其妙的 class 定义；体会到了经常要去看一个莫名其妙的继承树，必须要把整个继承树整体读明白才能确认一个细小的逻辑分支；多次体会到了我需要辛苦地压抑住自己的抵触情绪，去细度一个自作聪明的被封装的代码，确认我的 bug。除了 UI 类场景，我认为少用继承、多用组合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">template&lt;class _PKG_TYPE&gt;<br>class CSuperAction : public CSuperActionBase &#123;<br>  public:<br>    typedef _PKG_TYPE pkg_type;<br>    typedef CSuperAction&lt;pkg_type&gt; this_type;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 sspp 的代码。CSuperAction 和 CSuperActionBase，一会儿 super，一会儿 base，Super 和 SuperBase 是在怎样的两个抽象层次上，不通读代码，没人能读明白。我想确认任何细节，都要把多个层次的代码都通读了，有什么封装性可言？</p><p>好，你说是作者没有把 class name 取得好。那，问题是，你能取得好么？一个刚入职的 T1.2 的同学能把 class name、class 树设计得好么？即使是对简单的业务模型，也需要无数次'坏'的对象抽象实践，才能培养出一个具有合格的 class 抽象能力的同学，这对于大型却松散的团队协作，不是破坏性的？已经有了一套继承树，想要添加功能就只能在这个继承树里添加，以前的继承树不再适合新的需求，这个继承树上所有的 class，以及使用它们的地方，你都去改？不，是个正常人都会放弃，开始堆屎山。</p><p>封装，就是我可以不关心实现。但是，做一个稳定的系统，每一层设计都可能出问题。abi，总有合适的用法和不合适的用法，真的存在我们能完全不关心封装的部分是怎么实现的？不，你不能。bug 和性能问题，常常就出现在，你用了错误的用法去使用一个封装好的函数。即使是 android、ios 的 api，golang、java 现成的 api，我们常常都要去探究实现，才能把 api 用好。那，我们是不是该一上来，就做一个透明性很强的函数，才更为合理？使用者想知道细节，进来吧，我的实现很易读，你看看就明白，使用时不会迷路！对于逻辑复杂的函数，我们还要强调函数内部工作方式'可以让读者在大脑里想象呈现完整过程'的可现性，让使用者轻松读懂，有把握，使用时，不迷路！</p><h2 id="根本没有设计">根本没有设计</h2><p>这个最可怕，所有需求，上手就是一顿撸，'设计是什么东西？我一个文件 5w 行，一个函数 5k 行，干不完需求？'从第一行代码开始，就是无设计的，随意地踩着满地的泥坑，对于旁人的眼光没有感觉，一个人独舞，产出的代码，完成了需求，毁灭了接手自己代码的人。这个就不举例了，每个同学应该都能在自己的项目类发现这种代码。</p><h1 id="必须形而上的思考">必须形而上的思考</h1><p>常常，同学们听演讲，公开课，就喜欢听一些细枝末节的'干活'。这没有问题。但是，你干了几年活，学习了多少干货知识点？构建起自己的技术思考'面'，进入立体的'工程思维'，把技术细节和系统要满足的需求在思考上连接起来了么？当听一个需求的时候，你能思考到自己的 code package 该怎么组织，函数该怎么组织了么？</p><p>那，技术点要怎么和需求连接起来呢？答案很简单，你需要在时间里总结，总结出一些明确的原则、思维过程。思考怎么去总结，特别像是在思考哲学问题。从一些琐碎的细节中，由具体情况上升到一些原则、公理。同时，大家在接受原则时，不应该是接受和记住原则本身，而应该是结构原则，让这个原则在自己这里重新推理一遍，自己完全掌握这个原则的适用范围。</p><p>再进一步具体地说，对于工程最佳实践的形而上的思考过程，就是：</p><p>把工程实践中遇到的问题，从问题类型和解法类型，两个角度去归类，总结出一些有限适用的原则，就从点到了面。把诸多总结出的原则，组合应用到自己的项目代码中，就是把多个面结合起来构建了一套立体的最佳实践的方案。当你这套方案能适应 30w+行代码的项目，超过 30 人的项目，你就架构师入门了！当你这个项目，是多端，多语言，代码量超过 300w 行，参与人数超过 300 人，代码质量依然很高，代码依然在高效地自我迭代，每天消除掉过时的代码，填充高质量的替换旧代码和新生的代码。恭喜你，你已经是一个很高级的架构师了！再进一步，你对某个业务模型有独到或者全面的理解，构建了一套行业第一的解决方案，结合刚才高质量实现的能力，实现了这么一个项目。没啥好说的，你已经是专家工程师了。级别再高，我就不了解了，不在这里讨论。</p><p>那么，我们要重头开始积累思考和总结？不，有一本书叫做《unix 编程艺术》，我在不同的时期分别读了 3 遍，等一会，我讲一些里面提到的，我觉得在腾讯尤其值得拿出来说的原则。这些原则，正好就能作为 code review 时大家判定代码质量的准绳。但，在那之前，我得讲一下另外一个很重要的话题，模型设计。</p><h1 id="model-设计">model 设计</h1><p>没读过 oauth2.0 RFC，就去设计第三方授权登陆的人，终归还要再发明一个撇脚的 oauth。</p><p>2012 年我刚毕业，我和一个去了广州联通公司的华南理工毕业生聊天。当时他说他工作很不开心，因为工作里不经常写代码，而且认为自己有 ACM 竞赛金牌级的算法熟练度+对 CPP 代码的熟悉，写下一个个指针操作内存，什么程序写不出来，什么事情做不好。当时我觉得，挺有道理，编程工具在手，我什么事情做不了？</p><p>现在，我会告诉他，复杂如 linux 操作系统、Chromium 引擎、windows office，你做不了。原因是，他根本没进入软件工程的工程世界。不是会搬砖就能修出港珠澳大桥。但是，这么回答并不好，举证用的论据离我们太遥远了。见微知著。我现在会回答，你做不了，简单如一个权限系统，你知道怎么做么？堆积一堆逻辑层次一维展开的 if else？简单如一个共享文件管理，你知道怎么做么？堆积一堆逻辑层次一维展开的 ife lse？你联通有上万台服务器，你要怎么写一个管理平台？堆积一堆逻辑层次一维展开的 ife lse？</p><p>上来就是干，能实现上面提到的三个看似简单的需求？想一想，亚马逊、阿里云折腾了多少年，最后才找到了容器+Kubernetes 的大杀器。这里，需要谷歌多少年在 BORG 系统上的实践，提出了优秀的服务编排领域模型。权限领域，有 RBAC、DAC、MAC 等等模型，到了业务，又会有细节的不同。如 Domain Driven Design 说的，没有良好的领域思考和模型抽象，逻辑复杂度就是 n^2 指数级的，你得写多少 ifelse，得思考多少可能的 if 路径，来 cover 所有的不合符预期的情况。你必须要有 Domain 思考探索、model 拆解/抽象/构建的能力。有人问过我，要怎么有效地获得这个能力？这个问题我没能回答，就像是在问我，怎么才能获得 MIT 博士的学术能力？我无法回答。唯一回答就是，进入某个领域，就是首先去看前人的思考，站在前人的肩膀上，再用上自己的通识能力，去进一步思考。至于怎么建立好的通识思考能力，可能得去常青藤读个书吧：）或者，就在工程实践中思考和锻炼自己的这个能力！</p><p>同时，基于 model 设计的代码，能更好地适应产品经理不断变更的需求。比如说，一个 calendar(日历)应用，简单来想，不要太简单！以'userid_date'为 key 记录一个用户的每日安排不就完成了么？只往前走一步，设计了一个任务，上限分发给 100w 个人，创建这么一个任务，是往 100w 个人下面添加一条记录？你得改掉之前的设计，换 db。再往前走一步，要拉出某个用户和某个人一起要参与的所有事务，是把两个人的所有任务来做 join？好像还行。如果是和 100 个人一起参与的所有任务呢？100 个人的任务来 join？不现实了吧。好，你引入一个群组 id，那么，你最开始的'userid_date'为 key 的设计，是不是又要修改和做数据迁移了？经常来一个需求，你就得把系统推翻重来，或者根本就只能拒绝用户的需求，这样的战斗力，还好意思叫自己工程师？你一开始就应该思考自己面对的业务领域，思考自己的日历应用可能的模型边界，把可能要做的能力都拿进来思考，构建一个 model，设计一套通用的 store 层接口，基于通用接口的逻辑代码。当产品不断发展，就是不停往模型里填内容，而不是推翻重来。这，思考模型边界，构建模型细节，就是两个很重要的能力，也是绝大多数腾讯产品经理不具备的能力，你得具备，对整个团队都是极其有益的。你面对产品经理时，就听取他们出于对用户体验负责思考出的需求点，到你自己这里，用一个完整的模型去涵盖这些零碎的点。</p><p>model 设计，是形而上思考中的一个方面，一个特别重要的方面。接下来，我们来抄袭抄袭 unix 操作系统构建的实践为我们提出的前人实践经验和'公理'总结。在自己的 coding/code review 中，站在巨人的肩膀上去思考。不重复地发现经典力学，而是往相对论挺进。</p><h1 id="unix-设计哲学">UNIX 设计哲学</h1><p>不懂 Unix 的人注定最终还要重复发明一个撇脚的 Unix。--Henry Spenncer, 1987.11</p><p>下面这一段话太经典，我必须要摘抄一遍(自《UNIX 编程艺术》)：“工程和设计的每个分支都有自己的技术文化。在大多数工程领域中，就一个专业人员的素养组成来说，有些不成文的行业素养具有与标准手册及教科书同等重要的地位(并且随着专业人员经验的日积月累，这些经验常常会比书本更重要)。资深工程师们在工作中会积累大量的隐性知识，他们用类似禅宗'教外别传'的方式，通过言传身教传授给后辈。软件工程算是此规则的一个例外：技术变革如此之快，软件环境日新月异，软件技术文化暂如朝露。然而，例外之中也有例外。确有极少数软件技术被证明经久耐用，足以演进为强势的技术文化、有鲜明特色的艺术和世代相传的设计哲学。“</p><p>接下来，我用我的理解，讲解一下几个我们常常做不到的原则。</p><h2 id="keep-it-simple-stuped">Keep It Simple Stuped!</h2><p>KISS 原则，大家应该是如雷贯耳了。但是，你真的在遵守？什么是 Simple？简单？golang 语言主要设计者之一的 Rob Pike 说'大道至简'，这个'简'和简单是一个意思么？</p><p>首先，简单不是面对一个问题，我们印入眼帘第一映像的解法为简单。我说一句，感受一下。"把一个事情做出来容易，把事情用最简单有效的方法做出来，是一个很难的事情。"比如，做一个三方授权，oauth2.0 很简单，所有概念和细节都是紧凑、完备、易用的。你觉得要设计到 oauth2.0 这个效果很容易么？要做到简单，就要对自己处理的问题有全面的了解，然后需要不断积累思考，才能做到从各个角度和层级去认识这个问题，打磨出一个通俗、紧凑、完备的设计，就像 ios 的交互设计。简单不是容易做到的，需要大家在不断的时间和 code review 过程中去积累思考，pk 中触发思考，交流中总结思考，才能做得愈发地好，接近'大道至简'。</p><p>两张经典的模型图，简单又全面，感受一下，没看懂，可以立即自行 google 学习一下：RBAC:<img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/11.png?raw=true" alt="Image" /></p><p>logging:</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/22.png?raw=true" alt="Image" /><figcaption aria-hidden="true">Image</figcaption></figure><h2 id="原则-3-组合原则-设计时考虑拼接组合">原则 3 组合原则: 设计时考虑拼接组合</h2><p>关于 OOP，关于继承，我前面已经说过了。那我们怎么组织自己的模块？对，用组合的方式来达到。linux 操作系统离我们这么近，它是怎么架构起来的？往小里说，我们一个串联一个业务请求的数据集合，如果使用 BaseSession，XXXSession inherit BaseSession 的设计，其实，这个继承树，很难适应层出不穷的变化。但是如果使用组合，就可以拆解出 UserSignature 等等各种可能需要的部件，在需要的时候组合使用，不断添加新的部件而没有对老的继承树的记忆这个心智负担。</p><p>使用组合，其实就是要让你明确清楚自己现在所拥有的是哪个部件。如果部件过于多，其实完成组合最终成品这个步骤，就会有较高的心智负担，每个部件展开来，琳琅满目，眼花缭乱。比如 QT 这个通用 UI 框架，看它的Class 列表，有 1000 多个。如果不用继承树把它组织起来，平铺展开，组合出一个页面，将会变得心智负担高到无法承受。OOP 在'需要无数元素同时展现出来'这种复杂度极高的场景，有效的控制了复杂度 。'那么，古尔丹，代价是什么呢？'代价就是，一开始做出这个自上而下的设计，牵一发而动全身，每次调整都变得异常困难。</p><p>实际项目中，各种职业级别不同的同学一起协作修改一个 server 的代码，就会出现，职级低的同学改哪里都改不对，根本没能力进行修改，高级别的同学能修改对，也不愿意大规模修改，整个项目变得愈发不合理。对整个继承树没有完全认识的同学都没有资格进行任何一个对继承树有调整的修改，协作变得寸步难行。代码的修改，都变成了依赖一个高级架构师高强度监控继承体系的变化，低级别同学们束手束脚的结果。组合，就很好的解决了这个问题，把问题不断细分，每个同学都可以很好地攻克自己需要攻克的点，实现一个 package。产品逻辑代码，只需要去组合各个 package，就能达到效果。</p><p>这是 golang 标准库里 http request 的定义，它就是 Http 请求所有特性集合出来的结果。其中通用/异变/多种实现的部分，通过 duck interface 抽象，比如 Body io.ReadCloser。你想知道哪些细节，就从组合成 request 的部件入手，要修改，只需要修改对应部件。[这段代码后，对比.NET 的 HTTP 基于 OOP 的抽象]</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Request represents an HTTP request received by a server</span><br><span class="hljs-comment">// or to be sent by a client.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// The field semantics differ slightly between client and server</span><br><span class="hljs-comment">// usage. In addition to the notes on the fields below, see the</span><br><span class="hljs-comment">// documentation for Request.Write and RoundTripper.</span><br><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Method specifies the HTTP method (GET, POST, PUT, etc.).</span><br><span class="hljs-comment">// For client requests, an empty string means GET.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Go&#x27;s HTTP client does not support sending a request with</span><br><span class="hljs-comment">// the CONNECT method. See the documentation on Transport for</span><br><span class="hljs-comment">// details.</span><br>Method <span class="hljs-type">string</span><br><br><span class="hljs-comment">// URL specifies either the URI being requested (for server</span><br><span class="hljs-comment">// requests) or the URL to access (for client requests).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For server requests, the URL is parsed from the URI</span><br><span class="hljs-comment">// supplied on the Request-Line as stored in RequestURI.  For</span><br><span class="hljs-comment">// most requests, fields other than Path and RawQuery will be</span><br><span class="hljs-comment">// empty. (See RFC 7230, Section 5.3)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, the URL&#x27;s Host specifies the server to</span><br><span class="hljs-comment">// connect to, while the Request&#x27;s Host field optionally</span><br><span class="hljs-comment">// specifies the Host header value to send in the HTTP</span><br><span class="hljs-comment">// request.</span><br>URL *url.URL<br><br><span class="hljs-comment">// The protocol version for incoming server requests.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, these fields are ignored. The HTTP</span><br><span class="hljs-comment">// client code always uses either HTTP/1.1 or HTTP/2.</span><br><span class="hljs-comment">// See the docs on Transport for details.</span><br>Proto      <span class="hljs-type">string</span> <span class="hljs-comment">// &quot;HTTP/1.0&quot;</span><br>ProtoMajor <span class="hljs-type">int</span>    <span class="hljs-comment">// 1</span><br>ProtoMinor <span class="hljs-type">int</span>    <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// Header contains the request header fields either received</span><br><span class="hljs-comment">// by the server or to be sent by the client.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// If a server received a request with header lines,</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//Host: example.com</span><br><span class="hljs-comment">//accept-encoding: gzip, deflate</span><br><span class="hljs-comment">//Accept-Language: en-us</span><br><span class="hljs-comment">//fOO: Bar</span><br><span class="hljs-comment">//foo: two</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// then</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//Header = map[string][]string&#123;</span><br><span class="hljs-comment">//&quot;Accept-Encoding&quot;: &#123;&quot;gzip, deflate&quot;&#125;,</span><br><span class="hljs-comment">//&quot;Accept-Language&quot;: &#123;&quot;en-us&quot;&#125;,</span><br><span class="hljs-comment">//&quot;Foo&quot;: &#123;&quot;Bar&quot;, &quot;two&quot;&#125;,</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For incoming requests, the Host header is promoted to the</span><br><span class="hljs-comment">// Request.Host field and removed from the Header map.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// HTTP defines that header names are case-insensitive. The</span><br><span class="hljs-comment">// request parser implements this by using CanonicalHeaderKey,</span><br><span class="hljs-comment">// making the first character and any characters following a</span><br><span class="hljs-comment">// hyphen uppercase and the rest lowercase.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, certain headers such as Content-Length</span><br><span class="hljs-comment">// and Connection are automatically written when needed and</span><br><span class="hljs-comment">// values in Header may be ignored. See the documentation</span><br><span class="hljs-comment">// for the Request.Write method.</span><br>Header Header<br><br><span class="hljs-comment">// Body is the request&#x27;s body.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, a nil body means the request has no</span><br><span class="hljs-comment">// body, such as a GET request. The HTTP Client&#x27;s Transport</span><br><span class="hljs-comment">// is responsible for calling the Close method.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For server requests, the Request Body is always non-nil</span><br><span class="hljs-comment">// but will return EOF immediately when no body is present.</span><br><span class="hljs-comment">// The Server will close the request body. The ServeHTTP</span><br><span class="hljs-comment">// Handler does not need to.</span><br>Body io.ReadCloser<br><br><span class="hljs-comment">// GetBody defines an optional func to return a new copy of</span><br><span class="hljs-comment">// Body. It is used for client requests when a redirect requires</span><br><span class="hljs-comment">// reading the body more than once. Use of GetBody still</span><br><span class="hljs-comment">// requires setting Body.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For server requests, it is unused.</span><br>GetBody <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (io.ReadCloser, <span class="hljs-type">error</span>)<br><br><span class="hljs-comment">// ContentLength records the length of the associated content.</span><br><span class="hljs-comment">// The value -1 indicates that the length is unknown.</span><br><span class="hljs-comment">// Values &gt;= 0 indicate that the given number of bytes may</span><br><span class="hljs-comment">// be read from Body.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, a value of 0 with a non-nil Body is</span><br><span class="hljs-comment">// also treated as unknown.</span><br>ContentLength <span class="hljs-type">int64</span><br><br><span class="hljs-comment">// TransferEncoding lists the transfer encodings from outermost to</span><br><span class="hljs-comment">// innermost. An empty list denotes the &quot;identity&quot; encoding.</span><br><span class="hljs-comment">// TransferEncoding can usually be ignored; chunked encoding is</span><br><span class="hljs-comment">// automatically added and removed as necessary when sending and</span><br><span class="hljs-comment">// receiving requests.</span><br>TransferEncoding []<span class="hljs-type">string</span><br><br><span class="hljs-comment">// Close indicates whether to close the connection after</span><br><span class="hljs-comment">// replying to this request (for servers) or after sending this</span><br><span class="hljs-comment">// request and reading its response (for clients).</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For server requests, the HTTP server handles this automatically</span><br><span class="hljs-comment">// and this field is not needed by Handlers.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, setting this field prevents re-use of</span><br><span class="hljs-comment">// TCP connections between requests to the same hosts, as if</span><br><span class="hljs-comment">// Transport.DisableKeepAlives were set.</span><br>Close <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// For server requests, Host specifies the host on which the</span><br><span class="hljs-comment">// URL is sought. For HTTP/1 (per RFC 7230, section 5.4), this</span><br><span class="hljs-comment">// is either the value of the &quot;Host&quot; header or the host name</span><br><span class="hljs-comment">// given in the URL itself. For HTTP/2, it is the value of the</span><br><span class="hljs-comment">// &quot;:authority&quot; pseudo-header field.</span><br><span class="hljs-comment">// It may be of the form &quot;host:port&quot;. For international domain</span><br><span class="hljs-comment">// names, Host may be in Punycode or Unicode form. Use</span><br><span class="hljs-comment">// golang.org/x/net/idna to convert it to either format if</span><br><span class="hljs-comment">// needed.</span><br><span class="hljs-comment">// To prevent DNS rebinding attacks, server Handlers should</span><br><span class="hljs-comment">// validate that the Host header has a value for which the</span><br><span class="hljs-comment">// Handler considers itself authoritative. The included</span><br><span class="hljs-comment">// ServeMux supports patterns registered to particular host</span><br><span class="hljs-comment">// names and thus protects its registered Handlers.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, Host optionally overrides the Host</span><br><span class="hljs-comment">// header to send. If empty, the Request.Write method uses</span><br><span class="hljs-comment">// the value of URL.Host. Host may contain an international</span><br><span class="hljs-comment">// domain name.</span><br>Host <span class="hljs-type">string</span><br><br><span class="hljs-comment">// Form contains the parsed form data, including both the URL</span><br><span class="hljs-comment">// field&#x27;s query parameters and the PATCH, POST, or PUT form data.</span><br><span class="hljs-comment">// This field is only available after ParseForm is called.</span><br><span class="hljs-comment">// The HTTP client ignores Form and uses Body instead.</span><br>Form url.Values<br><br><span class="hljs-comment">// PostForm contains the parsed form data from PATCH, POST</span><br><span class="hljs-comment">// or PUT body parameters.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This field is only available after ParseForm is called.</span><br><span class="hljs-comment">// The HTTP client ignores PostForm and uses Body instead.</span><br>PostForm url.Values<br><br><span class="hljs-comment">// MultipartForm is the parsed multipart form, including file uploads.</span><br><span class="hljs-comment">// This field is only available after ParseMultipartForm is called.</span><br><span class="hljs-comment">// The HTTP client ignores MultipartForm and uses Body instead.</span><br>MultipartForm *multipart.Form<br><br><span class="hljs-comment">// Trailer specifies additional headers that are sent after the request</span><br><span class="hljs-comment">// body.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For server requests, the Trailer map initially contains only the</span><br><span class="hljs-comment">// trailer keys, with nil values. (The client declares which trailers it</span><br><span class="hljs-comment">// will later send.)  While the handler is reading from Body, it must</span><br><span class="hljs-comment">// not reference Trailer. After reading from Body returns EOF, Trailer</span><br><span class="hljs-comment">// can be read again and will contain non-nil values, if they were sent</span><br><span class="hljs-comment">// by the client.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For client requests, Trailer must be initialized to a map containing</span><br><span class="hljs-comment">// the trailer keys to later send. The values may be nil or their final</span><br><span class="hljs-comment">// values. The ContentLength must be 0 or -1, to send a chunked request.</span><br><span class="hljs-comment">// After the HTTP request is sent the map values can be updated while</span><br><span class="hljs-comment">// the request body is read. Once the body returns EOF, the caller must</span><br><span class="hljs-comment">// not mutate Trailer.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Few HTTP clients, servers, or proxies support HTTP trailers.</span><br>Trailer Header<br><br><span class="hljs-comment">// RemoteAddr allows HTTP servers and other software to record</span><br><span class="hljs-comment">// the network address that sent the request, usually for</span><br><span class="hljs-comment">// logging. This field is not filled in by ReadRequest and</span><br><span class="hljs-comment">// has no defined format. The HTTP server in this package</span><br><span class="hljs-comment">// sets RemoteAddr to an &quot;IP:port&quot; address before invoking a</span><br><span class="hljs-comment">// handler.</span><br><span class="hljs-comment">// This field is ignored by the HTTP client.</span><br>RemoteAddr <span class="hljs-type">string</span><br><br><span class="hljs-comment">// RequestURI is the unmodified request-target of the</span><br><span class="hljs-comment">// Request-Line (RFC 7230, Section 3.1.1) as sent by the client</span><br><span class="hljs-comment">// to a server. Usually the URL field should be used instead.</span><br><span class="hljs-comment">// It is an error to set this field in an HTTP client request.</span><br>RequestURI <span class="hljs-type">string</span><br><br><span class="hljs-comment">// TLS allows HTTP servers and other software to record</span><br><span class="hljs-comment">// information about the TLS connection on which the request</span><br><span class="hljs-comment">// was received. This field is not filled in by ReadRequest.</span><br><span class="hljs-comment">// The HTTP server in this package sets the field for</span><br><span class="hljs-comment">// TLS-enabled connections before invoking a handler;</span><br><span class="hljs-comment">// otherwise it leaves the field nil.</span><br><span class="hljs-comment">// This field is ignored by the HTTP client.</span><br>TLS *tls.ConnectionState<br><br><span class="hljs-comment">// Cancel is an optional channel whose closure indicates that the client</span><br><span class="hljs-comment">// request should be regarded as canceled. Not all implementations of</span><br><span class="hljs-comment">// RoundTripper may support Cancel.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For server requests, this field is not applicable.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Deprecated: Set the Request&#x27;s context with NewRequestWithContext</span><br><span class="hljs-comment">// instead. If a Request&#x27;s Cancel field and context are both</span><br><span class="hljs-comment">// set, it is undefined whether Cancel is respected.</span><br>Cancel &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// Response is the redirect response which caused this request</span><br><span class="hljs-comment">// to be created. This field is only populated during client</span><br><span class="hljs-comment">// redirects.</span><br>Response *Response<br><br><span class="hljs-comment">// ctx is either the client or server context. It should only</span><br><span class="hljs-comment">// be modified via copying the whole Request using WithContext.</span><br><span class="hljs-comment">// It is unexported to prevent people from using Context wrong</span><br><span class="hljs-comment">// and mutating the contexts held by callers of the same request.</span><br>ctx context.Context<br>&#125;<br></code></pre></td></tr></table></figure><p>看看.NET 里对于 web 服务的抽象，仅仅看到末端，不去看完整个继承树的完整图景，我根本无法知道我关心的某个细节在什么位置。进而，我要往整个 http 服务体系里修改任何功能，都无法抛开对整体完整设计的理解和熟悉，还极容易没有知觉地破坏者整体的设计。</p><p>说到组合，还有一个关系很紧密的词，叫插件化。大家都用 vscode 用得很开心，它比 visual studio 成功在哪里？如果 vscode 通过添加一堆插件达到 visual studio 具备的能力，那么它将变成另一个和 visual studio 差不多的东西，叫做 vs studio 吧。大家应该发现问题了，我们很多时候其实并不需要 visual studio 的大多数功能，而且希望灵活定制化一些比较小众的能力，用一些小众的插件。甚至，我们希望选择不同实现的同类型插件。这就是组合的力量，各种不同的组合，它简单，却又满足了各种需求，灵活多变，要实现一个插件，不需要事先掌握一个庞大的体系。体现在代码上，也是一样的道理。至少后端开发领域，组合，比 OOP，'香'很多。</p><h2 id="原则-6-吝啬原则-除非确无它法-不要编写庞大的程序">原则 6 吝啬原则: 除非确无它法, 不要编写庞大的程序</h2><p>可能有些同学会觉得，把程序写得庞大一些才好拿得出手去评 T11、T12。leader 们一看评审方案就容易觉得：很大，很好，很全面。但是，我们真的需要写这么大的程序么？</p><p>我又要说了"那么，古尔丹，代价是什么呢？"。代价是代码越多，越难维护，难调整。C 语言之父 Ken Thompson 说"删除一行代码，给我带来的成就感要比添加一行要大"。我们对于代码，要吝啬。能把系统做小，就不要做大。腾讯不乏 200w+行的客户端，很大，很牛。但是，同学们自问，现在还调整得动架构么。手 Q 的同学们，看看自己代码，曾经叹息过么。能小做的事情就小做，寻求通用化，通过 duck interface(甚至多进程，用于隔离能力的多线程)把模块、能力隔离开，时刻想着删减代码量，才能保持代码的可维护性和面对未来的需求、架构，调整自身的活力。客户端代码，UI 渲染模块可以复杂吊炸天，非 UI 部分应该追求最简单，能力接口化，可替换、重组合能力强。</p><p>落地到大家的代码，review 时，就应该最关注核心 struct 定义，构建起一个完备的模型，核心 interface，明确抽象 model 对外部的依赖，明确抽象 model 对外提供的能力。其他代码，就是要用最简单、平平无奇的代码实现模型内部细节。</p><h2 id="原则-7-透明性原则-设计要可见以便审查和调试">原则 7 透明性原则: 设计要可见，以便审查和调试</h2><p>首先，定义一下，什么是透明性和可显性。</p><p>"如果没有阴暗的角落和隐藏的深度，软件系统就是透明的。透明性是一种被动的品质。如果实际上能预测到程序行为的全部或大部分情况，并能建立简单的心理模型，这个程序就是透明的，因为可以看透机器究竟在干什么。</p><p>如果软件系统所包含的功能是为了帮助人们对软件建立正确的'做什么、怎么做'的心理模型而设计，这个软件系统就是可显的。因此，举例来说，对用户而言，良好的文档有助于提高可显性；对程序员而言，良好的变量和函数名有助于提高可显性。可显性是一种主动品质。在软件中要达到这一点，仅仅做到不晦涩是不够的，还必须要尽力做到有帮助。"</p><p>我们要写好程序，减少 bug，就要增强自己对代码的控制力。你始终做到，理解自己调用的函数/复用的代码大概是怎么实现的。不然，你可能就会在单线程状态机的 server 里调用有 IO 阻塞的函数，让自己的 server 吞吐量直接掉到底。进而，为了保证大家能对自己代码能做到有控制力，所有人写的函数，就必须具备很高的透明性。而不是写一些看了一阵看不明白的函数/代码，结果被迫使用你代码的人，直接放弃了对掌控力的追取，甚至放弃复用你的代码，另起炉灶，走向了'制造重复代码'的深渊。</p><p>透明性其实相对容易做到的，大家有意识地锻炼一两个月，就能做得很好。可显性就不容易了。有一个现象是，你写的每一个函数都不超过 80 行，每一行我都能看懂，但是你层层调用，很多函数调用，组合起来怎么就实现了某个功能，看两遍，还是看不懂。第三遍可能才能大概看懂。大概看懂了，但太复杂，很难在大脑里构建起你实现这个功能的整体流程。结果就是，阅读者根本做不到对你的代码有好的掌控力。</p><p>可显性的标准很简单，大家看一段代码，懂不懂，一下就明白了。但是，如何做好可显性？那就是要追求合理的函数分组，合理的函数上下级层次，同一层次的代码才会出现在同一个函数里，追求通俗易懂的函数分组分层方式，是通往可显性的道路。</p><p>当然，复杂如 linux 操作系统，office 文档，问题本身就很复杂，拆解、分层、组合得再合理，都难建立心理模型。这个时候，就需要完备的文档了。完备的文档还需要出现在离代码最近的地方，让人'知道这里复杂的逻辑有文档'，而不是其实文档，但是阅读者不知道。再看看上面 golang 标准库里的 http.Request，感受到它在可显性上的努力了么？对，就去学它。</p><h2 id="原则-10-通俗原则-接口设计避免标新立异">原则 10 通俗原则: 接口设计避免标新立异</h2><p>设计程序过于标新立异的话，可能会提升别人理解的难度。</p><p>一般，我们这么定义一个'点'，使用 x 表示横坐标，用 y 表示纵坐标：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br> X <span class="hljs-type">float64</span><br> Y <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你就是要不同、精准：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br> VerticalOrdinate   <span class="hljs-type">float64</span><br> HorizontalOrdinate <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很好，你用词很精准，一般人还驳斥不了你。但是，多数人读你的 VerticalOrdinate 就是没有读 X 理解来得快，来得容易懂、方便。你是在刻意制造协作成本。</p><p>上面的例子常见，但还不是最小立异原则最想说明的问题。想想一下，一个程序里，你把用'+'这个符号表示数组添加元素，而不是数学'加'，'result := 1+2' --&gt; 'result = []int{1, 2}'而不是'result=3'，那么，你这个标新立异，对程序的破坏性，简直无法想象。"最小立异原则的另一面是避免表象想死而实际却略有不同。这会极端危险，因为表象相似往往导致人们产生错误的假定。所以最好让不同事物有明显区别，而不要看起来几乎一模一样。" -- Henry Spencer。</p><p>你实现一个 db.Add()函数却做着 db.AddOrUpdate()的操作，有人使用了你的接口，错误地把数据覆盖了。</p><h2 id="原则-11-缄默原则-如果一个程序没什么好说的就沉默"><strong>原则 11 缄默原则: 如果一个程序没什么好说的，就沉默</strong></h2><p>这个原则，应该是大家最经常破坏的原则之一。一段简短的代码里插入了各种'log("cmd xxx enter")', 'log("req data " + req.String())'，非常害怕自己信息打印得不够。害怕自己不知道程序执行成功了，总要最后'log("success")'。但是，我问一下大家，你们真的耐心看过别人写的代码打的一堆日志么？不是自己需要哪个，就在一堆日志里，再打印一个日志出来一个带有特殊标记的日志'log("this_is_my_log_" + xxxxx)'？结果，第一个作者打印的日志，在代码交接给其他人或者在跟别人协作的时候，这个日志根本没有价值，反而提升了大家看日志的难度。</p><p>一个服务一跑起来，就疯狂打日志，请求处理正常也打一堆日志。滚滚而来的日志，把错误日志淹没在里面。错误日志失去了效果，简单地 tail 查看日志，眼花缭乱，看不出任何问题，这不就成了'为了捕获问题'而让自己'根本无法捕获问题'了么？</p><p>沉默是金。除了简单的 stat log，如果你的程序'发声'了，那么它抛出的信息就一定要有效！打印一个 log('process fail')也是毫无价值，到底什么 fail 了？是哪个用户带着什么参数在哪个环节怎么 fail 了？如果发声，就要把必要信息给全。不然就是不发声，表示自己好好地 work 着呢。不发声就是最好的消息，现在我的 work 一切正常！</p><p>"设计良好的程序将用户的注意力视为有限的宝贵资源，只有在必要时才要求使用。"程序员自己的主力，也是宝贵的资源！只有有必要的时候，日志才跑来提醒程序员'我有问题，来看看'，而且，必须要给到足够的信息，让一把讲明白现在发生了什么。而不是程序员还需要很多辅助手段来搞明白到底发生了什么。</p><p>每当我发布程序 ，我抽查一个机器，看它的日志。发现只有每分钟外部接入、内部 rpc 的个数/延时分布日志的时候，我就心情很愉悦。我知道，这一分钟，它的成功率又是 100%，没任何问题！</p><h2 id="原则-12-补救原则-出现异常时马上退出并给出足够错误信息">原则 12 补救原则: 出现异常时，马上退出并给出足够错误信息</h2><p>其实这个问题很简单，如果出现异常，异常并不会因为我们尝试掩盖它，它就不存在了。所以，程序错误和逻辑错误要严格区分对待。这是一个态度问题。</p><p>'异常是互联网服务器的常态'。逻辑错误通过 metrics 统计，我们做好告警分析。对于程序错误 ，我们就必须要严格做到在问题最早出现的位置就把必要的信息搜集起来，高调地告知开发和维护者'我出现异常了，请立即修复我!'。可以是直接就没有被捕获的 panic 了。也可以在一个最上层的位置统一做好 recover 机制，但是在 recover 的时候一定要能获得准确异常位置的准确异常信息。不能有中间 catch 机制，catch 之后丢失很多信息再往上传递。</p><p>很多 Java 开发的同学，不区分程序错误和逻辑错误，要么都很宽容，要么都很严格，对代码的可维护性是毁灭性的破坏。"我的程序没有程序错误，如果有，我当时就解决了。"只有这样，才能保持程序代码质量的相对稳定，在火苗出现时扑灭火灾是最好的扑灭火灾的方式。当然，更有效的方式是全面自动化测试的预防：）</p><h1 id="具体实践点">具体实践点</h1><p>前面提了好多思考方向的问题。大的原则问题和方向。我这里，再来给大家简单列举几个细节执行点吧。毕竟，大家要上手，是从执行开始，然后才是总结思考，能把我的思考方式抄过去。下面是针对 golang 语言的，其他语言略有不同。以及，我一时也想不全我所执行的 所有细则，这就是我强调'原则'的重要性，原则是可枚举的。</p><ul><li>对于代码格式规范，100%严格执行，严重容不得一点沙。</li><li>文件绝不能超过 800 行，超过，一定要思考怎么拆文件。工程思维，就在于拆文件的时候积累。</li><li>函数对决不能超过 80 行，超过，一定要思考怎么拆函数，思考函数分组，层次。工程思维，就在于拆文件的时候积累。</li><li>代码嵌套层次不能超过 4 层，超过了就得改。多想想能不能 early return。工程思维，就在于拆文件的时候积累。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> !needContinue &#123;<br> doA()<br> <span class="hljs-keyword">return</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br> doB()<br> <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> !needContinue &#123;<br> doA()<br> <span class="hljs-keyword">return</span><br>&#125;<br><br>doB()<br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>下面这个就是 early return，把两端代码从逻辑上解耦了。</p><ul><li>从目录、package、文件、struct、function 一层层下来 ，信息一定不能出现冗余。比如 file.FileProperty 这种定义。只有每个'定语'只出现在一个位置，才为'做好逻辑、定义分组/分层'提供了可能性。</li><li>多用多级目录来组织代码所承载的信息，即使某一些中间目录只有一个子目录。</li><li>随着代码的扩展，老的代码违反了一些设计原则，应该立即原地局部重构，维持住代码质量不滑坡。比如:拆文件；拆函数；用 Session 来保存一个复杂的流程型函数的所有信息；重新调整目录结构。</li><li>基于上一点考虑，我们应该尽量让项目的代码有一定的组织、层次关系。我个人的当前实践是除了特别通用的代码，都放在一个 git 里。特别通用、修改少的代码，逐渐独立出 git，作为子 git 连接到当前项目 git，让 goland 的 Refactor 特性、各种 Refactor 工具能帮助我们快速、安全局部重构。</li><li>自己的项目代码，应该有一个内生的层级和逻辑关系。flat 平铺展开是非常不利于代码复用的。怎么复用、怎么组织复用，肯定会变成'人生难题'。T4-T7 的同学根本无力解决这种难题。</li><li>如果被 review 的代码虽然简短，但是你看了一眼却发现不咋懂，那就一定有问题。自己看不出来，就找高级别的同学交流。这是你和别 review 代码的同学成长的时刻。</li><li>日志要少打。要打日志就要把关键索引信息带上。必要的日志必须打。</li><li>有疑问就立即问，不要怕问错。让代码作者给出解释。不要怕问出极低问题。</li><li>不要说'建议'，提问题，就是刚，你 pk 不过我，就得改！</li><li>请积极使用 trpc。总是要和老板站在一起！只有和老板达成的对于代码质量建设的共识，才能在团队里更好地做好代码质量建设。</li><li>消灭重复！消灭重复！消灭重复！</li></ul><h1 id="主干开发">主干开发</h1><p>最后，我来为'主干开发'多说一句话。道理很简单，只有每次被 review 代码不到 500 行，reviewer 才能快速地看完，而且几乎不会看漏。超过 500 行，reviewer 就不能仔细看，只能大概浏览了。而且，让你调整 500 行代码内的逻辑比调整 3000 行甚至更多的代码，容易很多，降低不仅仅是 6 倍，而是一到两个数量级。有问题，在刚出现的时候就调整了，不会给被 revew 的人带来大的修改负担。</p><p>关于 CI(continuous integration)，还有很多好的资料和书籍，大家应该及时去学习学习。</p><h1 id="unix-编程艺术">《unix 编程艺术》</h1><p>建议大家把这本书找出来读一读。特别是，T7 及更高级别的同学。你们已经积累了大量的代码实践，亟需对'工程性'做思考总结。很多工程方法论都过时了，这本书的内容，是例外中的例外。它所表达出的内容没有因为软件技术的不断更替而过时。</p><p>佛教禅宗讲'不立文字'(不立文字，教外别传，直指人心，见性成佛)，很多道理和感悟是不能用文字传达的，文字的表达能力，不能表达。大家常常因为"自己听说过、知道某个道理"而产生一种安心感，认为"我懂了这个道理"，但是自己却不能在实践中做到。知易行难，知道却做不到，在工程实践里，就和'不懂这个道理'没有任何区别了。</p><p>曾经，我面试过一个别的公司的总监，讲得好像一套一套，代码拉出来遛一遛，根本就没做到，仅仅会道听途说。他在工程实践上的探索前路可以说已经基本断绝了。我只能祝君能做好向上管理，走自己的纯管理道路吧。请不要再说自己对技术有追求，是个技术人了！</p><p>所以，大家不仅仅是看看我这篇文章，而是在实践中去不断践行和积累自己的'教外别传'吧。</p><p>Software Engineering at Google也是一本必读好书。</p>]]></content>
    
    
    <categories>
      
      <category>Coding</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>500规则：让一条公式，助您拍摄高质量“星夜”</title>
    <link href="/2020/12/09/2020-12-12-500%E8%A7%84%E5%88%99/"/>
    <url>/2020/12/09/2020-12-12-500%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_2_2019022208162568.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>当用固定的三脚架拍摄星夜时，使用500规则来测量最慢的快门速度，以避免出现星迹。</p><p>这条规则是一个更大的经验规则家族中的一部分，这些规则主要是在胶片摄影的时代发展起来的。目的是在特定的拍摄环境中，帮助摄影师快速设置他们的相机。</p><p>事实上，使用胶卷拍摄你的压力就会非常的大，就越有可能在镜头里的内容拍得恰到好处。因为只有冲洗好胶卷，你才能看的到结果。</p><p>然而，在数字摄影时代，我们可以实时地检查拍摄结果。我们可以负担得起一点马虎和调整设置偏差。尽管如此，通过学习这些规则，即使是在数字化拍摄时代也非常受用。</p><p>这种显著的经验规则例如众所周知的阳光16、阴天8和日落4等。这些方法涉及在特定的日光条件下设置适当的曝光量。甚至是对于你的夜间摄影，月光11规则将帮助你正确地曝光月球。</p><h1 id="什么是500规则">什么是500规则？</h1><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_3_20190222081625177.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>500规则背后的想法是为你提供一个容易记住的公式来定格恒星的运动，并避免产生恒星轨迹（星轨）。</p><p>当然，如果你的目标是星轨，那么你应该忽略这条规则。这条规则的目的是，让你可以捕捉到银河系和星空的清晰图像。</p><p>但为什么你的拍摄会产生星轨呢？那是因为地球每天都在自转一次。这种自转产生了相当每小时15度的运动表现。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_4_20190222081625287.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>在天文摄影中，我们把定格星体运动作为一件大事。严格来说，图像上星迹的长度将取决于相机镜头组合的视角、传感器大小、图像分辨率、曝光时间以及星光角速度和偏角。</p><p>虽然这些看似很难理解，所以将这些变量联系在一起的公式并不是最容易记住和简单的实际使用。</p><p>如果您只是偶尔拍摄星空，知道如何使用更简单的500规则将让你的拍摄更加简单。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_5_20190222081625396.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>规则如下：SS = 500 /（FL * CF）</strong></p><p>SS是以秒为单位的快门速度，FL是以mm表示的焦距，CF是传感器的裁剪系数，即全画幅传感器与您的相机传感器之间的比率。</p><p>不同类型相机的常见裁剪系数CF是：</p><ul><li>1用于全画幅相机</li><li>1.6（1.5）适用于佳能（尼康）APS-C相机</li><li>2用于M4/3</li></ul><p>据我所知，虽然它可能与指定焦距的图像分辨率和视野压缩相关，但使用数字“500”并没有实际意义。它是一个任意常数，因此规则在大多数情况下都能正常工作。</p><h1 id="规则的实际使用">500规则的实际使用</h1><p>让我们来试试使用M4/3传感器相机，它的裁剪系数等于2。现在让我们来看看这条规则是如何使用的。</p><p>例如，用一个50毫米的镜头，500法则将告诉我星轨不会出现的曝光时间是：</p><p>SS=500/(50*2)=5秒。</p><p>对于具有相同镜头的全画幅，曝光时间将为：</p><p>SS=500/(50*1)=10秒。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_6_20190222081625521.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上面的图片显示了当用50毫米镜头在M4/3画幅上使用3分钟的曝光时间，这一暴光时间比规则所建议的要长得多。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_7_20190222081625646.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>通过使用500规则，当使用远摄镜头拍摄明亮的星云时，您甚至可以获得不错的效果，虽然细节水平不会那么令人印象深刻，但这将是一次非常令人满意的体验，我建议您也试一试。</p><h1 id="和600以及npf规则">400和600以及NPF规则</h1><p>500规则有两种常见的变体，分别是400和600规则。</p><p>在400规则中，上面的公式中的数字500被400替换。这导致更短的曝光时间。使用600规则时，导致稍慢的快门速度，即更长的曝光时间。</p><p>如果想要更好的结果，则应切换到其他规则，例如NPF规则，这500规则更准确和严谨，但是计算会非常复杂。</p><p>如今，您可以找到许多计算器等智能手机应用程序。这些可以帮助您为相机镜头组合选择最佳曝光时间。</p><h1 id="使用500规则和图像堆叠改善您的星空摄影">使用500规则和图像堆叠改善您的星空摄影</h1><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_8_20190222081625756.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>要改善图像，首先要使用RAW而不是JPEG。这将确保您在需要编辑图像时具有最大的灵活性。</p><p>如果您没有使用设备跟踪星体运动，则星体将始终穿过传感器。您可以为每个像素收集的光仅取决于星体在同一像素上停留多长时间。</p><p>你可能想要提高你的ISO，但这只会增加图像噪点，没有额外的好处。</p><p>通过使用更长的曝光也无济于事，因为星体激发相同像素的时间不会改变。</p><p>该解决方案称为图像堆叠</p><p>通过以相当低的ISO拍摄许多照片，每个照片根据500规则曝光，然后您可以稍后组合（堆叠）它们，这将显著改善最终图像中的细节。</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_9_20190222081625865.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上面你可以看到M4/3传感器相机中的单次拍摄于图像堆叠之间的比较</p><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_10_201902220816266.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>最终的图像，获得了8个不同的曝光。您可以看到堆叠如何提升细节并丰富天空。</p><p>对于图像堆叠的细节操作，我将会在后期的文章中带来详细的分解操作。</p><h1 id="出于好奇500规则背后的科学">出于好奇：500规则背后的科学</h1><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_11_20190222081626193.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>500规则背后的想法是提供一种简单的逻辑来计算运动不明显的最长曝光时间。</p><p>天空在24小时内旋转360度，或每秒0.0042度。带有24mm镜头的全画幅相机将具有大约73.7度的水平视图。</p><p>假设我们有一个24 Mpx传感器（6000px X 4000px）。那些73.7度投影到6000个水平像素，每度为81.4像素。</p><p>假设24mm镜头，“500规则”给你的曝光时间约为21秒（500/24）。</p><p>在21秒内，天空将移动大约0.09度（0.0042 * 21）。</p><p>对于配备24mm镜头的24 Mpx全画幅相机，0.1度转换为7.3像素（81.4 * 0.1）。</p><p>那些7.3像素表示在点状恒星变成星迹之前可接受的最大运动模糊。但这种运动真的可以接受吗？</p><p>我们习惯于在电脑屏幕上查看我们的图像。如果将全分辨率图像炸成100％，您将看到星形不是圆点。</p><p>但印刷品怎么样？</p><p>事实证明，如果您以30x45cm格式打印图像，那么这7个像素将构成您的打印仅0.5毫米长的痕迹！</p><h1 id="结语">结语</h1><figure><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/blog-1/154792415_12_20190222081626318.jpg?raw=true" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Photogaphy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Photogaphy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>引擎搜索技巧</title>
    <link href="/2020/12/02/2020-12-02-%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/12/02/2020-12-02-%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="搜索技巧">搜索技巧</h1><p><strong>标点符号均为英文，以谷歌为例，大部分百度或其他搜索引擎同样支持</strong></p><ul class="task-list"><li><input type="checkbox" disabled="" />准确搜索：给关键词加上英文双引号<ul><li>eg: “人工智能算法”</li></ul></li><li><input type="checkbox" disabled="" />排除关键词：在搜索内容后面加上空格减号需要排除的关键词<ul><li>eg: 苹果 -iPhone -iPad</li></ul></li><li><input type="checkbox" disabled="" />用OR逻辑搜索：用大写的OR和空格隔开关键词<ul><li>eg: 百度OR 谷歌</li></ul></li><li><input type="checkbox" disabled="" />模糊搜索：用*代替文字或单词<ul><li>eg: study * home</li></ul></li><li><input type="checkbox" disabled="" />filetype：在关键词后加上filetype:文件类型<ul><li>eg: 高等数学 filetype:pdf</li></ul></li><li><input type="checkbox" disabled="" />site：在关键词后加上site:指定的网站<ul><li>eg: 后浪 site:bilibili.com</li></ul></li><li><input type="checkbox" disabled="" />inurl/allinurl：在关键词后加上inurl:需要筛选的url关键字，allinurl必须同时包含关键词<ul><li>eg: 肖生克的救赎 inurl:movie film</li></ul></li><li><input type="checkbox" disabled="" />intitle/allintitle：在关键词后加上intitle:需要筛选的title关键字，allintitle必须同时包含关键词<ul><li>eg: machine learning intitle:stanford mit</li></ul></li><li><input type="checkbox" disabled="" />define：通过define:关键词得到准确定义<ul><li>eg: define:internet</li></ul></li></ul><p>组合示例："machine learning" -vision -drive site:stanford.edu filetype:pdf</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_hi</span>(<span class="hljs-params">name</span>)<br>  puts <span class="hljs-string">&quot;Hi, <span class="hljs-subst">#&#123;name&#125;</span>&quot;</span><br><span class="hljs-keyword">end</span><br>print_hi(<span class="hljs-string">&#x27;Tom&#x27;</span>)<br><span class="hljs-comment">#=&gt; prints &#x27;Hi, Tom&#x27; to STDOUT.</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Search</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cherry-Pick的使用</title>
    <link href="/2020/09/28/Cherry-Pick/"/>
    <url>/2020/09/28/Cherry-Pick/</url>
    
    <content type="html"><![CDATA[<h1 id="cherry-pick的作用">Cherry-Pick的作用</h1><p>假设当前所在分支为B，可以在Version Control 的 Log 中选择在A分支单个commit或者多个commit的内容，会将选中的内容拉到B分支重新进行commit，之后记得push上去，就完成了公共功能代码的拉取。</p><h1 id="git-cherry-pick的使用">Git Cherry-Pick的使用</h1><ol type="1"><li>单个commit合并</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick commit_id<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>多个<strong>连续</strong>commit合并</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick commit_id..commit_idn<br></code></pre></td></tr></table></figure><p>commit_id到commit_idn之间，非闭包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick （commit_id..commit_idn]<br></code></pre></td></tr></table></figure><p>挑选多个commit:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick commit_id commit_idx commit_idy<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>合并过程中依次<strong>解决冲突后</strong>，继续合并</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>使用命令放弃 git cherry-pick 变更</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick --abort <br></code></pre></td></tr></table></figure><h1 id="idea-cherry-pick的使用">IDEA Cherry-Pick的使用</h1><p>此时我有两个分支 分别为 test1分支和master分支,现要将test1分支的代码合并到master分支上.</p><ol type="1"><li>首先我们要将我们自己test分支的代码提交到库中,然后切换到master分支.</li></ol><figure><img src="https://img-blog.csdnimg.cn/630ad525782d40db837ff3b9d83d8b49.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54KO5Y2H,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="2" type="1"><li>通过showHistory 查看版本信息，在showHistory中的branch中查看test1分支的代码</li></ol><figure><img src="https://img-blog.csdnimg.cn/a1393cb0f9c248e289bbb6a3d3ac3118.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54KO5Y2H,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="3" type="1"><li>代码冲突解决</li></ol><p>cherry pick 后，如果存在冲突，会出现冲突提示：</p><p>界面说明：</p><blockquote><p>Accept Yours : 以自己本地代码为准。</p><p>Accept Theirs : 以分支来源代码（即：test1 分支）为准。</p><p>Merge : 查看冲突文件内容，进行冲突解决。</p></blockquote><figure><img src="https://img-blog.csdnimg.cn/7be824cd79be4873839921a7c3cc8e67.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54KO5Y2H,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol start="4" type="1"><li>解决冲突：</li></ol><p>冲突文件 解决界面说明：</p><blockquote><p>最左边 ： 为你本次提交的代码。 中间 ： 为base 你之前拉下来的代码 最右边 ： 为当前服务器有改动的代码。</p></blockquote><figure><img src="https://img-blog.csdnimg.cn/0ecf2b5f99a947589cd31625427096c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54KO5Y2H,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可以选择 Accept Left(只保存提交我的改动,可能会覆盖别人的代码)。</p><p>可以点击 "&gt;&gt;&gt;" 将变动的代码合并到中间的,可以保存双方的代码，或自己手动更改。</p><p>点击 Accept Right 只保存服务器上的代码 放弃自己对该类操作的提交。</p><p>冲突解决完成后，点击 apply ,则该文件已处理完成。 <img src="https://img-blog.csdnimg.cn/936001d5285046b989f6e61e4a42289f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54KO5Y2H,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" /></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora教程</title>
    <link href="/2020/08/15/2020-08-15-Typro%E6%95%99%E7%A8%8B/"/>
    <url>/2020/08/15/2020-08-15-Typro%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="typora快捷键"><a href="https://www.cnblogs.com/hongdada/p/9776547.html">Typora快捷键</a></h1><p>目录</p><ul><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#windows快捷键：">windows快捷键：</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#给代码块设置快捷键">给代码块设置快捷键:</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#mac中的快捷键：">Mac中的快捷键：</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#图片：">图片：</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#表情">表情</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#数学公式">数学公式</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#html">HTML</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#行内嵌数学符号">行内嵌数学符号</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#下标">下标</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#高亮">高亮</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#参考：">参考：</a></li></ul><h2 id="windows快捷键"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#3058213421">windows快捷键：</a></h2><ul><li><p>无序列表：输入-之后输入空格</p></li><li><p>有序列表：输入数字+“.”之后输入空格</p></li><li><p>任务列表：-[空格]空格 文字</p></li><li><p>标题：ctrl+数字</p></li><li><p>表格：ctrl+t</p></li><li><p>生成目录：</p><p>目录</p><ul><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#windows快捷键：">windows快捷键：</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#给代码块设置快捷键">给代码块设置快捷键:</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#mac中的快捷键：">Mac中的快捷键：</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#图片：">图片：</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#表情">表情</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#数学公式">数学公式</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#html">HTML</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#行内嵌数学符号">行内嵌数学符号</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#下标">下标</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#高亮">高亮</a></li><li><a href="https://www.cnblogs.com/hongdada/p/9776547.html#参考：">参考：</a></li></ul></li><li><p>选中一整行：ctrl+l</p></li><li><p>选中单词：ctrl+d</p></li><li><p>选中相同格式的文字：ctrl+e</p></li><li><p>跳转到文章开头：ctrl+home</p></li><li><p>跳转到文章结尾：ctrl+end</p></li><li><p>搜索：ctrl+f</p></li><li><p>替换：ctrl+h</p></li><li><p>引用：输入&gt;之后输入空格</p></li><li><p>代码块：ctrl+alt+f</p></li><li><p>加粗：ctrl+b</p></li><li><p>倾斜：ctrl+i</p></li><li><p>下划线：ctrl+u</p></li><li><p>删除线：alt+shift+5</p></li><li><p>插入图片：直接拖动到指定位置即可或者ctrl+shift+i</p></li><li><p>插入链接：ctrl + k</p></li></ul><h2 id="给代码块设置快捷键"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#1406136495">给代码块设置快捷键:</a></h2><p>偏好设置-&gt;打开高级设置-&gt;conf.user.json文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">Copy  <span class="hljs-string">&quot;keyBinding&quot;</span>: &#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-keyword">for</span> example: <br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;Always on Top&quot;</span>: <span class="hljs-string">&quot;Ctrl+Shift+P&quot;</span><br><span class="hljs-string">&quot;Always on Top&quot;</span>: <span class="hljs-string">&quot;Ctrl+Shift+P&quot;</span>,  <br>    <span class="hljs-string">&quot;Code Fences&quot;</span>: <span class="hljs-string">&quot;Ctrl+Shift+F&quot;</span>,  <br>    <span class="hljs-string">&quot;Ordered List&quot;</span>:<span class="hljs-string">&quot;Ctrl+Alt+o&quot;</span>,  <br>    <span class="hljs-string">&quot;Unordered List&quot;</span>: <span class="hljs-string">&quot;Ctrl+Alt+u&quot;</span>  <br>  &#125;,<br></code></pre></td></tr></table></figure><p>Code Fences 代码块</p><p>Ordered List 数字有序列表</p><p>Unordered List 无序列表</p><h2 id="mac中的快捷键"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#330407688">Mac中的快捷键：</a></h2><ol type="1"><li>最大标题：command + 1 或者：#</li><li>大标题：command + 2 或者：##</li><li>标准标题：command + 3 或者：###</li><li>中标题：command + 4 或者：####</li><li>小标题：command + 5 或者：#####</li><li>插入表格：command + T</li><li>插入代码：command + alt +c</li><li>行间公式 command + Alt + b</li><li>段落：command + 0</li><li>竖线 ： command + Alt +q</li><li>有序列表（1. 2.） ：输入数字+“.”之后输入空格 或者：command + Alt + o</li><li>黑点标记：command + Alt + u</li><li>隔离线shift + command + -</li><li>超链接：command + Alt + l</li><li>插入链接：command +k</li><li>下划线：command +u</li><li>加粗：command +b</li><li>搜索：command +f</li></ol><h1 id="图片"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#2797995196">图片：</a></h1><p><img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/typora1.jpg?raw=true" alt="img" /> <img src="https://github.com/hswsp/IMAGE_HOST/blob/main/Blog/typro2.jpg?raw=true" alt="img" /></p><h1 id="表情"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#1603435964">表情</a></h1><p>输出表情需要借助 <code>：</code>符号。</p><p>栗子：<code>:smile</code> 显示为 😄,记住是左右两边都要冒号。</p><p>使用者可以通过使用<code>ESC</code>键触发表情建议补全功能，也可在功能面板启用后自动触发此功能。同时，直接从菜单栏<code>Edit</code> -&gt; <code>Emoji &amp; Symbols</code>插入UTF8表情符号也是可以的。</p><p>或者使用下面的方法</p><p>访问网站 https://emojikeyboard.org/，找到需要的符号，鼠标左键单击，然后粘贴到需要的地方就行了！🆗</p><h1 id="数学公式"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#2490103694">数学公式</a></h1><p>你可以通过使用<strong>MathJax</strong>来实现<em>LaTeX</em>的数学符号的表达。</p><p>输入<code>$$</code>，然后按下<code>Enter</code>键就会弹出一个支持TeX/LaTeX语法的输入框，下面是一个栗子：</p><p>在Markdown源文件中，数学的公式块是通过利用<code>$$</code>标记借用<em>LaTeX</em>语言来实现的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">$$<br>\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 =  <br>\begin&#123;vmatrix&#125; <br>\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\<br>\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\<br>\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\<br>\end&#123;vmatrix&#125;<br>$$<br></code></pre></td></tr></table></figure><p><span class="math display">\[\mathbf{V}_1  \times  \mathbf{V}_2 =  \begin{vmatrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \\\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \\\end{vmatrix}\]</span></p><p>Another Example: <span class="math display">\[\begin{aligned} y = y(x,t) &amp;= A e^{i\theta} \\ &amp;= A (\cos \theta + i \sin \theta) \\ &amp;= A (\cos(kx - \omega t) + i \sin(kx - \omega t)) \\ &amp;= A\cos \frac{2\pi}{\lambda} (x - v t) + i A\sin \frac{2\pi}{\lambda} (x - v t)\end{aligned}\]</span></p><h2 id="how-to-support-latex-in-github-pages"><a href="https://stackoverflow.com/questions/26275645/how-to-support-latex-in-github-pages">How to support latex in github-pages?</a></h2><p>The easiest way to do this right now is to use the <a href="https://katex.org/">KaTeX</a> <a href="https://katex.org/docs/autorender.html">auto-render extension</a>.</p><p>Simply drop the following into your <code>&lt;head&gt;</code>:</p><div class="note note-success">            <p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous"></p><script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.js" integrity="sha384-9Nhn55MVVN0/4OFx7EE5kpFBPsEMZxKTCnA+4fqDmg12eCTqGi6+BB2LjY8brQxJ" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>          </div><p>Note that this assumes the following delimiters appear in your HTML:</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>\LaTeX code<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>   (<span class="hljs-keyword">for</span> <span class="hljs-keyword">display</span>)<br>\\[\LaTeX code\\] (also <span class="hljs-keyword">for</span> <span class="hljs-keyword">display</span>)<br>\\(\LaTeX code\\) (<span class="hljs-keyword">for</span> inline)<br></code></pre></td></tr></table></figure><p>Note, if using Jekyll, you will need to have the following in your <code>_config.yml</code>:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">markdown:</span> kramdown<br><span class="hljs-symbol">kramdown:</span><br><span class="hljs-symbol">    math_engine:</span> katex<br></code></pre></td></tr></table></figure><p><strong>WARNING:</strong> Do not use <code>math_engine: mathjax</code>. It will break this by automatically removing the LaTeX delimiters.</p><p><strong>Inline Example</strong>: \( i={}-1 \)</p><h1 id="html"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#2061120287">HTML</a></h1><p>Typora不能使用HTML元素，但是Typora可以解析和编译非常有限的HTML元素，作为Markdown功能的补充，这些有限的功能包括：</p><ul><li>下划线： <code>&lt;u&gt;underline&lt;/u&gt;</code></li><li>图片：<code>&lt;img src="http://www.w3.org/html/logo/img/mark-word-icon.png" width="200px" /&gt;</code>（HTML标签中的<code>width</code>, <code>height</code> 以及属于样式的<code>width</code>, <code>height</code>, <code>zoom</code>样式可以被识别和应用。）</li><li>评论：<code>&lt;!-- This is some comments --&gt;</code></li><li>超链接： <code>&lt;a href="http://typora.io" target="_blank"&gt;link&lt;/a&gt;</code> 。</li></ul><p>大多数这些属性、样式或分类会被忽略。对其他的标签，Typora会将它们以HTML片段的形式表达。</p><h1 id="行内嵌数学符号"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#3588184236">行内嵌数学符号</a></h1><p>想要使用这个功能，需要在设置面板的 <code>Markdown</code>栏启用它。然后使用<code>$</code>来启动TeX命令，栗如<code>$\lim_&#123;x \to \infty&#125; \exp(-x) = 0$</code> 会以LaTeX的命令形式表达出来。</p><p>为了触发行内内嵌数学符号的实时编译你需要：输入<code>$</code>然后按下<code>ESC</code>键之后输入TeX命令，之后就会弹出一个如图所示的工具提示栏：</p><p><a href="https://pic3.zhimg.com/v2-4033508b043cad96c59ec4edbca92f36_b.gif"><img src="https://pic3.zhimg.com/v2-4033508b043cad96c59ec4edbca92f36_b.gif" alt="img" /></a></p><h1 id="下标"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#3223758977">下标</a></h1><p>想要使用这个功能，需要在设置面板的 <code>Markdown</code> 栏启动它，之后使用<code>~</code>来修饰下标文本。栗如：</p><p><code>H~2~O</code> 和<code>X~long\ text~</code> 显示为 H2O 和Xlong text 。</p><h1 id="上标">上标</h1><p>想要使用这个功能，需要在设置面板的 <code>Markdown</code> 栏启动它，之后使用<code>^</code>来修饰下标文本。栗如：</p><p><code>X^2^</code> 显示为 X2 。</p><h1 id="高亮"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#3393569062">高亮</a></h1><p>想要使用这个功能，需要在设置面板的<code>Markdown</code> 栏启动它，之后使用<code>==</code>来修饰高亮文本，栗如：</p><p><code>==highlight==</code> 显示为 highlight 。</p><h1 id="markdown嵌套视频">Markdown嵌套视频</h1><video id="video" controls="" preload="none" poster="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=652322852,1290568523&fm=26&gp=0.jpg" style="box-sizing: border-box; display: inline-block; vertical-align: baseline; color: rgb(64, 64, 64); font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;Microsoft JhengHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, &quot;Noto Sans SC&quot;, &quot;Source Han Sans TC&quot;, &quot;Noto Sans CJK TC&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"><source id="mp4" src="http://vfx.mtime.cn/Video/2019/03/19/mp4/190319222227698228.mp4" type="video/mp4"></video><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">preload</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&quot;https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=652322852,1290568523&amp;fm=26&amp;gp=0.jpg&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mp4&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://vfx.mtime.cn/Video/2019/03/19/mp4/190319222227698228.mp4&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="简洁的写法">简洁的写法：</h2><iframe width="800" height="450" src="https://v.miaopai.com/iframe?scid=SvyHaHOczsp7B6ftW86oqMMz62-h5ai6~Fwp8A__" frameborder="0" allowfullscreen></iframe><iframe width="800" height="450" src="//player.bilibili.com/player.html?aid=584747363&amp;bvid=BV1Sz4y1Z7g9&amp;cid=237582291&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;800&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;450&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://v.miaopai.com/iframe?scid=SvyHaHOczsp7B6ftW86oqMMz62-h5ai6~Fwp8A__&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">allowfullscreen</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="markdown嵌套音频">Markdown嵌套音频</h1><audio id="audio" controls="" preload="none" style="box-sizing: border-box; display: inline-block; vertical-align: baseline; color: rgb(64, 64, 64); font-family: -apple-system, system-ui, &quot;Helvetica Neue&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, STHeiti, &quot;Microsoft YaHei&quot;, &quot;Microsoft JhengHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;Source Han Sans CN&quot;, &quot;Noto Sans SC&quot;, &quot;Source Han Sans TC&quot;, &quot;Noto Sans CJK TC&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"><source id="mp3" src="http://m10.music.126.net/20201212152151/1248b0f87abd9ad542b2377c9818d22a/ymusic/0758/550f/545f/028d3b9421be8425d60dc57735cf6ebc.mp3"></audio><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;audio&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">preload</span>=<span class="hljs-string">&quot;none&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;box-sizing: border-box; display: inline-block; vertical-align: baseline; color: rgb(64, 64, 64); font-family: -apple-system, system-ui, <span class="hljs-symbol">&amp;quot;</span>Helvetica Neue<span class="hljs-symbol">&amp;quot;</span>, Arial, <span class="hljs-symbol">&amp;quot;</span>PingFang SC<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Hiragino Sans GB<span class="hljs-symbol">&amp;quot;</span>, STHeiti, <span class="hljs-symbol">&amp;quot;</span>Microsoft YaHei<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Microsoft JhengHei<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Source Han Sans SC<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Noto Sans CJK SC<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Source Han Sans CN<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Noto Sans SC<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Source Han Sans TC<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>Noto Sans CJK TC<span class="hljs-symbol">&amp;quot;</span>, <span class="hljs-symbol">&amp;quot;</span>WenQuanYi Micro Hei<span class="hljs-symbol">&amp;quot;</span>, SimSun, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mp3&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://m10.music.126.net/20201212152151/1248b0f87abd9ad542b2377c9818d22a/ymusic/0758/550f/545f/028d3b9421be8425d60dc57735cf6ebc.mp3&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="简洁的写法-1">简洁的写法：</h2><audio id="audio" controls="" preload="none"><source id="mp3" src="http://m10.music.126.net/20201212152151/1248b0f87abd9ad542b2377c9818d22a/ymusic/0758/550f/545f/028d3b9421be8425d60dc57735cf6ebc.mp3"></audio><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;audio&quot;</span> <span class="hljs-attr">controls</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">preload</span>=<span class="hljs-string">&quot;none&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mp3&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://m10.music.126.net/20201212152151/1248b0f87abd9ad542b2377c9818d22a/ymusic/0758/550f/545f/028d3b9421be8425d60dc57735cf6ebc.mp3&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="嵌入pdf">嵌入PDF</h1><p>当然，PDF也不在话下，通过 <code>Google Drive Viewer</code> 即可嵌入PDF</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://docs.google.com/viewer?url=http://infolab.stanford.edu/pub/papers/google.pdf&amp;embedded=true&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:800px; height:500px;&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你会科学上网的话，那应该就可以成功在typorah中看到嵌入的PDF了:</p><iframe src="https://docs.google.com/viewer?url=http://infolab.stanford.edu/pub/papers/google.pdf&amp;embedded=true" style="width:800px; height:500px;" frameborder="0"></iframe><h1 id="参考"><a href="https://www.cnblogs.com/hongdada/p/9776547.html#3282563693">参考：</a></h1><p>https://baka943.coding.me/2018/02/08/2018-02-08-TyporaSimpleDoc/</p><p><a href="https://blog.csdn.net/vola9527/article/details/69948411">在markdown中使用HTML中的特殊符号：</a></p><p><a href="https://blog.csdn.net/full_speed_turbo/article/details/69951768">Markdown输入Latex公式的特殊符号</a></p><p><a href="https://zhuanlan.zhihu.com/p/39872673">Markdown For Typora 中文版使用指南</a></p><p><a href="https://www.zybuluo.com/codeep/note/163962">Cmd Markdown 公式指导手册</a></p><p><a href="https://bookdown.org/baydap/steemh/wzbjp.html">Markdown 简介</a></p><blockquote><p>作者：hongda</p><p>出处：https://www.cnblogs.com/hongdada/p/9776547.html</p><p>版权：本文采用「<a href="https://creativecommons.org/licenses/by/4.0">署名 4.0 国际</a>」知识共享许可协议进行许可。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Editor</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jmeter初级入门教程</title>
    <link href="/2017/08/20/2017-08-20-Jmeter%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2017/08/20/2017-08-20-Jmeter%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="创建一个简单的自动化脚本">创建一个简单的自动化脚本</h1><h2 id="创建线程组thread-group">创建线程组【Thread Group】:</h2><p>右击【TestPlan】选择【Add】——【Thread（Users）】——【Thread Group】</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDc5NjM2NC00MzQxNGM3MjZmZDdhY2E5LnBuZw?x-oss-process=image/format,png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="定义用户自定义的变量">定义用户自定义的变量：</h2><p>右击【Thread Group（线程组）】选择【Add】—【Config Element（配置元件）】—【User Defined Variables】</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDc5NjM2NC04YzQyMTJmZjU1MDM2MjZkLnBuZw?x-oss-process=image/format,png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDc5NjM2NC04OWZhNWY1ZDAxMmNmZGY5LnBuZw?x-oss-process=image/format,png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="创建http信息头管理器">创建HTTP信息头管理器：</h2><p>右击【Thread Group（线程组）】选择【Add】—【Config Element（配置元件）】—【HTTP Header Manager】</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDc5NjM2NC0yNjQyMThiMGNkN2M1OTcxLnBuZw?x-oss-process=image/format,png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDc5NjM2NC1kNDgyNDQxYmY5NjA2ZWJhLnBuZw?x-oss-process=image/format,png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="创建http-cookie-管理器">创建HTTP Cookie 管理器：</h2><p>右击【Thread Group（线程组）】选择【Add】—【Config Element（配置元件）】—【HTTP Cookie Manager】</p><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDc5NjM2NC02N2EzODgyYjQ3OGJjZGZiLnBuZw?x-oss-process=image/format,png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDc5NjM2NC0xMWFkY2VhY2NjZTUyOWIzLnBuZw?x-oss-process=image/format,png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（1）（Clear cookies each iteration?）<strong>每次反复清除Cookies？</strong>：选择后，则每次线程组运行时，都会清除 cookie。（若是手动添加的cookie，则不会被清除）</p><p>（2）<strong>Cookie Policy：</strong>Cookie的管理策略</p><ul><li><p>compatibility：推荐选择此种策略。这种兼容性设计要求是适应尽可能多的不同的服务器，尽管不是完全按照标准来实现的。如果你遇到了解析 Cookies 的问题，你就可能要用到这一个规范。有太多的web站点是用CGI脚本去实现的，而导致只有将所有的 Cookies 都放入 Request header 才可以正常的工作。这种情况下最好设置 http.protocol.single-cookie-header 参数为 true。</p></li><li><p>rfc2109：是HttpClient使用的默认Cookies协议。</p></li><li><p>rfc2965：定义了版本2并且尝试去弥补在版本1中 Cookie 的 RFC2109 标准的缺点。规定 RFC2965 最终取代 RFC2109 发送 RFC2965 标准 Cookies 的服务端，将会使用 Set-Cookie2 header 添加到 Set-Cookie Header 信心中，RFC2965 Cookies 是区分端口的。</p></li><li><p>ignorecookies：此规格忽略所有 Cookie。被用来防止 HttpClient 接受和发送的 Cookie。</p></li><li><p>netscape：是最原始的 Cookies 规范，同时也是 RFC2109 的基础。尽管如此，还是在很多重要的方面与 RFC2109 不同，可能需要特定服务器才可以兼容。</p></li><li><p>default：默认。</p></li><li><p>best-match：</p></li><li><p>standard：</p></li><li><p>standard-strict：</p></li></ul><h2 id="创建jdbc-connection-configuration">创建JDBC Connection Configuration：</h2><p>右击【Thread Group（线程组）】选择【Add】—【Config Element（配置元件）】—【JDBC Connection Configuration】</p><figure><img src="https://img-blog.csdnimg.cn/20200109111345488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109111505503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ol type="1"><li>Variable Name Bound to Pool</li></ol><ul><li><p>Variable Name，数据库连接池的变量名，之后JDBC request可以通过选择不同的连接池名来选择不同的数据库连接</p></li><li><p>Variable name变量名称:与JDBC Request的Variable name保持一致</p><p>原因：因为链接数据库是需要在JDBC Connection Configuration中配置好的，然后赋予一个变量名称，那么JDBC Request想要去访问数据库，就必须通过这个配置好的元件去链接，所以JDBC Reques就需要通过读取JDBC Connection Configuration的变量中的信息，那怎么读取呢，JDBC Reques就需要用到这个变量了，就需要到名称为mysql的元件中去应用。</p></li></ul><ol start="2" type="1"><li>Connection Pool Configuration</li></ol><ul><li><p>Max Number of Connections 该数据库连接池的最大连接数，一般可设置为0，意思是每个线程都使用单独的数据库连接，线程之间数据库连接不共享</p><p>中文：池中允许的最大连接数。在大多数情况下，将其设置为0，这意味着每个线程将得到它自己的池，其中只有一个连接，即线程之间不共享连接。如果您真的想要使用共享池(为什么?)，那么将max count与线程数相同，以确保线程不会相互等待。</p><p>原文：aximum number of connections allowed in the pool. In most cases, set this to zero (0) . This means that each thread will get its own pool with a single connection in it, i.e. the connections are not shared between threads. If you really want to use shared pooling (why?), then set the max count to the same as the number of threads to ensure threads don't wait on each other.</p></li><li><p>Max Wait (ms) 在连接池中取回连接最大等待时间</p><p>中文：如果在试图检索连接过程中（取回连接）超过所设置期限，连接池抛出一个错误</p><p>原文：ool throws an error if the timeout period is exceeded in the process of trying to retrieve a connection</p></li><li><p>Time Between Eviction Runs (ms) 疏散时间</p><p>中文：在空闲对象驱逐线程运行期间，可以休眠的毫秒数。当非正值时，将运行无空闲对象驱逐器线程。(默认为“60000”，1分钟)（如果当前连接池中某个连接在空闲了time Between Eviction Runs Millis时间后任然没有使用，则被物理性的关闭掉。） 原文：The number of milliseconds to sleep between runs of the idle object evictor thread. When non-positive, no idle object evictor thread will be run. (Defaults to " 60000 ", 1 minute)</p></li><li><p>Auto Commit 自动提交sql语句</p><p>中文：打开或关闭连接的自动提交。</p><p>原文：Turn auto commit on or off for the connections.</p></li><li><p>Transaction Isolation：</p><p>事务间隔级别设置，主要有如下几个选项：（对JMX加解密）</p><p>TRANSACTION_NODE 事务节点</p><p>TRANSACTION_READ_UNCOMMITTED 事务未提交读</p><p>TRANSACTION_READ_COMMITTED 事务已提交读</p><p>TRANSACTION_SERIALIZABLE 事务序列化</p><p>DEFAULT 默认</p><p>TRANSACTION_REPEATABLE_READ 事务重复读</p></li></ul><ol start="3" type="1"><li>Connection Validation by Pool</li></ol><p>这是Jmeter用来检验数据库连接是否有效的一种机制，超过5秒没有使用的话，就会用validation query去测试下这个连接是否有效</p><ul><li><p>Test While Idle 当空闲的时候测试连接是否断开</p><p>中文：测试连接池的空闲连接，验证查询将会被使用去测试。</p><p>原文：Test idle connections of the pool, see BasicDataSource.html#getTestWhileIdle . Validation Query will be used to test it.</p></li><li><p>Soft Min Evictable Idle Time(ms)</p><p>中文：最少的时间连接可能在池中闲置，然后才有资格被闲置的对象驱逐出去，额外的条件是至少在池中保持连接。默认值为5000(5秒)</p><p>原文：Minimum amount of time a connection may sit idle in the pool before it is eligible for eviction by the idle object evictor, with the extra condition that at least minIdle connections remain in the pool. See BasicDataSource.html#getSoftMinEvictableIdleTimeMillis . Defaults to 5000 (5 seconds)</p></li><li><p>Validation Query：验证查询，检验连接是否有效（数据库重启后之前的连接都失效，需要验证查询）</p></li></ul><ol start="4" type="1"><li>Database Connection Configuration</li></ol><p>Database URL: jdbc:mysql://服务器地址:3306/数据库名 （比如：jdbc:mysql://ip:3306/数据库名?useUnicode=true&amp;characterEncoding=utf8&amp;allowMultiQueries=true）</p><p>备注：“&amp;allowMultiQueries=true” 这句话的意思呢 是为了在JDBC中执行多条select语句的时候用的！</p><ul><li><p>JDBC Driver class:数据库JDBC驱动类名：com.mysql.jdbc.Driver</p></li><li><p>Username:数据库连接用户名</p></li><li><p>password:数据库连接密码</p></li></ul><p>不同数据库具体的填写方式，可以参考下面的表格：</p><table><thead><tr class="header"><th><strong>Datebase</strong></th><th><strong>Driver class</strong></th><th><strong>Database URL</strong></th></tr></thead><tbody><tr class="odd"><td>MySQL</td><td>com.mysql.jdbc.Driver</td><td>jdbc:mysql://host:port/{dbname}</td></tr><tr class="even"><td>PostgreSQL</td><td>org.postgresql.Driver</td><td>jdbc:postgresql:{dbname}</td></tr><tr class="odd"><td>Oracle</td><td>oracle.jdbc.driver.OracleDriver</td><td>jdbc:oracle:thin:user/pass@//host:port/service</td></tr><tr class="even"><td>Ingres (2006)</td><td>ingres.jdbc.IngresDriver</td><td>jdbc:ingres://host:port/db[;attr=value]</td></tr><tr class="odd"><td>MSSQL</td><td>com.microsoft.sqlserver.jdbc.SQLServerDriver或者net.sourceforge.jtds.jdbc.Driver</td><td>jdbc:sqlserver://IP:1433;databaseName=DBname或者jdbc:jtds:sqlserver://localhost:1433/"+"library"</td></tr></tbody></table><h2 id="创建jdbc-request">创建JDBC Request：</h2><p>右击【Thread Group（线程组）】选择【Add】—【Sampler（取样器）】—【JDBC Request】</p><figure><img src="https://img-blog.csdnimg.cn/202001091117267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/2020010911161666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109112714481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>重要的参数说明：</p><ul><li><p>Variable Name：数据库连接池的名字，需要与JDBC Connection Configuration的Variable Name Bound Pool名字保持一致</p></li><li><p>Query：填写的sql语句未尾不要加“;”</p></li><li><p>Parameter valus：参数值</p></li><li><p>Parameter types：参数类型，可参考：Javadoc for java.sql.Types</p></li><li><p>Variable names：保存sql语句返回结果的变量名</p></li><li><p>Result variable name：创建一个对象变量，保存所有返回的结果</p></li><li><p>Query timeout：查询超时时间</p></li><li><p>Handle result set：定义如何处理由callable statements语句返回的结果</p></li></ul><h2 id="创建http-request">创建HTTP Request：</h2><p>右击【Thread Group（线程组）】选择【Add】—【Sampler（取样器）】—【HTTP Request】</p><figure><img src="https://img-blog.csdnimg.cn/20200109120201145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/2020010912130878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（1）添加Bean Shell PreProcessor：选择右击【httprequest】—【add】—【preprocessors】前置处理器—【Bean Shell PreProcessor】</p><figure><img src="https://img-blog.csdnimg.cn/20200109122014193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/2020010912190643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（2）添加json提取器提取加密结果</p><figure><img src="https://img-blog.csdnimg.cn/20200109122237954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（3）添加Bean Shell PostProcessor：选择右击【httprequest】—【add】—【Post Processors】后置处理器—【Bean Shell PostProcessor】</p><figure><img src="https://img-blog.csdnimg.cn/20200109122412632.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109122336207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（4）添加json提取器提取Token结果</p><figure><img src="https://img-blog.csdnimg.cn/20200109122505144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（5）添加Bean Shell PostProcessor：选择右击【httprequest】—【add】—【Post Processors】后置处理器—【Bean Shell PostProcessor】</p><figure><img src="https://img-blog.csdnimg.cn/20200109122633565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（6）添加json提取器提取执行结果</p><figure><img src="https://img-blog.csdnimg.cn/2020010912272160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>（7）添加BeanShell Assertion（beanshell断言）：右击【httprequest】选择【Add】—【Assertions（断言）】—【BeanShell Assertion】</p><figure><img src="https://img-blog.csdnimg.cn/20200109123014124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109122804817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h1 id="个人中心登陆">个人中心登陆</h1><figure><img src="https://img-blog.csdnimg.cn/20200109124020627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109124052965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109124112211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109124135450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><img src="https://img-blog.csdnimg.cn/20200109124246919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dhb3h1ZXRlc3Q=,size_16,color_FFFFFF,t_70" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
