<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/profile.jpeg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Starry"><meta name="keywords" content=""><meta name="description" content="如何阅读 Java 字节码（Byte Code）"><meta property="og:type" content="article"><meta property="og:title" content="如何阅读 Java 字节码（Byte Code）"><meta property="og:url" content="https://www.blog.spphoto.top/2022/09/14/Java-Byte-Code/index.html"><meta property="og:site_name" content="champagne&#39;s vicissitude"><meta property="og:description" content="如何阅读 Java 字节码（Byte Code）"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/Blog/scenic_wxl.jpg"><meta property="article:published_time" content="2022-09-14T02:00:33.000Z"><meta property="article:modified_time" content="2022-11-05T02:44:43.670Z"><meta property="article:author" content="Champagne"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/Blog/scenic_wxl.jpg"><title>如何阅读 Java 字节码（Byte Code） - champagne&#39;s vicissitude</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3619942_p0ons582io9.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/daziyanse.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"www.blog.spphoto.top",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Starry</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> Archives</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/Repositories/"><i class="iconfont icon-github-fill"></i> Repositories</a></li><li class="nav-item"><a class="nav-link" href="/gallery/"><i class="iconfont icon-image"></i> Galleries</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/Blog/114323.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="如何阅读 Java 字节码（Byte Code）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-09-14 10:00" pubdate>September 14, 2022 am</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.7k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 73 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">如何阅读 Java 字节码（Byte Code）</h1><div class="markdown-body"><h1 id="字节码byte-code">字节码（Byte Code）</h1><p>学习 Java 的都知道，我们所编写的 <code>.java</code> 代码文件通过编译将会生成 <code>.class</code> 文件，最初的方式就是通过 JDK 的 <code>javac</code> 指令来编译，再通过 <code>java</code> 命令执行 main 方法所在的类，从而执行我们的 Java 程序。而在这中间所生成的 .class 文件中的内容，就是 JVM 可以处理运行的字节码（Byte Code），它由 JVM 解释为对应系统可运行的机器指令，这也是我们的 Java 程序能够做到一处编译处处执行的原理。</p><p>对于 Java 开发人员来说，平时需要阅读 Byte Code 的场景比较少，但和阅读框架源码能够了解到框架的设计思路一样，阅读 Java Byte Code 也有利于我们理解 Java 一些深层的东西，提高我们解决问题的能力。能够阅读 Byte Code 也有利于我们去理解 Kotlin 或其它运行在 JVM 上的语言，是如何扩展 Java 所没有的特性或语法糖。</p><h1 id="字节码文件结构">字节码文件结构</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> add(a, b);<br>        System.out.println(c);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们先编写一个简单的 Java 代码作为演示例子，然后编译这个 Hello.java 文件得到 Hello.class 文件。我们知道 .class 是二进制文件，它无法被直接查看，当然我们可以通过一些二进制文件查看工具来阅读里面的内容。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8dea7c42a8e491098dfce263479c38d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="（在 Visual Studio Code 里使用 hexdump for VSCode 插件查看到的内容）"><figcaption aria-hidden="true">（在 Visual Studio Code 里使用 hexdump for VSCode 插件查看到的内容）</figcaption></figure><p>一个符合标准的 <code>.class</code> 文件是以 <code>CA FE BA BE</code> 开头，这个四个字节均为魔数，JVM 根据这个开头来判断一个文件是否可能为 <code>.class</code> 文件，如果是才会继续执行。</p><p>魔数后面四个字节 <code>00 00 00 34</code> 是版本号，前两个字节为次版本号，后两个字节为主版本号，在对主版本号进行转换可以得到 52，该序号对应的 Java 版本为 1.8。</p><p>如果需要查阅最新的 Java 版本对应的版本号，可以在官方查看 Java SE 最新版本的文档</p><blockquote><p>Oracle Java SE Specifications：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Findex.html">docs.oracle.com/javase/spec…</a></p></blockquote><p>在版本号后面则是常量池，它包含常量池计数器（constant_pool_count）和常量池数据区两个部分。前面两个字节 00 28 是计数器，用于表示常量池的容量计数值，代表常量池数据区有 <code>constant_pool_count - 1</code> 个常量。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/662392269d41446ea26919114d18ae33~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="常量池结构"><figcaption aria-hidden="true">常量池结构</figcaption></figure><p>在常量池后面还有访问标志，很显然这个文件对于我们来说阅读起来并不方便，但是我们可以转换为助记符来帮助我们阅读。</p><h2 id="使用-javap-命令">使用 javap 命令</h2><p>当我们拥有一个 <code>.class</code> 文件时，我们可以通过 <code>javap</code> 来将字节码指令转换为助记符，这个命令有一些参数，你可以通过 <code>javap -help</code> 来查看所有参数的说明，这里为了显示尽量详细的内容，使用 <code>javap -verbose Hello</code>，其效果如下，但由于内容太长，我们不一次性展示所有内容，而是分区域来进行阅读。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Classfile /F:/project/java/JavaMain/<span class="hljs-keyword">out</span>/production/JavaMain/Hello.<span class="hljs-keyword">class</span><br>  Last modified <span class="hljs-number">2021</span><span class="hljs-number">-3</span><span class="hljs-number">-26</span>; size <span class="hljs-number">645</span> bytes<br>  MD5 checksum ca1b2193159aece89c05c7f9d3b54c7b<br>  Compiled <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;Hello.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span><br>  <span class="hljs-title">minor</span> <span class="hljs-title">version</span>: 0<br>  <span class="hljs-title">major</span> <span class="hljs-title">version</span>: 52<br>  <span class="hljs-title">flags</span>: <span class="hljs-title">ACC_PUBLIC</span>, <span class="hljs-title">ACC_SUPER</span><br></code></pre></td></tr></table></figure><p>最开始几行是关于这个文件的基本信息，之后是类的信息，我们的关注点从类这里开始。</p><p>在类里面，它包含了主版本号（major version），次版本号（minor version），访问标志（flags）。</p><p>对于版本号，和我们上面所讲的一样，因此这里不再重复。而 flags 是关于这个类的相关修饰符，根据官方文档，它可能拥有的值如下：</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ed8c7325c495469da2d0b0e382ab1903~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h2 id="常量池">常量池</h2><p>在类信息的下面，则是常量池，它类似一个表，每个常量由编号、类型、值，这 3 个部分组成。我们列出一小部分来了解它的结构。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Constant</span> <span class="hljs-selector-tag">pool</span>:<br>   <span class="hljs-selector-id">#1</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#6</span>.<span class="hljs-selector-id">#26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   <span class="hljs-selector-id">#2</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#5</span>.<span class="hljs-selector-id">#27</span>         <span class="hljs-comment">// Hello.add:(II)I</span><br>   <span class="hljs-selector-id">#3</span> = <span class="hljs-selector-tag">Fieldref</span>           <span class="hljs-selector-id">#28</span>.<span class="hljs-selector-id">#29</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   <span class="hljs-selector-id">#4</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#30</span>.<span class="hljs-selector-id">#31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   <span class="hljs-selector-id">#5</span> = <span class="hljs-selector-tag">Class</span>              <span class="hljs-selector-id">#32</span>            <span class="hljs-comment">// Hello</span><br>   <span class="hljs-selector-id">#6</span> = <span class="hljs-selector-tag">Class</span>              <span class="hljs-selector-id">#33</span>            <span class="hljs-comment">// java/lang/Object</span><br>   <span class="hljs-selector-id">#7</span> = <span class="hljs-selector-tag">Utf8</span>               &lt;<span class="hljs-selector-tag">init</span>&gt;<br>   <span class="hljs-selector-id">#8</span> = <span class="hljs-selector-tag">Utf8</span>               ()<span class="hljs-selector-tag">V</span><br>   <span class="hljs-selector-id">#9</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">Code</span><br>  <span class="hljs-selector-id">#10</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">LineNumberTable</span><br>  <span class="hljs-selector-id">#11</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">LocalVariableTable</span><br>  <span class="hljs-selector-id">#12</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">this</span><br>  <span class="hljs-selector-id">#13</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">LHello</span>;<br>  <span class="hljs-selector-id">#14</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">main</span><br>  <span class="hljs-selector-id">#15</span> = <span class="hljs-selector-tag">Utf8</span>               ([Ljava/lang/String;)<span class="hljs-selector-tag">V</span><br></code></pre></td></tr></table></figure><p>在这里列出了前 15 个常量，每个常量都有一个编号，编号以符号 <code>#</code> 开头，编号后面是 <code>=</code> 加上该常量的类型，具体类型说明请参考官方 jvms 文档的 The Constant Pool 的解释。这里我们从中挑选几个常量来进行说明。</p><p>由于我们使用的命令是 <code>javap -verbose</code> 因此它会给我们加上一些注释说明，我们可以看到 <code>#2</code> 常量后面的注释是 <code>Hello.add:(II)I</code>，那么我们可以猜测它应该是我们代码中所编写的 <code>add()</code> 方法，由于这个方法是静态，因此它被加入到这个类中的常量区。那么这个常量的值呢？</p><p>对于 Methodref 类型，它的值是该方法的名称，对于一个方法而言，它的名称是一个字符串，因此构成方法名称的字符串也会被添加到常量池中，<code>#2</code> 这个方法，它的名称引用了常量池中其它的两个常量，也就是 <code>#5</code> 和 <code>#27</code>，而这两个常量以及与它们相关的其它常量在常量池中的值如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"> <span class="hljs-selector-id">#2</span> = <span class="hljs-selector-tag">Methodref</span>          <span class="hljs-selector-id">#5</span>.<span class="hljs-selector-id">#27</span>         <span class="hljs-comment">// Hello.add:(II)I</span><br> <span class="hljs-selector-id">#5</span> = <span class="hljs-selector-tag">Class</span>              <span class="hljs-selector-id">#32</span>            <span class="hljs-comment">// Hello</span><br><span class="hljs-selector-id">#22</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">add</span><br><span class="hljs-selector-id">#23</span> = <span class="hljs-selector-tag">Utf8</span>               (II)<span class="hljs-selector-tag">I</span><br><span class="hljs-selector-id">#27</span> = <span class="hljs-selector-tag">NameAndType</span>        <span class="hljs-selector-id">#22</span>:<span class="hljs-selector-id">#23</span>        <span class="hljs-comment">// add:(II)I</span><br><span class="hljs-selector-id">#32</span> = <span class="hljs-selector-tag">Utf8</span>               <span class="hljs-selector-tag">Hello</span><br></code></pre></td></tr></table></figure><p>在常量池中我们可以看到，<code>#5</code> 是一个类，它的值和方法一样都是名称，因此它引用了常量 #32，对于 <code>Utf8</code> 类型的常量，其值则是一个字符串，也就是常量 <code>#32</code> 的值就是字符串 <em>Hello</em>。因此 <code>#5</code> 的值就是 <em>Hello</em>。同样的 <code>#27</code> 的值是 <code>add:(II)I</code>，将它们组合起来 <code>#2</code> 的值就是 <code>Hello.add:(II)I</code> 了。</p><h2 id="包含的方法">包含的方法</h2><p>与 Java 代码一样，我们所定义的方法在类里面，而在字节码中我们定义在类中的方法也放在大括号里面，而这个大括号就在常量池下方。</p><p>对于每个方法，都包含首行的声明，以及紧接在后面的 descriptor（描述符号），flags（访问标识），Code（代码），我们把 Code 部分的内容先省略，先看一下类中所拥有的所有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hello</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      <span class="hljs-comment">// 省略</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;<br>    descriptor: (II)I<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      <span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们并没有给类写构造方法，但这里却生成了 <code>public Hello();</code>，这也说明了为什么我们在 Java 中不给类写构造方法，默认会有一个无参的构造方法。</p><p>另外我们可以看到到 <code>add(int, int)</code> 方法的 descriptor 为 <code>(II)I</code>，这与我们上面观察常量池时 <code>Hello.add:(II)I</code> 冒号后面带的字符是一样的，这其实是这个方法的参数以及返回值的缩写。当我们在 Java 中编写重载方法时，由于方法名一样，JVM 可以通过 descriptor 来区分所调用的方法是哪一个。</p><p>而 flags 与 Class 的 flags 类似，用于声明方法所拥有的修饰符。而最后的 Code 中包含的则是该方法的代码所执行的指令。</p><h2 id="code-的结构">Code 的结构</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">public</span> <span class="hljs-string">static</span> <span class="hljs-string">void</span> <span class="hljs-string">main(java.lang.String[]);</span><br>  <span class="hljs-attr">descriptor:</span> <span class="hljs-string">([Ljava/lang/String;)V</span><br>  <span class="hljs-attr">flags:</span> <span class="hljs-string">ACC_PUBLIC,</span> <span class="hljs-string">ACC_STATIC</span><br>  <span class="hljs-attr">Code:</span><br>    <span class="hljs-string">stack=2,</span> <span class="hljs-string">locals=4,</span> <span class="hljs-string">args_size=1</span><br>       <span class="hljs-attr">0:</span> <span class="hljs-string">iconst_1</span><br>       <span class="hljs-attr">1:</span> <span class="hljs-string">istore_1</span><br>       <span class="hljs-attr">2:</span> <span class="hljs-string">iconst_1</span><br>       <span class="hljs-attr">3:</span> <span class="hljs-string">istore_2</span><br>       <span class="hljs-attr">4:</span> <span class="hljs-string">iload_1</span><br>       <span class="hljs-attr">5:</span> <span class="hljs-string">iload_2</span><br>       <span class="hljs-attr">6:</span> <span class="hljs-string">invokestatic</span>  <span class="hljs-comment">#2                  // Method add:(II)I</span><br>       <span class="hljs-attr">9:</span> <span class="hljs-string">istore_3</span><br>      <span class="hljs-attr">10:</span> <span class="hljs-string">getstatic</span>     <span class="hljs-comment">#3                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br>      <span class="hljs-attr">13:</span> <span class="hljs-string">iload_3</span><br>      <span class="hljs-attr">14:</span> <span class="hljs-string">invokevirtual</span> <span class="hljs-comment">#4                  // Method java/io/PrintStream.println:(I)V</span><br>      <span class="hljs-attr">17:</span> <span class="hljs-string">return</span><br>    <span class="hljs-attr">LineNumberTable:</span><br>      <span class="hljs-attr">line 3:</span> <span class="hljs-number">0</span><br>      <span class="hljs-attr">line 4:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">line 5:</span> <span class="hljs-number">4</span><br>      <span class="hljs-attr">line 6:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">line 7:</span> <span class="hljs-number">17</span><br>    <span class="hljs-attr">LocalVariableTable:</span><br>      <span class="hljs-string">Start</span>  <span class="hljs-string">Length</span>  <span class="hljs-string">Slot</span>  <span class="hljs-string">Name</span>   <span class="hljs-string">Signature</span><br>          <span class="hljs-number">0</span>      <span class="hljs-number">18</span>     <span class="hljs-number">0</span>  <span class="hljs-string">args</span>   [<span class="hljs-string">Ljava/lang/String;</span><br>          <span class="hljs-number">2</span>      <span class="hljs-number">16</span>     <span class="hljs-number">1</span>     <span class="hljs-string">a</span>   <span class="hljs-string">I</span><br>          <span class="hljs-number">4</span>      <span class="hljs-number">14</span>     <span class="hljs-number">2</span>     <span class="hljs-string">b</span>   <span class="hljs-string">I</span><br>         <span class="hljs-number">10</span>       <span class="hljs-number">8</span>     <span class="hljs-number">3</span>     <span class="hljs-string">c</span>   <span class="hljs-string">I</span><br></code></pre></td></tr></table></figure><p>以 main 方法为例子，在 Code 中可以分为 3 个部分，第一个部分是代码的指令表，该部分第一行是该方法的指令以及执行过程的相关信息，这一行信息包括：</p><ul><li>args_size 是参数数量，在主函数中，因为有 args 这个参数，所以在这里 args_size 为 1；</li><li>locals 是该方法中的本地变量有多少个，在我们的主函数里面有定义了 3 个变量，加上一个参数，因此有 4 个变量；</li><li>stack 是方法在执行过程中，操作数栈中最大深度，这个在之后讲解指令执行过程时可以看出。</li></ul><p>在这一行信息之后是字节码指令，一条指令包括偏移量以及执行的指令码，PC Register 利用偏移量来判断指令执行位置。</p><p>第二部分是 LineNumberTable，它是一个代码行对照表，用于标识我们 Java 代码中对应的行数的代码在 Code 中从哪个位置开始。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">LineNumberTable:</span><br>  <span class="hljs-attr">line 3:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">line 4:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">line 5:</span> <span class="hljs-number">4</span><br>  <span class="hljs-attr">line 6:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">line 7:</span> <span class="hljs-number">17</span><br></code></pre></td></tr></table></figure><p><code>line 3: 0</code> 代表 Java 源码文件中的第三行代码从偏移量为 0 的位置开始，而继续往下看可以看到第四行代码从偏移量为 2 的位置开始，也就是说第三行代码所对应的字节码指令有 <code>iconst_1</code> 和 <code>istore_1</code> 两条。这也可以让 JVM 执行指令出现错误时，帮助我们定位到对应的源码位置。</p><p>第三部分为 LocalVariableTable，调试器可以使用它在方法执行的过程中确定局部变量的值，它是一个可选的属性，在程序执行的时候并不需要它。</p><ul><li>第一个属性 start 为这个变量可见的起始偏移位置，它的值必须是在 Code 中存在的偏移量值。</li><li>第二个属性 length 为该变量的有效长度，在这个例子中，我们的变量直到方法末尾都有效，因此你会发现 <code>start + lenth</code> 的值都是 18 （方法中执行的指令数）。当我们在一个局部的代码块里面声明一个变量，那么它的有效期长度将会更短。</li><li>Slot 为变量在 local variable 中的位置，这可以帮助我们在指令中确定对应的变量，而 Name 则是变量名，Signature 为该变量的类型。</li></ul><p>当我们初步了解了 Code 属性的格式后，我们就可以对其中的指令执行进行分析了，但在此之前，我们需要先有一点 JVM 内存布局的基础知识，这对于我们之后了解指令的执行过程非常重要。</p><h1 id="jvm-内存结构">JVM 内存结构</h1><p>我们的 Java 程序在运行时是通过 <code>main()</code> 方法启动，它是程序的入口，我们的进程在启动时会为该方法创建一个主线程来执行代码。当我们使用多线程时，那么程序的进程将会拥有多个线程。每个线程的资源都拥有独自的资源，当然它们也可以共享进程的资源，那么在 JVM 中，根据资源的可用范围，可将内存区域分为线程独占和线程共享两个类别。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592d930aadd94e0a947fb844f97b8727~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="JVM内存布局"><figcaption aria-hidden="true">JVM内存布局</figcaption></figure><p>对于每一个线程，都可将其拥有的内存空间分为 PC Register、Native Method Stack、JVM Stack 这 3 个区域，这 3 个区域对于线程来说都是独占的，其它线程无法进行访问。</p><ul><li><strong>PC Register</strong> 用于记录当前线程指令的执行位置。由于一个进程可能有多个线程，而 CPU 会在不同线程之间切换，为了能够记录各个线程的当前执行的指令，每个线程都需要有一个 PC Register，来保证各个线程都可以进行独立运算。</li><li><strong>JVM Stack</strong> 用于存放调用方法时压入栈的栈帧。相信学过数据结构的对栈应该不陌生，JVM Stack 压入的单位为栈帧（Frame），用于存储数据、动态链接、方法返回值和调度异常等。每次调用一个方法都会创建一个新的栈帧压入 JVM Stack 来存储该方法的信息，当该方法调用完成时，对应的栈帧也会跟着被销毁。一个栈帧都有自己的局部变量数组、操作数栈、对当前方法类的运行常量池的引用。</li><li><strong>Native Method Stack</strong> 则是用于调用操作系统本地方法时使用的栈空间。</li></ul><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f55b35eb303f476c960a3d375a3a3965~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="JVM Stack 结构"><figcaption aria-hidden="true">JVM Stack 结构</figcaption></figure><p>每个线程都可用访问的内存空间为线程共享区域，它包含 Head 和 Method Area 两个部分，Head 用于存放实例对象，也是 GC 回收的主要区域，而 Method Area 用于存放类结构与静态变量。</p><p>现在我们初步了解了 JVM 内存的布局，那么接下来可以继续看指令的执行过程了。</p><h1 id="指令的执行过程">指令的执行过程</h1><p>由于 Java 程序从 <code>main()</code> 方法开始，我们也是从这个方法的指令开始进行分析。</p><p>假设程序运行 0 号指令前的状态如下，在 mian 方法栈帧里面，有着 operand stack（操作数栈），它的最大长度为 2（与 Code 下的 stack 的值一致），此外还有一个 local variable（本地变量表）来存放变量的值，其中下标为 0 的变量为主方法的参数 args，我们直接用这个字符串填充在那里来做一个标识（实际的值可能是一个空数组）。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56b46e0ada1147858d65b84bfa68c071~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>接下来我们一步步执行方法中的指令，在这里我们先对出现的几个指令做一个简单的介绍：</p><ul><li><code>iconst_&lt;i&gt;</code> 放一个 int 常量（-1, 0, 1, 2, 3, 4 or 5) 到 operand stack 中</li><li><code>istore_&lt;n&gt;</code> 从 operand stack 中获取一个 int 到 local variable 的 n 中</li><li><code>iload_&lt;n&gt;</code> 从 local variable 中读取 int 变量 n 的值到操作数栈中</li><li><code>invokestatic</code> 调用一个 class 的 static 方法</li><li><code>getstatic</code> 从 class 中获取一个 static 字段</li><li><code>invokevirtual</code> 调用一个实例方法，基于类的调度</li><li><code>return</code> 从方法中返回一个 void，<code>ireturn</code> 从方法中返回 operand stack 栈顶的 int</li></ul><p><em>更多的指令与详细的说明请查看文章最后参考中的官方指令文档</em></p><p>现在我们开始分析指令的执行，我们在上面知道了，我们的 Java 代码所对应的指令分别是偏移量为 0 和 1 的两个，最开始执行的是 <code>0: iconst_1</code>，该指令会把 int 常量 1 放置到 operand stack 中，之后执行的是 <code>1: istore_1</code>，把 operand stack 栈顶的 int 常量取出放到 local variable 下标为 1 的变量中，该过程图示如下。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0716730b1a0e4897a8f345f11df12cc3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="iconst_1 与 istore_1 的执行过程"><figcaption aria-hidden="true">iconst_1 与 istore_1 的执行过程</figcaption></figure><p>我们可以通过查看 LocalVariableTable 得知下标为 1 的变量在我们的 Java 程序中是 int 变量 a，因此上面这两条指令常量 1 赋值给变量 a。同样的，后面两条指令则是将常量 1 赋值给变量 b。这里要注意，操作数栈的数是被取出操作，被取出的数将不会继续在 operand stack 里面。</p><p>执行完 0~3 这 4 条指令后，就来到了本例中最为关键的方法调用了。在执行 <code>iload_1</code> 和 <code>iload_2</code> 后，operand stack 中将会存放着变量 a 和 b 的值，作为 <code>invokestatic</code> 调用函数时传入的参数。</p><p>而执行到 <code>invokestatic #2</code> 这个指令的时候，该指令为调用一个 class 的 static 方法，也就是调用常量池中 <code>#2</code> 的方法，该方法为 <code>Hello.add:(II)I</code>。</p><p>当执行 invokestatic 时会依次读取 operand stack 的数据作为方法的参数，并创建一个新的栈帧来执行方法，将数据放到 local variable 对应变量位置。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59adc8ee20d0400f807836a7a52e6249~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>之后开始执行 <code>add()</code> 方法中的指令，首先执行的是两个 <code>iload</code> 指令，将 loca variable 对应下标的变量的值放到 operand stack 中，之后执行 <code>iadd</code> 取出 operand stack 中的值并进行加法运算，再把结果放到，最后执行 ireturn 取出 operand stack 顶部的 int 值进行返回。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8bcf3779bc3430ba736dd17b0e29f5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="执行了两个 iload 指令"><figcaption aria-hidden="true">执行了两个 iload 指令</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f5dd7d4698594e98bea8b4f1f7949400~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="执行 iadd 指令"><figcaption aria-hidden="true">执行 iadd 指令</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bee9441a876f419aa1a006cc7d20f3c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="ireturn 取出栈顶的 int 常量作为方法的返回值"><figcaption aria-hidden="true">ireturn 取出栈顶的 int 常量作为方法的返回值</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e753288ac6e4a1ebc18e9f18a684b7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="执行 istore_3"><figcaption aria-hidden="true">执行 istore_3</figcaption></figure><p>当执行完 <code>ireturn</code> 后，add 方法也就执行完成了，对应的栈帧也会跟着销毁。之后回到 main 方法中继续往下执行，到 <code>istore_3</code> 指令，该指令将栈顶的 int 值取出放到了 local variable 中 Solt 为 3 的地方，这样执行完 4~9 这几条指令后就完成了我们代码中的 <code>int c = add(a, b);</code> 这一行代码。那么接下来就是执行 <code>System.out.println(c);</code> 对应的指令将 2 打印到控制台了。</p><p>到这里其实我们就已经知道如何去阅读我们代码生成的 Byte Code 了，这里我就不继续往下分析本文例子的代码了，阅读过程中如果遇到了没见过的指令，我们可以在 Oracle 官方指令文档里面查阅对应的说明。</p><p>那可能有人会觉得，如果每次查看一个类都需要去 command line 执行 <code>javap</code> 来查看对应的助记符，这样非常麻烦呀。那么接下来我们讲一下如何在 IntelliJ IDEA 里面直接阅读 Byte Code。</p><h1 id="在-intellij-idea-阅读">在 IntelliJ IDEA 阅读</h1><p>如果你希望在 IntelliJ IDEA 里阅读 Byte Code，那么可以按照 <strong>Bytecode Viewer</strong> 这一个插件，只需要在 Plugins 里面查找就能找到。</p><p>安装完这个插件，在顶部菜单栏的 View 中将会多出一个 Show Bytecode 按钮选项，我们可以在对应的 <code>.java</code> 文件中点击 View -&gt; Show Bytecode，展示出该文件的 Byte Code。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b63f89e92e44356aecaa751ba26bcb6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="View -&gt; Show Bytecode"><figcaption aria-hidden="true">View -&gt; Show Bytecode</figcaption></figure><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ff2c64b7ce24747a709434ccd0260f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>在这里所展示的 Byte Code 格式与我们上面使用 <code>javap</code> 显示出来的不一样。首先在这里我们看不到常量池，因此在指令里也不会用引用的方式来表示常量池的内容。</p><p>在这里它会将每一行 Java 代码的指令都区分开。例如 main 方法中的第一行指令对应的就是 L0 那一块，第一行的 LINENUMBER 对应上面 <code>javap</code> 中的 LineNumberTable，直接在这里描述当前 L0 这一块的指令对应的代码在文件中的位置。也因此我们不会在生成的这个 Byte Code 里面看到 LineNumberTable，因为它直接分布在各个指令块中了。</p><figure><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/485654e735254ab7aef5432bd118a604~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="main 方法中的 L5"><figcaption aria-hidden="true">main 方法中的 L5</figcaption></figure><p>在方法的最后，会多出一块内容来描述方法的信息，在这里会将 LocalVariableTable 里的变量都列出来，但格式与 javap 的 LocalVariableTable 中的描述格式不一样，每一行 LOCALVARIABLE 代表一个变量，描述格式从左到右依次为变量名、类型、开始可见时的指令块、最后有效的位置、Solt。除了描述方法中出现的变量外，操作数栈最大深度和本地变量个数也在放在这里。</p><p>由于该插件主要是为了阅读 Byte Code 中的指令，因此是以一种更加方便阅读指令的方式展示 Byte Code，例如对指令根据源码做分块，并把对应代码行数放在指令块的第一行，这样我们就不需要去对照 LineNumberTable 寻找当前指令的代码所在的位置了，反过来由于进行了分块查询对应代码的指令也很方便。但这个插件显示的内容也少了很多东西，如果需要查看初始常量池的内容，那就需要使用 <code>javap</code> 了。</p><h1 id="参考">参考</h1><ul><li>字节码增强技术探索：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftech.meituan.com%2F2019%2F09%2F05%2Fjava-bytecode-enhancement.html">tech.meituan.com/2019/09/05/…</a></li><li>一文看懂 JVM 内存布局及 GC 原理：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.infoq.cn%2Farticle%2F3wyretkqrhivtw4frmr3">www.infoq.cn/article/3wy…</a></li><li>Oracle 官方说明文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse16%2Fhtml%2Fjvms-4.html%23jvms-4.10">docs.oracle.com/javase/spec…</a></li><li>Oracle 官方指令文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2Fspecs%2Fjvms%2Fse16%2Fhtml%2Fjvms-6.html">docs.oracle.com/javase/spec…</a></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/">#Java</a></div></div><div class="license-box my-3"><div class="license-title"><div>如何阅读 Java 字节码（Byte Code）</div><div>https://www.blog.spphoto.top/2022/09/14/Java-Byte-Code/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>Starry</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>September 14, 2022</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/09/14/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" title="Cache的基本原理"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Cache的基本原理</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2022/09/06/SpringBoot%E6%8E%A5%E6%94%B6%E5%89%8D%E7%AB%AF%E4%BC%A0%E6%9D%A5%E7%9A%84json%E6%95%B0%E6%8D%AE/" title="SpringBoot接收前端传来的json数据"><span class="hidden-mobile">SpringBoot接收前端传来的json数据</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config=function(){this.page.url="https://www.blog.spphoto.top/2022/09/14/Java-Byte-Code/",this.page.identifier="/2022/09/14/Java-Byte-Code/"};Fluid.utils.loadComments("#disqus_thread",(function(){var t=document,e=t.createElement("script");e.src="//fluid.disqus.com/embed.js",e.setAttribute("data-timestamp",new Date),(t.head||t.body).appendChild(e)}))</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">京ICP证123456号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"> <span>京公网安备12345678号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/qipao.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/jingtaisidai.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiantiao.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/timeDate.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>