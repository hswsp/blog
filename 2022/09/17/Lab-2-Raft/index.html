<!DOCTYPE html><html lang="en" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/profile.jpeg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Starry"><meta name="keywords" content=""><meta name="description" content="MIT 6.824 Lab 2 - Raft"><meta property="og:type" content="article"><meta property="og:title" content="6.824 Lab 2 - Raft"><meta property="og:url" content="https://umnchampagne.top/2022/09/17/Lab-2-Raft/index.html"><meta property="og:site_name" content="champagne&#39;s vicissitude"><meta property="og:description" content="MIT 6.824 Lab 2 - Raft"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://files.speakerdeck.com/presentations/0c645191e52f4c9fa82cb73fbff0b889/slide_24.jpg"><meta property="article:published_time" content="2022-09-17T13:35:48.000Z"><meta property="article:modified_time" content="2022-10-30T02:44:34.144Z"><meta property="article:author" content="Champagne"><meta property="article:tag" content="Distributed"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://files.speakerdeck.com/presentations/0c645191e52f4c9fa82cb73fbff0b889/slide_24.jpg"><title>6.824 Lab 2 - Raft - champagne&#39;s vicissitude</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3619942_p0ons582io9.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/toubudaziji.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/daziyanse.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/gundongtiao.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"umnchampagne.top",root:"/",version:"1.9.2",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Starry</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> Home</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> Archives</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> Categories</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> Tags</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> About</a></li><li class="nav-item"><a class="nav-link" href="/Repositories/"><i class="iconfont icon-github-fill"></i> Repositories</a></li><li class="nav-item"><a class="nav-link" href="/gallery/"><i class="iconfont icon-image"></i> Galleries</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> Links</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://files.speakerdeck.com/presentations/0c645191e52f4c9fa82cb73fbff0b889/slide_24.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="6.824 Lab 2 - Raft"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-09-17 21:35" pubdate>September 17, 2022 pm</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 40k words </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 334 mins</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">6.824 Lab 2 - Raft</h1><div class="markdown-body"><blockquote><p><strong>The source code of this Lab is <a target="_blank" rel="noopener" href="https://github.com/hswsp/MIT-6.824/tree/main/Lab%202-Raft">Here</a></strong></p></blockquote><h1 id="background">Background</h1><p>Consensus algorithms are vital in large-scale, fault-tolerant systems because they enable a set of distributed/replicated machines or servers to work as a coherent group and agree on system state, even in the presence of failures or outages.</p><figure><img src="https://cdn.ttgtmedia.com/rms/onlineImages/networking-distributed_computing.jpg" srcset="/img/loading.gif" lazyload alt="Consensus algorithms are important in distributed computing systems."><figcaption aria-hidden="true">Consensus algorithms are important in distributed computing systems.</figcaption></figure><p>There are basically two types of consensus algorithms:</p><ul><li>Byzantine Fault Tolerance Consensus Algorithm</li><li>Non-byzantine Fault Tolerance Consensus Algorithm</li></ul><p><strong>Byzantine Fault Tolerance</strong>(BFT) is the feature of a distributed network to reach consensus(agreement on the same value) even when some of the nodes in the network fail to respond or respond with incorrect information. The objective of a BFT mechanism is to safeguard against the system failures by employing collective decision making(both – correct and faulty nodes) which aims to reduce to influence of the faulty nodes. BFT is derived from Byzantine Generals’ Problem.</p><p>The Byzantine Generals Problem is a game theory problem, which describes the difficulty decentralized parties have in arriving at consensus without relying on a trusted central party. Only decentralized systems face the Byzantine Generals problem, as they have no reliable source of information and no way of verifying the information they receive from other members of the network. The problem was explained aptly in <a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/pubs/byz.pdf">a paper by LESLIE LAMPORT, ROBERT SHOSTAK, and MARSHALL PEASE at Microsoft Research in 1982</a>.</p><figure><img src="https://river.com/learn/images/articles/byzantine-generals-problem.png" srcset="/img/loading.gif" lazyload alt="byzantine-generals-problem"><figcaption aria-hidden="true">byzantine-generals-problem</figcaption></figure><p>So what I want to emphasize is that the Byzantine Generals problem describes the most difficult and complex distributed fault scenario. In addition to faulty behavior, there is also a scenario of malicious behavior. In the presence of malicious node behavior (such as in the blockchain technology of digital currencies), we must apply <strong>Byzantine Fault Tolerance</strong>.</p><p>Leslie Lamport constructed two solutions to the Byzantine Generals Problem:</p><ul><li>A SOLUTION WITH ORAL MESSAGES</li><li>A SOLUTION WITH SIGNED MESSAGES</li></ul><p>Besides, other commonly used BFT includes:</p><ul><li>PBFT(practical Byzantine Fault Tolerance)</li><li>PoW(Proof-of-Work).</li></ul><p>While in a distributed computing system, the most commonly used non-Byzantine fault-tolerant algorithm is <strong>Crash Fault Tolerance</strong> (CFT). CFT solves the consensus problem in the scenario where there is a fault in the distributed system, but no malicious node.</p><p>The commonly used CFT includes:</p><ul><li><p><a target="_blank" rel="noopener" href="https://martinfowler.com/articles/patterns-of-distributed-systems/paxos.html">Paxos algorithm</a></p></li><li><p>Multi-Paxos</p></li><li><p><a target="_blank" rel="noopener" href="https://marcoserafini.github.io/papers/zab.pdf">Zab protocol</a></p></li><li><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Gossip_protocol#:~:text=A%20gossip%20protocol%20or%20epidemic,all%20members%20of%20a%20group.">gossip protocol</a></p></li><li><p><a target="_blank" rel="noopener" href="https://blog.birost.com/a?ID=00550-5be6c52e-30ff-4c27-9137-aa026180578a">Qourum NWR</a></p></li></ul><p>Raft produces a result equivalent to (multi-)Paxos, and it is as efﬁcient as Paxos. In this lab we'll implement Raft, a replicated state machine protocol.</p><h1 id="introduction">Introduction</h1><p>We should follow the design in the <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">extended Raft paper</a>, with particular attention to Figure 2. We'll implement most of what's in the paper, including saving persistent state and reading it after a node fails and then restarts. We will not implement cluster membership changes (Section 6).</p><p>We may find this <a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">guide</a> useful, as well as this advice about <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt">locking</a> and <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt">structure</a> for concurrency.</p><p>To help us to understand Raft algorithm, this <a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">working draft</a> visualize the data flow of consensus algorithm and especially Raft algorithm.</p><p>Raft decomposes the consensus problem into three relatively independent subproblems: <strong>Leader Election, Log Replication in the state machine, and Cluster Membership Changes</strong>. In this lab, we will only implement the first two parts, with two other essential techniques for Raft practice: <strong>Persistence and Log Compaction</strong>.</p><h2 id="lab-code-structure">Lab Code Structure</h2><p>A service calls <code>Make(peers,me,…)</code> to create a Raft peer. the ports of all the Raft servers (including this one) are in <code>peers[]</code>. this server's port is <code>peers[me]</code>. all the servers' <code>peers[]</code> arrays have the same order. <code>persister</code> is a place for this server to save its persistent state, and also initially holds the most recent saved state, if any. <code>Make()</code> must return quickly, so it should start goroutines for any long-running work.</p><p><code>applyCh</code> is a channel on which the tester or service expects Raft to send <code>ApplyMsg</code> messages. The service expects your implementation to send an <code>ApplyMsg</code> for each newly committed log entry to the <code>applyCh</code> channel argument to <code>Make()</code>. you'll want to send two kinds of messages to the service (or tester) on the same server: command and snapshots. set <code>CommandValid</code> to <code>true</code> to indicate that the <code>ApplyMsg</code> contains a newly committed log entry and set <code>CommandValid</code> to <code>false</code> for snapshots.</p><p><code>Start(command interface&#123;&#125;)</code> asks Raft to start the processing to append the command to the replicated log. <code>Start()</code> should return immediately, without waiting for the log appends to complete.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// create a new Raft server instance:</span><br>rf := Make(peers, me, persister, applyCh)<br><br><span class="hljs-comment">// start agreement on a new log entry:</span><br>rf.Start(command <span class="hljs-keyword">interface</span>&#123;&#125;) (index, term, isleader)<br><br><span class="hljs-comment">// ask a Raft for its current term, and whether it thinks it is leader</span><br>rf.GetState() (term, isLeader)<br><br><span class="hljs-comment">// each time a new entry is committed to the log, each Raft peer</span><br><span class="hljs-comment">// should send an ApplyMsg to the service (or tester).</span><br><span class="hljs-keyword">type</span> ApplyMsg<br></code></pre></td></tr></table></figure><p>this lab has also provided a diagram of Raft interactions that can help clarify how your Raft code interacts with the layers on top of it:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft-server.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft interactions"><figcaption aria-hidden="true">lab2 Raft interactions</figcaption></figure><p>Combining the interactions diagram and test code, we can see how our Raft code works as a whole:</p><p>The test functions call <code>func make_config(t *testing.T, n int, unreliable bool, snapshot bool) *config</code> to create a raft service, in which, it calls <code>Make(peers,me,…)</code>.</p><p>The service calls <code>func (cfg *config) one(cmd interface&#123;&#125;, expectedServers int, retry bool) int</code> to do a complete agreement, in which, it calls <code>rf.Start(cmd)</code> to append the command to the replicated log.</p><h2 id="logging">Logging</h2><p>In order to debug distributed systems, We will make Go print a boring log with a specific format for each peer service. Here I use <a target="_blank" rel="noopener" href="https://github.com/hashicorp/go-hclog">go-hclog</a> as the logger to output formatted log in a file for each peer. <strong>It prints the message along with the topic and the amount of milliseconds since the start of the run</strong>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileConfig</span><span class="hljs-params">(file io.Writer)</span></span> Config &#123;<br>	id := generateUUID()<br>	<span class="hljs-keyword">return</span> Config&#123;<br>		HeartbeatTimeout:   <span class="hljs-number">100</span> * time.Millisecond,<br>		ElectionTimeout:    <span class="hljs-number">200</span> * time.Millisecond,<br>		CommitTimeout:      <span class="hljs-number">70</span> * time.Millisecond,<br>    <span class="hljs-comment">// LeaseRead, LeaderLeaseTimeout&lt;HeartbeatTimeout,</span><br>    <span class="hljs-comment">// During the lease period, we can believe that other nodes must not initiate elections, </span><br>    <span class="hljs-comment">// and the cluster must not have split-brain, so we can directly read the master during this time period.</span><br>		LeaderLeaseTimeout: <span class="hljs-number">100</span> * time.Millisecond, <br>		LogLevel:           <span class="hljs-string">&quot;DEBUG&quot;</span>,<br>		LocalID:            ServerID(id),<br>		LogOutput:          file,<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">rf.logger = hclog.New(&amp;hclog.LoggerOptions&#123;<br>		Name:  fmt.Sprintf(<span class="hljs-string">&quot;my-raft-%d&quot;</span>, me),<br>		Level: hclog.LevelFromString(rf.config().LogLevel),<br>		Output: rf.config().LogOutput,<br>	&#125;)<br></code></pre></td></tr></table></figure><h2 id="locking-advice">Locking Advice</h2><p>To avoid Livelocks, I use Golang <code>Atomic</code> as much as possible and fetch all the variables at the very beginning of each function. And try to use fine-grained lock instead of Coarse-Grained Lock (such as using <code>sync.Mutex</code> to lock the whole function). And also copy-on-write technich when dealing with the Raft <code>logs</code>.</p><p>Besides, to prevent thread getting blocked, we can add time limit to Go Select Statement for asynchronous nofitication:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// asyncNotifyCh is used to do an async channel send</span><br><span class="hljs-comment">// to a single channel without blocking.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">asyncNotifyCh</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>	<span class="hljs-keyword">select</span> &#123;<br>	<span class="hljs-keyword">case</span> ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;:<br>	<span class="hljs-keyword">default</span>:<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>To aovid deadlock, we can prevent Deadlock by eliminating Circular wait condition: all of the functions request the resources in an increasing order of numbering. For example, <code>lastLock sync.Mutex</code> first and then <code>logsLock sync.RWMutex</code>.</p><h1 id="data-structure-design">Data Structure Design</h1><p>As for the general structure, the tables in Raft paper are very clear in Figure 2, and we only need to add some details.</p><h2 id="server-state">Server State</h2><p>Firstly, we define some enum constants to represent the server node status:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RaftState captures the state of a Raft node: Follower, Candidate, Leader,</span><br><span class="hljs-comment">// or Shutdown.</span><br><span class="hljs-keyword">type</span> RaftState <span class="hljs-type">uint32</span><br><span class="hljs-keyword">const</span> (<br>	<span class="hljs-comment">// Follower is the initial state of a Raft node.</span><br>	Follower RaftState = <span class="hljs-literal">iota</span><br><br>	<span class="hljs-comment">// Candidate is one of the valid states of a Raft node.</span><br>	Candidate<br><br>	<span class="hljs-comment">// Leader is one of the valid states of a Raft node.</span><br>	Leader<br><br>	<span class="hljs-comment">// Shutdown is the terminal state of a Raft node.</span><br>	Shutdown<br>)<br></code></pre></td></tr></table></figure><p>To represent the state of all the servers, we define <code>raftState</code> to maintain various state variables:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft1.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft State"><figcaption aria-hidden="true">lab2 Raft State</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// raftState is used to maintain various state variables</span><br><span class="hljs-comment">// and provides an interface to set/get the variables in a</span><br><span class="hljs-comment">// thread safe manner.</span><br><span class="hljs-keyword">type</span> raftState <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// currentTerm commitIndex, lastLogIndex,  must be kept at the top of</span><br>	<span class="hljs-comment">// the struct so they&#x27;re 64 bit aligned which is a requirement for</span><br>	<span class="hljs-comment">// atomic ops on 32 bit platforms.</span><br><br>	<span class="hljs-comment">// The current term, cache of StableStore, start from 1</span><br>	currentTerm <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// Highest committed log entry</span><br>	commitIndex <span class="hljs-type">uint64</span><br>	<span class="hljs-comment">// Last applied log to the FSM</span><br>	lastApplied <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// protects 4 next fields</span><br>	lastLock sync.Mutex<br><br>	<span class="hljs-comment">// Cache the latest snapshot index/term</span><br>	lastSnapshotIndex <span class="hljs-type">uint64</span>  <span class="hljs-comment">//lastIncludedIndex</span><br>	lastSnapshotTerm  <span class="hljs-type">uint64</span>  <span class="hljs-comment">//lastIncludedTerm</span><br><br>	<span class="hljs-comment">// Cache the latest log that in Persistent state (stored in FSM)</span><br>	lastLogIndex <span class="hljs-type">uint64</span><br>	lastLogTerm  <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// Tracks running goroutines</span><br>	routinesGroup sync.WaitGroup<br><br>	<span class="hljs-comment">// The current state</span><br>	state         RaftState<br><br>	<span class="hljs-comment">//dedicated thread calling r.app.apply</span><br>	applyLogCh       <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>	<span class="hljs-comment">// killCh is used to kill all go routines when state changes</span><br>	killCh           <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In Go, one can use structs for inheritance. For object-oriented programming, we can compose using <code>raftState</code> to form our <code>Raft</code> peer struct:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Raft <span class="hljs-keyword">struct</span> &#123;<br>	raftState <span class="hljs-comment">//OOP inherit</span><br><br>	mu        sync.Mutex          <span class="hljs-comment">// Lock to protect shared access to this peer&#x27;s state</span><br>	peers     []*labrpc.ClientEnd <span class="hljs-comment">// RPC end points of all peers</span><br>	persister *Persister          <span class="hljs-comment">// Object to hold this peer&#x27;s persisted state</span><br>	me        <span class="hljs-type">int</span>                 <span class="hljs-comment">// this peer&#x27;s index into peers[]</span><br>	dead      <span class="hljs-type">int32</span>               <span class="hljs-comment">// set by Kill()</span><br>	<span class="hljs-comment">// Shutdown channel to exit, protected to prevent concurrent exits</span><br>	shutdownCh   <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>	shutdownLock sync.Mutex<br><br>	<span class="hljs-comment">// Your data here (2A, 2B, 2C).</span><br>	<span class="hljs-comment">// Look at the paper&#x27;s Figure 2 for a description of what</span><br>	<span class="hljs-comment">// state a Raft server must maintain.</span><br><br>	<span class="hljs-comment">// persistent state on all servers</span><br>	<span class="hljs-comment">//candidateID that received vote in current term</span><br>	votedFor <span class="hljs-type">int32</span><br>	<span class="hljs-comment">//the current cluster leader ID</span><br>	leaderID <span class="hljs-type">int32</span><br>	leaderLock sync.RWMutex<br><br>	<span class="hljs-comment">//each entry contains command for state machine</span><br>	<span class="hljs-comment">// and term when entry was received by leader</span><br>	<span class="hljs-comment">//we actually use logs[index-1] to fetch log with Index = index</span><br>	logs      []Log<br>	logsLock sync.RWMutex<br><br>	<span class="hljs-comment">// volatile state on leaders</span><br>	<span class="hljs-comment">// leaderState used only while state is leader</span><br>	leaderState LeaderState<br><br>	<span class="hljs-comment">// conf stores the current configuration to use. This is the most recent one</span><br>	<span class="hljs-comment">// provided. All reads of config values should use the config() helper method</span><br>	<span class="hljs-comment">// to read this safely.</span><br>	conf atomic.Value<br><br>	<span class="hljs-comment">// lastContact is the last time we had contact from the</span><br>	<span class="hljs-comment">// leader node. This can be used to gauge staleness.</span><br>	lastContact     time.Time<br>	lastContactLock sync.RWMutex<br><br>	<span class="hljs-comment">// committedCh chan notify client we have committed</span><br>	committedCh  <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>	<span class="hljs-comment">// applyCh is used to async send logs to the main thread to</span><br>	<span class="hljs-comment">// be committed and applied to the FSM.</span><br>	applyCh <span class="hljs-keyword">chan</span> ApplyMsg<br><br>	<span class="hljs-comment">// stable is a StableStore implementation for durable state</span><br>	<span class="hljs-comment">// It provides stable storage for many fields in raftState</span><br>	stable StableStore<br><br>	<span class="hljs-comment">// Used for our logging</span><br>	<span class="hljs-comment">// Logger is a user-provided logger. If nil, a logger writing to</span><br>	<span class="hljs-comment">// LogOutput with LogLevel is used.</span><br>	logger hclog.Logger<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="appendentries-rpc">AppendEntries RPC</h2><p>One important things to define PRC struct is that go RPC sends only struct fields whose names start with <strong>capital letters</strong>. <strong>Sub-structures must also have capitalized field names</strong> (e.g. fields of log records in an array). The <code>labgob</code> package will warn you about this; don't ignore the warnings.</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft2.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft AppendEntries"><figcaption aria-hidden="true">lab2 Raft AppendEntries</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// AppendEntriesArgs is the command used to append entries to the</span><br><span class="hljs-comment">// replicated log.</span><br><span class="hljs-keyword">type</span> AppendEntriesArgs <span class="hljs-keyword">struct</span> &#123;<br>	Term         <span class="hljs-type">uint64</span><br>	LeaderId     <span class="hljs-type">int32</span><br>	PrevLogIndex <span class="hljs-type">uint64</span> <span class="hljs-comment">//index of log entry immediately preceding new ones</span><br>	PrevLogTerm  <span class="hljs-type">uint64</span> <span class="hljs-comment">//term of prevLogIndex entry</span><br>	Entries      []Log<br>	LeaderCommit <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg AppendEntriesArgs)</span></span> String() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, LeaderId = %d, PrevLogIndex = %d, PrevLogTerm = %d, LeaderCommit = %d, Entries = %s&quot;</span>, arg.Term,arg.LeaderId,arg.PrevLogIndex,arg.PrevLogTerm,arg.LeaderCommit,arg.Entries)<br>&#125;<br><br><br><span class="hljs-keyword">type</span> AppendEntriesReply <span class="hljs-keyword">struct</span> &#123;<br>	ServerID      <span class="hljs-type">int</span><br>	Term          <span class="hljs-type">uint64</span><br>	Success       <span class="hljs-type">bool</span><br><br>	<span class="hljs-comment">// optimization: accelerated log backtracking</span><br>	ConflictTerm  <span class="hljs-type">uint64</span>  <span class="hljs-comment">// first Log Term that conflicts between follower and leader</span><br>	ConflictIndex <span class="hljs-type">uint64</span>  <span class="hljs-comment">// first Log Index that conflicts between follower and leader</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg AppendEntriesReply)</span></span> String() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;ServerID = %d, Term = %d, Success = %v, ConflictTerm = %d, ConflictIndex = %d&quot;</span>,<br>		arg.ServerID,arg.Term,arg.Success,arg.ConflictTerm,arg.ConflictIndex)<br>&#125;<br></code></pre></td></tr></table></figure><p>Another important things here is that, for all of the data structure, <strong>attaching a <code>String()</code> function to a named struct</strong> allows us to convert a struct to a string. This will help me a lot during debugging!</p><h2 id="requestvote-rpc">RequestVote RPC</h2><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft3.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft RequestVote"><figcaption aria-hidden="true">lab2 Raft RequestVote</figcaption></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RequestVoteArgs</span><br><span class="hljs-comment">// example RequestVote RPC arguments structure.</span><br><span class="hljs-comment">// field names must start with capital letters!</span><br><span class="hljs-keyword">type</span> RequestVoteArgs <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// Your data here (2A, 2B).</span><br>	Term <span class="hljs-type">uint64</span><br>	CandidateId <span class="hljs-type">int32</span><br>	<span class="hljs-comment">// Cache the latest log from LogStore</span><br>	LastLogIndex <span class="hljs-type">uint64</span><br>	LastLogTerm  <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// for Debug</span><br>	Time time.Time<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg RequestVoteArgs)</span></span> String() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, CandidateId = %v, LastLogIndex = %v, LastLogTerm = %v, request Time = %v&quot;</span>,<br>		arg.Term,arg.CandidateId,arg.LastLogIndex,arg.LastLogTerm, arg.Time)<br>&#125;<br><br><span class="hljs-comment">// example RequestVote RPC reply structure.</span><br><span class="hljs-comment">// field names must start with capital letters!</span><br><span class="hljs-keyword">type</span> RequestVoteReply <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// Your data here (2A).</span><br>	Term <span class="hljs-type">uint64</span><br>	VoteGranted <span class="hljs-type">bool</span><br>	VoterID <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// for Debug</span><br>	Time time.Time<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg RequestVoteReply)</span></span> String() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, VoteGranted = %v, VoterID = %v, reply time = %v&quot;</span>,<br>		arg.Term,arg.VoteGranted,arg.VoterID, arg.Time)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="installsnapshot-rpc">InstallSnapshot RPC</h2><p>In the Raft paper, Snapshots are split into chunks for transmission; this gives the follower a sign of life with each chunk, so it can reset its election timer.</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft5.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft InstallSnapshot"><figcaption aria-hidden="true">lab2 Raft InstallSnapshot</figcaption></figure><p>But here, for simplicity, we don't split Snapshots into several chunks. So we don't use the variable <code>offset</code> and <code>done</code> in this lab.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// InstallSnapshotRequest is the command sent to a Raft peer to bootstrap its</span><br><span class="hljs-comment">// log (and state machine) from a snapshot on another peer.</span><br><span class="hljs-keyword">type</span> InstallSnapshotRequest <span class="hljs-keyword">struct</span> &#123;<br>	Term        <span class="hljs-type">uint64</span><br>	LeaderId    <span class="hljs-type">int32</span>    <span class="hljs-comment">// LeaderId of request</span><br><br>	<span class="hljs-comment">// These are the last index/term included in the snapshot</span><br>	LastLogIndex <span class="hljs-type">uint64</span><br>	LastLogTerm  <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// Raw byte stream data of snapshot</span><br>	Data         []<span class="hljs-type">byte</span><br><br>	<span class="hljs-comment">// Size of the snapshot</span><br>	Size         <span class="hljs-type">int64</span><br><br>	<span class="hljs-comment">// true if this is the last chunk</span><br>	Done         <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg InstallSnapshotRequest)</span></span> String() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, LeaderId = %d, LastLogIndex = %d, LastLogTerm = %d, Data = %v, Size = %d&quot;</span>,<br>		arg.Term,arg.LeaderId,arg.LastLogIndex,arg.LastLogTerm,arg.Data,arg.Size)<br>&#125;<br><span class="hljs-comment">// InstallSnapshotReply is the response returned from an</span><br><span class="hljs-comment">// InstallSnapshotRequest.</span><br><span class="hljs-keyword">type</span> InstallSnapshotReply <span class="hljs-keyword">struct</span> &#123;<br>	Term    <span class="hljs-type">uint64</span><br>	Success <span class="hljs-type">bool</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(arg InstallSnapshotReply)</span></span> String() <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Term = %d, Success = %v&quot;</span>,<br>		arg.Term,arg.Success)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="rpc-handler">RPC Handler</h1><p>Our Raft peers should exchange RPCs using the <code>labrpc</code> Go package (source in <code>src/labrpc</code>). The tester can tell <code>labrpc</code> to delay RPCs, re-order them, and discard them to simulate various network failures.</p><p>We use <code>labrpc.ClientEnd.Call()</code> to send a request and waits for a reply. <code>Call()</code> is guaranteed to return (perhaps after a delay) <em>except</em> if the handler function on the server side does not return. Thus there is no need to implement your own timeouts around <code>Call()</code>.</p><p>The labrpc package simulates a lossy network, in which servers may be unreachable, and in which requests and replies may be lost. <code>Call()</code>sends a request and waits for a reply. If a reply arrives within a timeout interval, <code>Call()</code> returns true; otherwise <code>Call()</code> returns false. <strong>Thus <code>Call()</code> may not return for a while</strong>. A false return can be caused by a dead server, a live server that can't be reached, a lost request, or a lost reply.</p><p>Since <code>Call()</code> may return for a long time, which means the possibility of outdated PRC response. And we apply Go Channel as a medium for goroutines, for example background goroutine that kicking off leader election periodically by sending out <code>RequestVote</code> RPCs, to communicate with each other. So we should take this condition into account: Peer 1, for example, sent the <code>RequestVote</code> RPCs during the its <em>leader</em> lease time and got blocked in <code>rf.peers[server].Call(...)</code> clause, but when RPC returned, peer 1 has already been the <em>follower</em>, which means this PRC response is outdated and some of the <strong>channels for receiving data</strong> have already been cloesed!</p><p>One way to handle this potential bug is to restrict blocked time in RPC handler:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		ok := rf.peers[server].Call(<span class="hljs-string">&quot;Raft.InstallSnapShot&quot;</span>, args, reply)<br>		rstChan &lt;- ok<br>	&#125;()<br><span class="hljs-keyword">select</span> &#123;<br>  <span class="hljs-keyword">case</span> ok = &lt;-rstChan:<br>	<span class="hljs-keyword">case</span> &lt;-time.After(rf.config().HeartbeatTimeout):<br>  <span class="hljs-comment">//call rpc timeout!!!</span><br>  rf.logger.Debug(<span class="hljs-string">&quot;sent an SnapShot timeout!!&quot;</span>,<span class="hljs-string">&quot;from &quot;</span>, rf.me,<span class="hljs-string">&quot; to &quot;</span>, server)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="server-behavior">Server Behavior</h1><p>At any given time each server is in one of three states: <strong>leader, follower, or candidate</strong>.</p><ul><li>Followers are passive: they issue no requests on their own but simply respond to requests from leaders and candidates.</li><li>The leader handles all client requests (if a client contacts a follower, the follower redirects it to the leader).</li><li>Candidate is used to elect a new leader.</li></ul><p>So the whole Raft module is constructed in a main loop:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//main server loop.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> ticker() &#123;<br>	<span class="hljs-keyword">for</span> rf.killed() == <span class="hljs-literal">false</span> &#123;<br><br>		<span class="hljs-comment">// Your code here to check if a leader election should</span><br>		<span class="hljs-comment">// be started and to randomize sleeping time using</span><br>		<span class="hljs-comment">// time.Sleep().</span><br>		<span class="hljs-comment">// Check if we are doing a shutdown</span><br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-keyword">case</span> &lt;-rf.shutdownCh:<br>			<span class="hljs-comment">// Clear the leader to prevent forwarding</span><br>			rf.setLeader(<span class="hljs-number">-1</span>)<br>			<span class="hljs-keyword">return</span><br>		<span class="hljs-keyword">default</span>:<br>		&#125;<br><br>		<span class="hljs-keyword">switch</span> rf.getState() &#123;<br>		<span class="hljs-keyword">case</span> Follower:<br>			rf.runFollower()<br>		<span class="hljs-keyword">case</span> Candidate:<br>			rf.runCandidate()<br>		<span class="hljs-keyword">case</span> Leader:<br>			rf.runLeader()<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>What is left is to code all the behaviors of different states for one server. Figure 2 describes the algorithm more precisely:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft4.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft Rules for Servers"><figcaption aria-hidden="true">lab2 Raft Rules for Servers</figcaption></figure><h1 id="leader-election">Leader Election</h1><p>Raft uses a heartbeat mechanism to trigger leader election. When servers start up, they <strong>begin as followers</strong> running code <code>rf.runFollower()</code>. A server remains in follower state as long as it receives valid RPCs from a leader or candidate.</p><p>If a follower receives no communication over a period of time called the <em>election timeout</em> (in code we use <code>HeartbeatTimeout</code> to represent), then it assumes there is no viable leader and begins an election to choose a new leader. After the node elects itself as a candidate, the function <code>rf.runCandidate()</code>executes.</p><h2 id="runfollower">runFollower()</h2><p>Each follower will have a random time to see if the leader's <em>contact</em> has been received within a certain period of time(<code>HeartbeatTimeout</code>). If the time from the <strong>last contact</strong> exceeds the timeout time, it will enter the <em>candidate</em> state:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">heartbeatTimer := randomTimeout(r.config().HeartbeatTimeout)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> &lt;-heartbeatTimer:<br>			<span class="hljs-comment">// Restart the heartbeat timer</span><br>			hbTimeout := r.config().HeartbeatTimeout<br>			heartbeatTimer = randomTimeout(hbTimeout)<br><br>			<span class="hljs-comment">// Check if we have had a successful contact</span><br>			lastContact := r.LastContact()<br>			<span class="hljs-keyword">if</span> time.Now().Sub(lastContact) &lt; hbTimeout &#123;<br>				<span class="hljs-comment">//log here</span><br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			<span class="hljs-comment">// Heartbeat failed! Transition to the candidate state</span><br>			<span class="hljs-comment">//If election timeout elapses without receiving AppendEntries RPC from current leader</span><br>			<span class="hljs-comment">//or granting vote to candidate: convert to candidate</span><br>			r.setLeader(<span class="hljs-number">-1</span>)<br>			r.setState(Candidate)<br></code></pre></td></tr></table></figure><p>Every time the <em>follower</em> receives the leader's HeartBeat, AppendEntries, InstallSnapshot and other operations, the <code>LastContact</code> time will be updated:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// setLastContact is used to set the last contact time to now</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> setLastContact() &#123;<br>	r.lastContactLock.Lock()<br>	r.lastContact = time.Now()<br>	r.lastContactLock.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)&#123;<br>	...<br>	<span class="hljs-comment">// you grant a vote to another peer. restart your election timer</span><br>	rf.setLastContact()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)&#123;<br>		...<br>		<span class="hljs-comment">//restart your election timer if you get an AppendEntries RPC from the current leader</span><br>		rf.setLastContact()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> InstallSnapShot(req *InstallSnapshotRequest,reply *InstallSnapshotReply) &#123;<br>	...<br>	reply.Success = <span class="hljs-literal">true</span><br>	<span class="hljs-comment">//restart your election timer if you get an InstallSnapShot RPC from the current leader</span><br>	r.setLastContact()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="runcandidate">runCandidate()</h2><p>The core logic of the <em>candidate</em> is in the <code>electSelf()</code> function, where the candidate will first increase its own <em>term</em>, and then send RequestVote RPC in parallel to each of the other servers in the cluster., and finally become the leader when the number of votes is greater than 1/2 of the number of nodes.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// electSelf is used to send a RequestVote RPC to all peers, and vote for</span><br><span class="hljs-comment">// ourself. This has the side affecting of incrementing the current term. The</span><br><span class="hljs-comment">// response channel returned is used to wait for all the responses (including a</span><br><span class="hljs-comment">// vote for ourself). This must only be called from the main thread.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> electSelf() &lt;-<span class="hljs-keyword">chan</span> *RequestVoteReply&#123;<br>	<span class="hljs-comment">// Increment the term</span><br>	r.setCurrentTerm(r.getCurrentTerm() + <span class="hljs-number">1</span>)<br><br>	<span class="hljs-comment">// Create a response channel</span><br>	respCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *RequestVoteReply, <span class="hljs-built_in">len</span>(r.peers))<br><br>	<span class="hljs-comment">// Construct the request</span><br>	lastIdx, lastTerm := r.getLastEntry()<br>	req := &amp;RequestVoteArgs&#123;<br>		Term:         r.getCurrentTerm(),<br>		CandidateId:  <span class="hljs-type">int32</span>(r.me),<br>		LastLogIndex: lastIdx,<br>		LastLogTerm:  lastTerm,<br>	&#125;<br><br>	<span class="hljs-comment">// Construct a function to ask for a vote</span><br>	askPeer := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(peerId <span class="hljs-type">int</span>)</span></span> &#123;<br>		r.goFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>			voteReply := &amp;RequestVoteReply&#123;&#125;<br>			voteReply.VoterID = <span class="hljs-type">uint64</span>(peerId)<br>			err := r.sendRequestVote(peerId, req, voteReply)<br>			<span class="hljs-keyword">if</span> !err&#123;<br>				r.logger.Error(<span class="hljs-string">&quot;failed to make requestVote RPC&quot;</span>, <span class="hljs-string">&quot;target&quot;</span>, peerId,<br>					<span class="hljs-string">&quot;error&quot;</span>, err, <span class="hljs-string">&quot;term&quot;</span>, req.Term)<br>				voteReply.Term = req.Term<br>				voteReply.VoteGranted = <span class="hljs-literal">false</span><br>			&#125;<br>			<span class="hljs-comment">// note we may be blocked here if target rf has been killed and sendRequestVote will wait,</span><br>			<span class="hljs-comment">// at the same time we are killed and respCh is closed before sendRequestVote returned</span><br>			<span class="hljs-comment">// so we need to double check our state again here</span><br>			<span class="hljs-keyword">if</span> r.getState() != Candidate || r.getCurrentTerm() != req.Term&#123;<br>				r.logger.Warn(<span class="hljs-string">&quot;obsolete request returned!!!!!!!! ignore it&quot;</span>)<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>			respCh &lt;- voteReply<br>		&#125;)<br>	&#125;<br><br>	<span class="hljs-comment">// For each peer, request a vote</span><br>	<span class="hljs-keyword">for</span> serverId,_:=<span class="hljs-keyword">range</span> r.peers&#123;<br>		<span class="hljs-comment">// vote for myself</span><br>		<span class="hljs-keyword">if</span> serverId==r.me &#123;<br>			r.logger.Debug(<span class="hljs-string">&quot;voting for self&quot;</span>, <span class="hljs-string">&quot;term&quot;</span>, req.Term, <span class="hljs-string">&quot;id&quot;</span>, r.me)<br>			<span class="hljs-comment">// Include our own vote</span><br>			respCh &lt;-&amp;RequestVoteReply&#123;<br>				Term:        req.Term,<br>				VoteGranted: <span class="hljs-literal">true</span>,<br>				VoterID: <span class="hljs-type">uint64</span>(serverId),<br>			&#125;<br>			r.setVotedFor(<span class="hljs-type">int32</span>(r.me))<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			r.logger.Debug(<span class="hljs-string">&quot;asking for vote&quot;</span>,<span class="hljs-string">&quot;node &quot;</span>,r.me,  <span class="hljs-string">&quot;term&quot;</span>, req.Term, <span class="hljs-string">&quot;from&quot;</span>, serverId)<br>			askPeer(serverId)<br>		&#125;<br>	&#125;<br>	r.persist()<br>	<span class="hljs-keyword">return</span> respCh<br>&#125;<br></code></pre></td></tr></table></figure><p>The <em>candidate</em> process is as follows:</p><ol type="1"><li>send RequestVote RPC to all nodes: elect yourself as the leader and wait for the replies from all other nodes.</li><li>If in the replies of other nodes, the <strong>term</strong> of their service is greater than the <strong>term</strong> of your own (<code>vote.Term &gt; r.getCurrentTerm()</code>), indicating that your election is behind and you are not eligible for the leader, so you set your status to <em>follower</em> and update <strong>term</strong> at the same time. Finally exit the candidate process.</li><li>If the replies from other nodes agree with your own proposal, your <em>votes</em> will be increased by one. If the number of <em>votes</em> is greater than half of the nodes, it means that your are successfully elected as the leader, and your status is updated to the <strong><em>leader</em></strong>. Finally exit the candidate process.</li><li>If the election request times out, exit the candidate process directly.</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> r.getState() == Candidate &#123;<br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-keyword">case</span> vote := &lt;-voteCh:<br>			<span class="hljs-comment">// If RPC request or response contains term T &gt; currentTerm:</span><br>			<span class="hljs-comment">//set currentTerm = T, convert to follower (§5.1)</span><br>			<span class="hljs-keyword">if</span> vote.Term &gt; r.getCurrentTerm() &#123;<br>				r.logger.Warn(<span class="hljs-string">&quot;newer term discovered, fallback to follower&quot;</span>, <span class="hljs-string">&quot;term&quot;</span>, vote.Term)<br>				r.setState(Follower)<br>				r.setCurrentTerm(vote.Term)<br>				r.setLeader(<span class="hljs-number">-1</span>)<br>				r.persist()<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>			<span class="hljs-comment">// Check if the vote is granted</span><br>			<span class="hljs-keyword">if</span> vote.VoteGranted &#123;<br>				grantedVotes++<br>				r.logger.Debug(<span class="hljs-string">&quot;vote granted&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>, vote.VoterID,<br>					<span class="hljs-string">&quot;term&quot;</span>, vote.Term, <span class="hljs-string">&quot;tally&quot;</span>, grantedVotes)<br>			&#125;<br>			<span class="hljs-comment">// Check if we&#x27;ve become the leader</span><br>			<span class="hljs-keyword">if</span> grantedVotes &gt;= votesNeeded &#123;<br>				r.logger.Info(<span class="hljs-string">&quot;election won&quot;</span>,<span class="hljs-string">&quot;server [&quot;</span>,r.me,<span class="hljs-string">&quot;], term&quot;</span>, vote.Term, <span class="hljs-string">&quot;tally&quot;</span>, grantedVotes)<br>				r.setState(Leader)<br>				r.setLeader(<span class="hljs-type">int32</span>(r.me))<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>		<span class="hljs-keyword">case</span> &lt;-electionTimer:<br>			<span class="hljs-comment">//If election timeout elapses: start new election</span><br>			r.logger.Warn(<span class="hljs-string">&quot;Election timeout reached, restarting election&quot;</span>)<br>			<span class="hljs-keyword">return</span><br>		<span class="hljs-keyword">case</span> &lt;-r.shutdownCh:<br>			r.logger.Warn(<span class="hljs-string">&quot;candidate server shut down!!&quot;</span>,<span class="hljs-string">&quot;peer&quot;</span>,r.me)<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="safety-argument">Safety Argument</h2><p>Generally, consensus algorithms need to satisfy three basic properties, namely <strong>agreement, integrity, and termination</strong>. These three basic properties can also be summarized into two, namely <strong>Liveness and Safety</strong>. Safety refers to agreement and integrity, which means that the processed proposal comes from the correct node, and the final state of the correct node can always be consistent.</p><p>Raft ensures this security by adding some additional restrictions and measures to the process of leader election and log replication:</p><ul><li><p>Make sure the <strong>election timeouts in different peers don't always fire at the same time</strong>, or else all peers will vote only for themselves and no one will become the leader.</p></li><li><p>The system should satisﬁes the following <strong>timing requirement:</strong> <code>broadcastTime ≪ electionTimeout ≪ MTBF</code></p><p>The paper's Section 5.2 mentions election timeouts in the range of 150 to 300 milliseconds. Such a range only makes sense if the leader sends heartbeats considerably more often than once per 150 milliseconds.</p><p>Because the tester limits you to 10 heartbeats per second, we will have to use an <strong>election timeout larger than the paper's 150 to 300 milliseconds</strong>, but not too large, because then you may fail to elect a leader within five seconds.</p></li></ul><ol type="1"><li><p>To randomize the election timeouts, we may find Go's <a target="_blank" rel="noopener" href="https://golang.org/pkg/math/rand/">rand</a> useful:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// randomTimeout returns a value that is between the minVal and 2x minVal.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randomTimeout</span><span class="hljs-params">(minVal time.Duration)</span></span> &lt;-<span class="hljs-keyword">chan</span> time.Time &#123;<br>	<span class="hljs-keyword">if</span> minVal == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>	&#125;<br>	extra := time.Duration(rand.Int63()) % minVal<br>	<span class="hljs-keyword">return</span> time.After(minVal + extra)<br>&#125;<br></code></pre></td></tr></table></figure><p>we can use it like this:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">heartbeatTimer := randomTimeout(r.config().HeartbeatTimeout)<br></code></pre></td></tr></table></figure></li><li><p>Here we give two recommended parameter settings:</p><ul><li><p>ElectionTimeout: 150ms-300ms, HeartbeatTimeout: 50ms</p></li><li><p>ElectionTimeout: 200ms-400ms, HeartbeatTimeout: 100ms</p></li></ul><blockquote><p>ref: <a target="_blank" rel="noopener" href="https://github.com/springfieldking/mit-6.824-golabs-2018/issues/1">lab2-one(%v) failed to reach agreement</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DefaultConfig</span><span class="hljs-params">()</span></span> Config &#123;<br>	id := generateUUID()<br>	<span class="hljs-keyword">return</span> Config&#123;<br>		HeartbeatTimeout:   <span class="hljs-number">100</span> * time.Millisecond,<br>		ElectionTimeout:    <span class="hljs-number">200</span> * time.Millisecond,<br>		CommitTimeout:      <span class="hljs-number">50</span> * time.Millisecond,<br>		LeaderLeaseTimeout: <span class="hljs-number">100</span> * time.Millisecond,<br>		LogLevel:           <span class="hljs-string">&quot;DEBUG&quot;</span>,<br>		LocalID:            ServerID(id),<br>		LogOutput:          os.Stderr,<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="log-replication">Log Replication</h1><p>Log replication is initiated by the leader and executed in the function <code>rf.runLeader()</code>.</p><p>The <em>Leader</em> process is as follows:</p><ol type="1"><li><p>Start a replication routine for each peer, calling <code>r.startStopReplication()</code> to perform log replication.</p></li><li><p>Sit in the leader loop until we step down, calling <code>r.leaderLoop()</code>.</p></li><li><p>In <code>leaderLoop()</code>, we periodically check out leader state:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> r.getState() == Leader &#123;<br>  ...<br>  <span class="hljs-keyword">case</span> &lt;-lease:<br>  		<br>  		<span class="hljs-comment">// Check if we&#x27;ve exceeded the lease, potentially stepping down</span><br>			maxDiff := r.checkLeaderLease()<br><br>			<span class="hljs-comment">// Next check interval should adjust for the last node we&#x27;ve</span><br>			<span class="hljs-comment">// contacted, without going negative</span><br>			checkInterval := r.config().LeaderLeaseTimeout - maxDiff<br>			<span class="hljs-keyword">if</span> checkInterval &lt; minCheckInterval &#123;<br>				checkInterval = minCheckInterval<br>			&#125;<br>  <br>			r.logger.Info(<span class="hljs-string">&quot;check lease time&quot;</span>,<span class="hljs-string">&quot;checkInterval&quot;</span>,checkInterval)<br>			<span class="hljs-comment">// Renew the lease timer</span><br>			lease = time.After(checkInterval)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>When we exit leader state, reset <code>lastContact</code>(calling <code>r.setLastContact()</code>). Since we were the leader previously, we update our last contact time when we step down, so that <strong>we are not reporting a last contact time from before we were the leader.</strong> Otherwise, to a client it would seem our data is extremely stale.</p></li></ol><p>The core function to perform log replication is <code>startStopReplication()</code>:</p><ol type="1"><li><p>Start a new goroutine, calling <code>replicate()</code> to perform log replication for each node except the leader.</p></li><li><p>The status of each node's AppendEntries RPC is saved through the object <code>followerReplication</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// followerReplication is in charge of sending snapshots and log entries from</span><br><span class="hljs-comment">// this leader during this particular term to a remote follower.</span><br><span class="hljs-keyword">type</span> followerReplication <span class="hljs-keyword">struct</span> &#123;<br>  <br>	Term         <span class="hljs-type">uint64</span><br>	LeaderId     <span class="hljs-type">int32</span><br>	PrevLogIndex <span class="hljs-type">uint64</span><br>	PrevLogTerm  <span class="hljs-type">uint64</span><br>	LeaderCommit <span class="hljs-type">uint64</span><br><br>	Entries      []Log<br>	EntriesLock sync.RWMutex<br><br>	<span class="hljs-comment">// getLastContact is updated to the current time whenever any response is</span><br>	<span class="hljs-comment">// received from the follower (successful or not). This is used to check</span><br>	<span class="hljs-comment">// whether the leader should step down (Raft.checkLeaderLease()).</span><br>	LastContact time.Time<br>	<span class="hljs-comment">// LastContactLock protects &#x27;getLastContact&#x27;.</span><br>	LastContactLock sync.RWMutex<br><br>	<span class="hljs-comment">// failures counts the number of failed RPCs since the last success, which is</span><br>	<span class="hljs-comment">// used to apply backoff.</span><br>	Failures <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// stopCh is notified/closed when this leader steps down or the follower is</span><br>	<span class="hljs-comment">// removed from the cluster. In the follower removed case, it carries a log</span><br>	<span class="hljs-comment">// index; replication should be attempted with a best effort up through that</span><br>	<span class="hljs-comment">// index, before exiting.</span><br>	stopCh <span class="hljs-keyword">chan</span> <span class="hljs-type">uint64</span><br><br>	<span class="hljs-comment">// stepDown is used to indicate to the leader that we</span><br>	<span class="hljs-comment">// should step down based on information from a follower.</span><br>	stepDown <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>	<span class="hljs-comment">// triggerCh is notified every time new entries are appended to the log.</span><br>	triggerCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>In the function <code>replicate()</code> , call <code>replicateTo()</code> to do log replication via sending <em>AppendEntries RPC</em> as soon as the leader receives a new <em>command</em> .(After the <code>replicate()</code> goroutine detects that there is a message in <code>triggerCh</code>, it starts to call <code>replicate()</code> )</p></li><li><p>In the beginning of <code>replicate()</code> , we start an another new goroutine calling function <code>heartbeat()</code> to send <em>heartbeat RPC</em> to all the followers periodically.</p></li><li><p>One important issue here is that when 1 new <em>command</em> comes in, the function <code>replicate()</code> may still be running in <code>replicateTo()</code> due to previous command. Since the channel size of <code>triggerCh</code> is 1, if new commands come in so fast, we will fail to send the new <em>AppendEntries RPC</em> to followers. To address this issue, we have 2 mechanism:</p><ul><li><p>Add a new channel <code>&lt;-randomTimeout(r.config().CommitTimeout)</code> to send <em>AppendEntries RPC</em> periodically for compendation.</p></li><li><p>Instead of sending empty <em>AppendEntries RPC</em> as the <strong>heartbeat RPC</strong>, we will carry new <code>entries[]</code> if we have new <em>command</em> in leader's logs.</p></li></ul></li></ol><p>When the leader sends <em>AppendEntries</em> to the follower, it will take the adjacent previous log (<strong>we don't actually need the <code>Log</code> object, but only need <code>PrevLogIndex</code> and <code>PrevLogTerm</code> for consistency check!</strong>). When the follower receives AppendEntries RPC, it will find the previous log entry with same <code>Term</code> and <code>Index</code>.</p><p>If it exists and matches, it will accept the log entry; otherwise, after a rejection, the leader decrements <code>nextIndex</code> and retries the <strong>AppendEntries RPC</strong>. Eventually <code>nextIndex</code> will reach a point where the leader and follower logs match.</p><p>Then the follower deletes all the logs after the <code>Index</code> and appends the log entries sent by the leader. Once the logs are appended successfully, all the logs of the follower and the leader are consistent.</p><p>Only after the majority of followers respond to receive the log, indicating that the log can be committed, can leader response to client applying successfully.</p><h2 id="the-importance-of-details">The Importance of Details</h2><ol type="1"><li>Follower deleting the existing entry is conditional</li></ol><p>Upon receiving a heartbeat, You may truncate the follower’s log following <code>prevLogIndex</code>, and then append any entries included in the <code>AppendEntries</code> arguments. <strong>This is not correct</strong>. We can once again turn to Figure 2:</p><blockquote><p><strong>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it.</strong></p></blockquote><p>The <em>if</em> here is crucial. <strong>If the follower has all the entries the leader sent</strong>, the follower <strong>MUST NOT</strong> truncate its log. Any elements <em>following</em> the entries sent by the leader <strong>MUST</strong> be kept. This is because we could be receiving an outdated <code>AppendEntries</code> RPC from the leader, and truncating the log would mean “taking back” entries that we may have already told the leader that we have in our log.</p><ol start="2" type="1"><li>Leaders can only commit logs of their own term</li></ol><p>Figure 8 use a time sequence showing why a leader cannot determine commitment using log entries from older terms. To eliminate problems like the one in Figure 8, <strong>Raft never commits log entries from previous terms by counting replicas</strong>. Only log entries from the leader’s current term are committed by counting replicas.</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/fig8.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft Figure 8"><figcaption aria-hidden="true">lab2 Raft Figure 8</figcaption></figure><h2 id="coding-hints">Coding Hints</h2><ol type="1"><li>One trick here to implement the rules in Figure 2 for Leaders:</li></ol><blockquote><p>If there exists an N such that <code>N &gt; commitIndex</code>, a majority of <code>matchIndex[i] ≥ N</code>, and <code>log[N].term == currentTerm</code>: set <code>commitIndex = N</code> (§5.3, §5.4).</p></blockquote><p>To obtain the majority of <code>matchIndex[i] ≥ N</code>, We can sort <code>matchIndex[]</code> in the increasing order and then fetch the middle one, which is just the <code>N</code> here. And then we can judge if <code>N &gt; commitIndex</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">matchIndex := rpcArg.PrevLogIndex + <span class="hljs-type">uint64</span>(<span class="hljs-built_in">len</span>(rpcArg.Entries))<br>r.logger.Info(<span class="hljs-string">&quot;update sever state&quot;</span>,<span class="hljs-string">&quot;sever&quot;</span>, reply.ServerID,<span class="hljs-string">&quot; matchIndex &quot;</span>,matchIndex)<br>r.leaderState.updateStateSuccess(reply.ServerID,matchIndex)<br><br><span class="hljs-comment">//If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N,</span><br><span class="hljs-comment">//and log[N].term == currentTerm: set commitIndex = N (§5.3, §5.4).</span><br>copyMatchIndex := <span class="hljs-built_in">make</span>(uint64Slice, <span class="hljs-built_in">len</span>(r.peers))<br>r.leaderState.indexLock.Lock()<br><span class="hljs-built_in">copy</span>(copyMatchIndex, r.leaderState.matchIndex)<br>r.leaderState.indexLock.Unlock()<br>copyMatchIndex[r.me] = r.getLastIndex()<br><br><span class="hljs-comment">//sort and get the middle to judge the majority</span><br>sort.Slice(copyMatchIndex, copyMatchIndex.Less)<br>N := copyMatchIndex[<span class="hljs-built_in">len</span>(r.peers)/<span class="hljs-number">2</span>]<br>r.logger.Debug(<span class="hljs-string">&quot;check returned matchIndex&quot;</span>,<span class="hljs-string">&quot;copyMatchIndex&quot;</span>,copyMatchIndex)<br><br><span class="hljs-comment">// convert to offset due to log compact</span><br>offset := N - <span class="hljs-number">1</span> - base<br><span class="hljs-keyword">if</span> N &gt; r.getCommitIndex() &amp;&amp; currentLogs[offset].Term == currentTerm &#123;<br>  r.setCommitIndex(N)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>The code have loops that repeatedly check for certain events. Don't have these loops execute continuously without pausing, since that will slow your implementation enough that it fails tests. We insert a time waiting in each loop iteration:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> heartbeat(id <span class="hljs-type">int</span>, s *followerReplication, stopCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#123;<br>  ...<br>  <span class="hljs-keyword">for</span> s.Term == r.getCurrentTerm()&#123;<br>		r.logger.Debug(<span class="hljs-string">&quot;heartbeat show current followerReplication data&quot;</span>,<span class="hljs-string">&quot;peer&quot;</span>, id, <span class="hljs-string">&quot; followerReplication&quot;</span>,s)<br>		<span class="hljs-comment">// Don&#x27;t have these loops execute continuously without pausing</span><br>		<span class="hljs-comment">// Wait for the next heartbeat interval or forced notify</span><br>		<span class="hljs-keyword">select</span> &#123;<br>		<span class="hljs-keyword">case</span> &lt;-randomTimeout(r.config().HeartbeatTimeout / <span class="hljs-number">4</span>):<br>		<span class="hljs-keyword">case</span> &lt;-stopCh:<br>			r.logger.Warn(<span class="hljs-string">&quot;replicate stopped heartbeat&quot;</span>,<span class="hljs-string">&quot;leader&quot;</span>,r.me,<span class="hljs-string">&quot; peer&quot;</span>,id)<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>		<span class="hljs-comment">// each command is sent to each peer just once.</span><br>		<span class="hljs-comment">// heartbeat does not send entries</span><br>		<span class="hljs-keyword">if</span> r.getState() != Leader &#123; <span class="hljs-comment">// has already stepped down</span><br>			r.logger.Warn(<span class="hljs-string">&quot;close heartbeat due to transferring to follower&quot;</span>)<br>			<span class="hljs-keyword">return</span><br>		&#125;<br>		...<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p>If <code>commitIndex &gt; lastApplied</code> <em>at any point</em> during execution, we should apply a particular log entry. It is not crucial that you do it straight away (for example, in the <code>AppendEntries</code> RPC handler), but it is important that you ensure that this application is only done by one entity. Specifically, <strong>we have a dedicated “applier”:<code>startApplyLogs()</code></strong>, so that some other routine doesn’t also detect that entries need to be applied and also tries to apply:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> startApplyLogs() &#123;<br>	<span class="hljs-comment">// dedicated thread calling r.app.apply from Raft</span><br>	rf.goFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>		<span class="hljs-keyword">for</span> &#123;<br>			<span class="hljs-keyword">select</span> &#123;<br>			<span class="hljs-keyword">case</span> &lt;- rf.applyLogCh:<br><br>				<span class="hljs-comment">// may only be partially submitted</span><br>				lastApplied := rf.getLastApplied()<br><br>				<span class="hljs-keyword">for</span> lastApplied &lt; rf.getCommitIndex()&#123;<br>					newLastApplied := lastApplied + <span class="hljs-number">1</span><br><br>					msg := ApplyMsg&#123;&#125;<br>					msg.CommandValid = <span class="hljs-literal">true</span><br>					msg.SnapshotValid = <span class="hljs-literal">false</span><br>					msg.CommandIndex = <span class="hljs-type">int</span>(newLastApplied)<br><br>					entry := rf.getEntryByOffset(newLastApplied)<br>					msg.Command = entry.Data<br><br>					<span class="hljs-comment">// Update the last log since it&#x27;s on disk now</span><br>					rf.setLastApplied(newLastApplied)<br><br>					rf.applyCh &lt;- msg<br><br>					lastApplied = newLastApplied<br>				&#125;<br>        <br>			<span class="hljs-keyword">case</span> &lt;-rf.shutdownCh:<br>				rf.logger.Warn(<span class="hljs-string">&quot;startApplyLogs goroutine shut down!!&quot;</span>,<span class="hljs-string">&quot;peer&quot;</span>,rf.me)<br>				<span class="hljs-keyword">return</span><br>			&#125;<br>		&#125;<br>	&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="accelerated-log-backtracking">Accelerated Log Backtracking</h2><p>To optimize accelerated log backtracking, we can follow these steps:</p><ol type="1"><li><p>If a follower <strong>does not</strong> have <code>prevLogIndex</code> in its log, it should return with <code>conflictIndex = len(log)</code> and <code>conflictTerm = None</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> lastSnapshotIndex &gt; args.PrevLogIndex || lastLogIndex &lt; args.PrevLogIndex &#123;<br>  <br>  reply.Term = currentTerm<br>  <br>  reply.Success = <span class="hljs-literal">false</span><br>  <br>  <span class="hljs-comment">// If a follower does not have prevLogIndex in its log</span><br>  <span class="hljs-comment">// it should return with conflictIndex = lastLogIndex + 1 and conflictTerm = None</span><br>  reply.ConflictIndex = lastLogIndex + <span class="hljs-number">1</span><br>  <br>  reply.ConflictTerm = <span class="hljs-number">0</span> <span class="hljs-comment">//represent conflictTerm = None.</span><br><br>  rf.persist()<br>  <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>If a follower does have <code>prevLogIndex</code> in its log, but the <strong>term does not match</strong>, it should return <code>conflictTerm = log[prevLogIndex].Term</code>, and then search its log for the first index whose entry has term equal to <code>conflictTerm</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getConflictTermIndex</span><span class="hljs-params">(conflictTerm <span class="hljs-type">uint64</span>,logEntries []Log)</span></span> <span class="hljs-type">uint64</span> &#123;<br>  <br>	<span class="hljs-comment">// all the indexes start from 1, so 0 means no conflict</span><br>	conflictIndex := <span class="hljs-type">uint64</span>(<span class="hljs-number">0</span>)<br>  <br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(logEntries); i++ &#123;<br>		<span class="hljs-keyword">if</span> logEntries[i].Term == conflictTerm &#123;<br>      <br>			<span class="hljs-comment">// conflictIndex = uint64(i + 1)</span><br>			<span class="hljs-comment">// conflictIndex is the actual index of the log !</span><br>			conflictIndex = logEntries[i].Index<br>      <br>			<span class="hljs-keyword">break</span><br>		&#125;<br>	&#125;<br>  <br>	<span class="hljs-keyword">return</span> conflictIndex<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> args.PrevLogTerm != prevLogTerm &#123;<br>		<br>    reply.Term = currentTerm<br>  <br>		reply.Success = <span class="hljs-literal">false</span><br>  <br>		<span class="hljs-comment">// If a follower does have prevLogIndex in its log, but the term does not match,</span><br>		<span class="hljs-comment">// it should return conflictTerm = log[prevLogIndex - 1].Term</span><br>		reply.ConflictTerm = prevLogTerm<br>  <br>    <span class="hljs-comment">// then search its log for the first index whose entry has term equal to conflictTerm.</span><br>		reply.ConflictIndex = getConflictTermIndex(prevLogTerm,originLogEntries)<br><br>		rf.persist()<br>		<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Upon receiving a conflict response, the leader should first search its log for <code>conflictTerm</code>. If it finds an entry in its log with that term, it should set <code>nextIndex</code> to be the one beyond the index of the <strong><em>last entry</em> </strong>in that term in its log.</p></li><li><p>If it does not find an entry with that term, it should set <code>nextIndex = conflictIndex</code>.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Raft)</span></span> lastConfictTermIndex(conflictTerm <span class="hljs-type">uint64</span>) (<span class="hljs-type">uint64</span>,<span class="hljs-type">bool</span>) &#123;<br>	entries := r.getLogEntries()<br>	founded := <span class="hljs-literal">false</span><br>  <br>	<span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">len</span>(entries); i++&#123;<br>    <br>		<span class="hljs-keyword">if</span> entries[i].Term==conflictTerm &#123;<br>			founded = <span class="hljs-literal">true</span><br>		&#125;<br>    <br>		<span class="hljs-keyword">if</span> entries[i].Term &gt; conflictTerm&#123;<br>			<span class="hljs-comment">//return uint64(i + 1),founded</span><br>			<span class="hljs-keyword">return</span> entries[i].Index,founded<br>		&#125;<br>    <br>	&#125;<br>  <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>,founded<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//If AppendEntries fails because of log inconsistency:</span><br><span class="hljs-comment">//decrement nextIndex and retry (§5.3)</span><br><br><span class="hljs-comment">// The accelerated log backtracking optimization</span><br><span class="hljs-comment">// Upon receiving a conflict response, the leader should first search its log for conflictTerm.</span><br>upperboundIndex, founded := r.lastConfictTermIndex(reply.ConflictTerm)<br><br><span class="hljs-keyword">if</span> founded &#123;<br>  <span class="hljs-comment">// If it finds an entry in its log with ConflictTerm,</span><br>	<span class="hljs-comment">// it should set nextIndex as the one beyond the index of the last entry in that term in its log.</span><br>	r.leaderState.setNextIndex(reply.ServerID, upperboundIndex)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  r.leaderState.setNextIndex(reply.ServerID, reply.ConflictIndex)<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="persistence">Persistence</h1><p>For the persistent content of the state, it is provided by the Figure 2 at the <em>State</em> part : <code>currentTerm</code>,<code>voteFor</code> and <code>log[]</code>. Besides, in <em>InstallSnapshot</em>, we also need to persist <code>lastIncludedIndex</code> and <code>lastIncludedTerm</code> in order to let server be able to restore the original state after the machine reboots.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> persistData() []<span class="hljs-type">byte</span> &#123;<br>	w := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>	e := gob.NewEncoder(w)<br>	e.Encode(rf.currentTerm)<br>	e.Encode(rf.votedFor)<br>	e.Encode(rf.logs)<br>	e.Encode(rf.lastSnapshotIndex)<br>	e.Encode(rf.lastSnapshotTerm)<br>	data := w.Bytes()<br>	<span class="hljs-keyword">return</span> data<br>&#125;<br></code></pre></td></tr></table></figure><p>And of course we should call <code>persist()</code> every time these contents of the state change.</p><h1 id="log-compaction">Log Compaction</h1><p>Raft implements log compaction through snapshot. Server persistently store a "snapshot" of their state from time to time, at which point Raft discards log entries that precede the snapshot.The result is a smaller amount of persistent data and faster restart.</p><p>However, it's now possible for a <strong>follower to fall so far behind that the leader</strong> has discarded the log entries it needs to catch up; <strong>the leader must then send a snapshot plus the log starting at the time of the snapshot.</strong></p><p>In Raft paper, Figure 12 can be a good illustration of the role of snapshots:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft12.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft Figure 12"><figcaption aria-hidden="true">lab2 Raft Figure 12</figcaption></figure><p>Simple explanation:</p><p>Suppose now that the updated information of x and y is stored in the log. The information of x is 3, 2, 0, 5 in sequence. The information of y is 1, 9, and 7 in sequence. And the <em>logs</em> with subscripts 1~ 5 have been committed, indicating that this log is no longer needed for the current node.</p><p>Then we access the last stored information as the <em>snapshot</em> (<code>persister.SaveStateAndSnapshot()</code>), that is, x=0, y=9, and record the log index (<code>lastIncludedIndex</code>) of the last snapshot storage and its corresponding term(<code>lastIncludedTerm</code>). At this point, our new <em>logs</em> only store the uncommitted index of 6 and 7, and the length of the <em>logs</em> has changed from 7 to 2.</p><p>We can start with the diagram of Raft interactions as mentioned above:</p><figure><img src="https://cdn.jsdelivr.net/gh/hswsp/IMAGE_HOST@main/img/raft-server.png" srcset="/img/loading.gif" lazyload alt="lab2 Raft interactions"><figcaption aria-hidden="true">lab2 Raft interactions</figcaption></figure><h2 id="functions-to-implement">Functions to Implement</h2><p>Lab 2 require us to implement <code>Snapshot()</code> ,<code>CondInstallSnapshot()</code> and the <strong><em>InstallSnapshot RPC</em></strong>.</p><p><code>Snapshot()</code> is actually called by the service to Raft, so that the Raft node updates its own snapshot information. Some one might argue that this violates Raft's principles of strong leadership. Because followers can update their own snapshots without the leader's knowledge. But in fact, this situation is reasonable. <strong>Updating the snapshot is only to update the data, which does not conflict with reaching a consensus. Data still only flows from the leader to the followers</strong>, followers just take snapshots to lighten their burden of storage.</p><p>The <em>snapshot</em> you send will be uploaded to <code>applyCh</code>, and at the same time your <em>AppendEntries</em> will also need to upload logs to <code>applyCh</code>, , which may cause conflicts. <code>CondInstallSnapshot()</code> is called to avoid the requirement that snapshots and log entries sent on <code>applyCh</code> are coordinated。But in fact, as long as you synchronize well when apply, adding a mutex, then this problem can be avoided. So you are discouraged from implementing it: instead, we suggest that you simply have it return true.</p><p>you need to send a <strong><em>InstallSnapshot RPC</em></strong> is actually when the log that the leader sends to the follower has been discarded. We add function <code>leaderSendSnapShot(server int)</code> to send the InstallSnapshot RPC. So where<code>leaderSendSnapShot()</code> called to send the snapshot should be during consistency check performed by AppendEntries RPCs. The condition is that <em>nextIndex</em> is lower than leader's snapshot: <code>rf.nextIndex[server] &lt; rf.lastIncludeIndex</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> nextIndex &lt; lastIncludeIndex&#123;<br>		r.logger.Info(<span class="hljs-string">&quot;InstallSnapShot to followers&quot;</span>,<span class="hljs-string">&quot;leader&quot;</span>,r.me,<span class="hljs-string">&quot; peer&quot;</span>,serverID,<br>			<span class="hljs-string">&quot;current term&quot;</span>,r.getCurrentTerm(),<span class="hljs-string">&quot; Replication RPC term&quot;</span>,s.Term)<br>		r.goFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;r.leaderSendSnapShot(serverID)&#125;)<br>		<span class="hljs-keyword">return</span> shouldStop<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="subscript-tips">Subscript Tips</h2><p>Every time you update <em>logs</em> during AppendEntries RPC process, you must take the subscript of the snapshot into count. There are two points you need to take into carefully consideration:</p><ol type="1"><li><p>After snapshot, the index(offset) of your log entries <code>log[]</code> should no longer be euqal to <code>Index</code> field of your <code>type Log struct</code>. Only <code>Log.Index</code> is actually the global index of all of your log entries.</p></li><li><p><strong>You need to do index conversion</strong> everywhere you use <code>log[]</code> in functions that process RPCs, like <code>func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply)</code> and <code>func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply)</code>.</p><p>For example, if you want to fetch <code>Term</code> according to <code>Log.Index</code>, you can use:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//get log term by index after snapshot</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(rf *Raft)</span></span> getLogTermByIndex(index <span class="hljs-type">uint64</span>) <span class="hljs-type">uint64</span> &#123;<br>  <br>	rf.lastLock.Lock()<br>	<span class="hljs-keyword">var</span> offset <span class="hljs-type">int64</span><br>	offset = <span class="hljs-type">int64</span>(index)-<span class="hljs-type">int64</span>(<span class="hljs-number">1</span> + rf.lastSnapshotIndex)  <span class="hljs-comment">// may overflow here, caution!!!!</span><br>  <br>	<span class="hljs-keyword">if</span> offset &lt; <span class="hljs-number">0</span> &#123;<br>		rf.lastLock.Unlock()<br>		<span class="hljs-keyword">return</span> rf.lastSnapshotTerm<br>	&#125;<br>	rf.lastLock.Unlock()<br><br>	rf.logsLock.Lock()<br>	<span class="hljs-keyword">defer</span> rf.logsLock.Unlock()<br>	<span class="hljs-keyword">return</span> rf.logs[offset].Term<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="reference">Reference</h1><ol type="1"><li><a target="_blank" rel="noopener" href="https://github.com/hashicorp/raft">hashicorp-raft</a></li><li><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">extended Raft paper</a></li><li><a target="_blank" rel="noopener" href="https://thesquareplanet.com/blog/students-guide-to-raft/">students-guide-to-raft</a></li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Distributed/" class="category-chain-item">Distributed</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Distributed/">#Distributed</a></div></div><div class="license-box my-3"><div class="license-title"><div>6.824 Lab 2 - Raft</div><div>https://umnchampagne.top/2022/09/17/Lab-2-Raft/</div></div><div class="license-meta"><div class="license-meta-item"><div>Author</div><div>Starry</div></div><div class="license-meta-item license-meta-date"><div>Posted on</div><div>September 17, 2022</div></div><div class="license-meta-item"><div>Licensed under</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - Attribution"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/10/18/LSM-tree/" title="LSM Tree:高性能海量数据写数据结构"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">LSM Tree:高性能海量数据写数据结构</span> <span class="visible-mobile">Previous</span></a></article><article class="post-next col-6"><a href="/2022/09/16/raft-3/" title="Raft 协议（三）—— 集群成员变更"><span class="hidden-mobile">Raft 协议（三）—— 集群成员变更</span> <span class="visible-mobile">Next</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div class="disqus" style="width:100%"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config=function(){this.page.url="https://umnchampagne.top/2022/09/17/Lab-2-Raft/",this.page.identifier="/2022/09/17/Lab-2-Raft/"};Fluid.utils.loadComments("#disqus_thread",(function(){var t=document,e=t.createElement("script");e.src="//fluid.disqus.com/embed.js",e.setAttribute("data-timestamp",new Date),(t.head||t.body).appendChild(e)}))</script><noscript>Please enable JavaScript to view the comments</noscript></div></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"})}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">Search</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">Keyword</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">京ICP证123456号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"> <span>京公网安备12345678号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var o=jQuery("#board-ctn").offset().top;window.tocbot.init({tocSelector:"#toc-body",contentSelector:".markdown-body",headingSelector:CONFIG.toc.headingSelector||"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:CONFIG.toc.collapseDepth||0,scrollSmooth:!0,headingsOffset:-o}),t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var o=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),n=[];for(var i of o)n.push(".markdown-body > "+i.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(n.join(", "))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/qipao.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/caidai.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/jingtaisidai.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiantiao.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxuehua.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/xiaoxingxing.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/timeDate.js"></script><script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/love.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">Blog works best with JavaScript enabled</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>